// #define ALLOW_STATIC_LIGHTING 1
// #define CLEAR_COAT_BOTTOM_NORMAL 0
// #define COMPILE_SHADERS_FOR_DEVELOPMENT 1
// #define COMPILER_DEFINE #define
// #define COMPUTESHADER 1
// #define DISKELMESH_BONE_INFLUENCES 0
// #define DOMAINSHADER 0
// #define DXT5_NORMALMAPS 0
// #define EARLY_Z_PASS_ONLY_MATERIAL_MASKING 0
// #define EIGHT_BIT_MESH_DISTANCE_FIELDS 0
// #define FORWARD_SHADING 0
// #define GBUFFER_HAS_TANGENT 0
// #define GBUFFER_HAS_VELOCITY 0
// #define GEOMETRYSHADER 0
// #define GPU_SIMULATION 1
// #define GPU_SIMULATION_SHADER 1
// #define HAS_INVERTED_Z_BUFFER 1
// #define HULLSHADER 0
// #define INSTANCED_STEREO 0
// #define IRIS_NORMAL 0
// #define MOBILE_MULTI_VIEW 0
// #define MULTI_VIEW 0
// #define NIAGARA_MAX_GPU_SPAWN_INFOS 8
// #define ODS_CAPTURE 0
// #define PIXELSHADER 0
// #define PLATFORM_SUPPORTS_DISTANCE_FIELDS 1
// #define PLATFORM_SUPPORTS_PER_PIXEL_DBUFFER_MASK 0
// #define PLATFORM_SUPPORTS_RENDERTARGET_WRITE_MASK 0
// #define PLATFORM_SUPPORTS_SRV_UB 1
// #define POST_PROCESS_ALPHA 0
// #define PROJECT_ALLOW_GLOBAL_CLIP_PLANE 0
// #define PROJECT_MOBILE_DISABLE_VERTEX_FOG 1
// #define PROJECT_MOBILE_USE_LEGACY_SHADING 0
// #define PROJECT_SUPPORT_SKY_ATMOSPHERE 1
// #define PROJECT_SUPPORT_SKY_ATMOSPHERE_AFFECTS_HEIGHFOG 0
// #define PROJECT_VERTEX_FOGGING_FOR_OPAQUE 0
// #define RAYCALLABLESHADER 0
// #define RAYGENSHADER 0
// #define RAYHITGROUPSHADER 0
// #define RAYMISSSHADER 0
// #define SELECTIVE_BASEPASS_OUTPUTS 0
// #define SHADING_PATH_DEFERRED 1
// #define THREADGROUP_SIZE 32
// #define USE_DBUFFER 1
// #define USE_PREEXPOSURE 1
// #define USE_SIMULATION_STAGES 0
// #define VERTEXSHADER 0
// #define VIRTUAL_TEXTURE_FEEDBACK_FACTOR 16
#line 1 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 6 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#pragma warning(disable:4008)
#line 7 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 1 "/Engine/Public/Platform.ush"
#line 9 "/Engine/Public/Platform.ush"
#line 1 "FP16Math.ush"
#line 10 "/Engine/Public/Platform.ush"
#line 37 "/Engine/Public/Platform.ush"
#line 1 "Platform/D3D/D3DCommon.ush"
#line 7 "/Engine/Public/Platform/D3D/D3DCommon.ush"
precise float MakePrecise(precise float v) { return v; }
precise float2 MakePrecise(precise float2 v) { return v; }
precise float3 MakePrecise(precise float3 v) { return v; }
precise float4 MakePrecise(precise float4 v) { return v; }
#line 38 "/Engine/Public/Platform.ush"
#line 43 "/Engine/Public/Platform.ush"
#line 1 "ShaderVersion.ush"
#line 44 "/Engine/Public/Platform.ush"
#line 595 "/Engine/Public/Platform.ush"
float min3( float a, float b, float c )
{
	return min( a, min( b, c ) );
}

float max3( float a, float b, float c )
{
	return max( a, max( b, c ) );
}

float2 min3( float2 a, float2 b, float2 c )
{
	return float2(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y )
	);
}

float2 max3( float2 a, float2 b, float2 c )
{
	return float2(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y )
	);
}

float3 max3( float3 a, float3 b, float3 c )
{
	return float3(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z )
	);
}

float3 min3( float3 a, float3 b, float3 c )
{
	return float3(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z )
	);
}

float4 min3( float4 a, float4 b, float4 c )
{
	return float4(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z ),
		min3( a.w, b.w, c.w )
	);
}

float4 max3( float4 a, float4 b, float4 c )
{
	return float4(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z ),
		max3( a.w, b.w, c.w )
	);
}




float UnpackByte0(uint v) { return float(v & 0xff); }
float UnpackByte1(uint v) { return float((v >> 8) & 0xff); }
float UnpackByte2(uint v) { return float((v >> 16) & 0xff); }
float UnpackByte3(uint v) { return float(v >> 24); }
#line 8 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 11 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 1 "/Engine/Private/Common.ush"
#line 61 "/Engine/Private/Common.ush"
#line 1 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"


cbuffer View
{
	float4x4 View_TranslatedWorldToClip;
	float4x4 View_WorldToClip;
	float4x4 View_ClipToWorld;
	float4x4 View_TranslatedWorldToView;
	float4x4 View_ViewToTranslatedWorld;
	float4x4 View_TranslatedWorldToCameraView;
	float4x4 View_CameraViewToTranslatedWorld;
	float4x4 View_ViewToClip;
	float4x4 View_ViewToClipNoAA;
	float4x4 View_ClipToView;
	float4x4 View_ClipToTranslatedWorld;
	float4x4 View_SVPositionToTranslatedWorld;
	float4x4 View_ScreenToWorld;
	float4x4 View_ScreenToTranslatedWorld;
	float4x4 View_MobileMultiviewShadowTransform;
	float3  View_ViewForward;
	float  PrePadding_View_972;
	float3  View_ViewUp;
	float  PrePadding_View_988;
	float3  View_ViewRight;
	float  PrePadding_View_1004;
	float3  View_HMDViewNoRollUp;
	float  PrePadding_View_1020;
	float3  View_HMDViewNoRollRight;
	float  PrePadding_View_1036;
	float4 View_InvDeviceZToWorldZTransform;
	float4  View_ScreenPositionScaleBias;
	float3 View_WorldCameraOrigin;
	float PrePadding_View_1084;
	float3 View_TranslatedWorldCameraOrigin;
	float PrePadding_View_1100;
	float3 View_WorldViewOrigin;
	float PrePadding_View_1116;
	float3 View_PreViewTranslation;
	float PrePadding_View_1132;
	float4x4 View_PrevProjection;
	float4x4 View_PrevViewProj;
	float4x4 View_PrevViewRotationProj;
	float4x4 View_PrevViewToClip;
	float4x4 View_PrevClipToView;
	float4x4 View_PrevTranslatedWorldToClip;
	float4x4 View_PrevTranslatedWorldToView;
	float4x4 View_PrevViewToTranslatedWorld;
	float4x4 View_PrevTranslatedWorldToCameraView;
	float4x4 View_PrevCameraViewToTranslatedWorld;
	float3 View_PrevWorldCameraOrigin;
	float PrePadding_View_1788;
	float3 View_PrevWorldViewOrigin;
	float PrePadding_View_1804;
	float3 View_PrevPreViewTranslation;
	float PrePadding_View_1820;
	float4x4 View_PrevInvViewProj;
	float4x4 View_PrevScreenToTranslatedWorld;
	float4x4 View_ClipToPrevClip;
	float4 View_TemporalAAJitter;
	float4 View_GlobalClippingPlane;
	float2 View_FieldOfViewWideAngles;
	float2 View_PrevFieldOfViewWideAngles;
	float4  View_ViewRectMin;
	float4 View_ViewSizeAndInvSize;
	float4 View_BufferSizeAndInvSize;
	float4 View_BufferBilinearUVMinMax;
	float4 View_ScreenToViewSpace;
	int View_NumSceneColorMSAASamples;
	float  View_PreExposure;
	float  View_OneOverPreExposure;
	float  PrePadding_View_2156;
	float4  View_DiffuseOverrideParameter;
	float4  View_SpecularOverrideParameter;
	float4  View_NormalOverrideParameter;
	float2  View_RoughnessOverrideParameter;
	float View_PrevFrameGameTime;
	float View_PrevFrameRealTime;
	float  View_OutOfBoundsMask;
	float  PrePadding_View_2228;
	float  PrePadding_View_2232;
	float  PrePadding_View_2236;
	float3 View_WorldCameraMovementSinceLastFrame;
	float View_CullingSign;
	float  View_NearPlane;
	float View_AdaptiveTessellationFactor;
	float View_GameTime;
	float View_RealTime;
	float View_DeltaTime;
	float View_MaterialTextureMipBias;
	float View_MaterialTextureDerivativeMultiply;
	uint View_Random;
	uint View_FrameNumber;
	uint View_StateFrameIndexMod8;
	uint View_StateFrameIndex;
	uint View_DebugViewModeMask;
	float  View_CameraCut;
	float  View_UnlitViewmodeMask;
	float  PrePadding_View_2312;
	float  PrePadding_View_2316;
	float4  View_DirectionalLightColor;
	float3  View_DirectionalLightDirection;
	float  PrePadding_View_2348;
	float4 View_TranslucencyLightingVolumeMin[2];
	float4 View_TranslucencyLightingVolumeInvSize[2];
	float4 View_TemporalAAParams;
	float4 View_CircleDOFParams;
	float View_DepthOfFieldSensorWidth;
	float View_DepthOfFieldFocalDistance;
	float View_DepthOfFieldScale;
	float View_DepthOfFieldFocalLength;
	float View_DepthOfFieldFocalRegion;
	float View_DepthOfFieldNearTransitionRegion;
	float View_DepthOfFieldFarTransitionRegion;
	float View_MotionBlurNormalizedToPixel;
	float View_bSubsurfacePostprocessEnabled;
	float View_GeneralPurposeTweak;
	float  View_DemosaicVposOffset;
	float  PrePadding_View_2492;
	float3 View_IndirectLightingColorScale;
	float  View_AtmosphericFogSunPower;
	float  View_AtmosphericFogPower;
	float  View_AtmosphericFogDensityScale;
	float  View_AtmosphericFogDensityOffset;
	float  View_AtmosphericFogGroundOffset;
	float  View_AtmosphericFogDistanceScale;
	float  View_AtmosphericFogAltitudeScale;
	float  View_AtmosphericFogHeightScaleRayleigh;
	float  View_AtmosphericFogStartDistance;
	float  View_AtmosphericFogDistanceOffset;
	float  View_AtmosphericFogSunDiscScale;
	float  PrePadding_View_2552;
	float  PrePadding_View_2556;
	float4 View_AtmosphereLightDirection[2];
	float4 View_AtmosphereLightColor[2];
	float4 View_AtmosphereLightColorGlobalPostTransmittance[2];
	float4 View_AtmosphereLightDiscLuminance[2];
	float4 View_AtmosphereLightDiscCosHalfApexAngle[2];
	float4 View_SkyViewLutSizeAndInvSize;
	float3 View_SkyWorldCameraOrigin;
	float PrePadding_View_2748;
	float4 View_SkyPlanetCenterAndViewHeight;
	float4 View_SkyAtmosphereSkyLuminanceFactor;
	float View_SkyAtmosphereHeightFogContribution;
	float View_SkyAtmosphereBottomRadiusKm;
	float View_SkyAtmosphereTopRadiusKm;
	float View_SkyAtmosphereAerialPerspectiveStartDepthKm;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float View_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	uint View_AtmosphericFogRenderMask;
	uint View_AtmosphericFogInscatterAltitudeSampleNum;
	uint PrePadding_View_2828;
	float3 View_NormalCurvatureToRoughnessScaleBias;
	float View_RenderingReflectionCaptureMask;
	float4 View_AmbientCubemapTint;
	float View_AmbientCubemapIntensity;
	float View_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float View_SkyLightAffectReflectionFlag;
	float View_SkyLightAffectGlobalIlluminationFlag;
	float4 View_SkyLightColor;
	float4 View_SkyIrradianceEnvironmentMap[7];
	float View_MobilePreviewMode;
	float View_HMDEyePaddingOffset;
	float  View_ReflectionCubemapMaxMip;
	float View_ShowDecalsMask;
	uint View_DistanceFieldAOSpecularOcclusionMode;
	float View_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_View_3032;
	float PrePadding_View_3036;
	float3 View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int View_StereoPassIndex;
	float4 View_GlobalVolumeCenterAndExtent[4];
	float4 View_GlobalVolumeWorldToUVAddAndMul[4];
	float View_GlobalVolumeDimension;
	float View_GlobalVolumeTexelSize;
	float View_MaxGlobalDistance;
	float PrePadding_View_3196;
	int2 View_CursorPosition;
	float View_bCheckerboardSubsurfaceProfileRendering;
	float PrePadding_View_3212;
	float3 View_VolumetricFogInvGridSize;
	float PrePadding_View_3228;
	float3 View_VolumetricFogGridZParams;
	float PrePadding_View_3244;
	float2 View_VolumetricFogSVPosToVolumeUV;
	float View_VolumetricFogMaxDistance;
	float PrePadding_View_3260;
	float3 View_VolumetricLightmapWorldToUVScale;
	float PrePadding_View_3276;
	float3 View_VolumetricLightmapWorldToUVAdd;
	float PrePadding_View_3292;
	float3 View_VolumetricLightmapIndirectionTextureSize;
	float View_VolumetricLightmapBrickSize;
	float3 View_VolumetricLightmapBrickTexelSize;
	float View_StereoIPD;
	float View_IndirectLightingCacheShowFlag;
	float View_EyeToPixelSpreadAngle;
	float PrePadding_View_3336;
	float PrePadding_View_3340;
	float4x4 View_WorldToVirtualTexture;
	float4 View_XRPassthroughCameraUVs[2];
	uint View_VirtualTextureFeedbackStride;
	uint PrePadding_View_3444;
	uint PrePadding_View_3448;
	uint PrePadding_View_3452;
	float4 View_RuntimeVirtualTextureMipLevel;
	float2 View_RuntimeVirtualTexturePackHeight;
	float PrePadding_View_3480;
	float PrePadding_View_3484;
	float4 View_RuntimeVirtualTextureDebugParams;
	int View_FarShadowStaticMeshLODBias;
	float View_MinRoughness;
	float PrePadding_View_3512;
	float PrePadding_View_3516;
	float4 View_HairRenderInfo;
	uint View_HairRenderInfoBits;
}
SamplerState View_MaterialTextureBilinearWrapedSampler;
SamplerState View_MaterialTextureBilinearClampedSampler;
Texture3D<uint4> View_VolumetricLightmapIndirectionTexture;
Texture3D View_VolumetricLightmapBrickAmbientVector;
Texture3D View_VolumetricLightmapBrickSHCoefficients0;
Texture3D View_VolumetricLightmapBrickSHCoefficients1;
Texture3D View_VolumetricLightmapBrickSHCoefficients2;
Texture3D View_VolumetricLightmapBrickSHCoefficients3;
Texture3D View_VolumetricLightmapBrickSHCoefficients4;
Texture3D View_VolumetricLightmapBrickSHCoefficients5;
Texture3D View_SkyBentNormalBrickTexture;
Texture3D View_DirectionalLightShadowingBrickTexture;
SamplerState View_VolumetricLightmapBrickAmbientVectorSampler;
SamplerState View_VolumetricLightmapTextureSampler0;
SamplerState View_VolumetricLightmapTextureSampler1;
SamplerState View_VolumetricLightmapTextureSampler2;
SamplerState View_VolumetricLightmapTextureSampler3;
SamplerState View_VolumetricLightmapTextureSampler4;
SamplerState View_VolumetricLightmapTextureSampler5;
SamplerState View_SkyBentNormalTextureSampler;
SamplerState View_DirectionalLightShadowingTextureSampler;
Texture3D View_GlobalDistanceFieldTexture0;
SamplerState View_GlobalDistanceFieldSampler0;
Texture3D View_GlobalDistanceFieldTexture1;
SamplerState View_GlobalDistanceFieldSampler1;
Texture3D View_GlobalDistanceFieldTexture2;
SamplerState View_GlobalDistanceFieldSampler2;
Texture3D View_GlobalDistanceFieldTexture3;
SamplerState View_GlobalDistanceFieldSampler3;
Texture2D View_AtmosphereTransmittanceTexture;
SamplerState View_AtmosphereTransmittanceTextureSampler;
Texture2D View_AtmosphereIrradianceTexture;
SamplerState View_AtmosphereIrradianceTextureSampler;
Texture3D View_AtmosphereInscatterTexture;
SamplerState View_AtmosphereInscatterTextureSampler;
Texture2D View_PerlinNoiseGradientTexture;
SamplerState View_PerlinNoiseGradientTextureSampler;
Texture3D View_PerlinNoise3DTexture;
SamplerState View_PerlinNoise3DTextureSampler;
Texture2D<uint> View_SobolSamplingTexture;
SamplerState View_SharedPointWrappedSampler;
SamplerState View_SharedPointClampedSampler;
SamplerState View_SharedBilinearWrappedSampler;
SamplerState View_SharedBilinearClampedSampler;
SamplerState View_SharedTrilinearWrappedSampler;
SamplerState View_SharedTrilinearClampedSampler;
Texture2D View_PreIntegratedBRDF;
SamplerState View_PreIntegratedBRDFSampler;
StructuredBuffer<float4> View_PrimitiveSceneData;
Texture2D<float4> View_PrimitiveSceneDataTexture;
StructuredBuffer<float4> View_LightmapSceneData;
Texture2D View_TransmittanceLutTexture;
SamplerState View_TransmittanceLutTextureSampler;
Texture2D View_SkyViewLutTexture;
SamplerState View_SkyViewLutTextureSampler;
Texture2D View_DistantSkyLightLutTexture;
SamplerState View_DistantSkyLightLutTextureSampler;
Texture3D View_CameraAerialPerspectiveVolume;
SamplerState View_CameraAerialPerspectiveVolumeSampler;
RWBuffer<uint> View_VTFeedbackBuffer;
RWTexture2D<uint> View_QuadOverdraw;
/*atic const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightColor[2];
	float4 AtmosphereLightColorGlobalPostTransmittance[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyWorldCameraOrigin;
	float4 SkyPlanetCenterAndViewHeight;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4x4 WorldToVirtualTexture;
	float4 XRPassthroughCameraUVs[2];
	uint VirtualTextureFeedbackStride;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint HairRenderInfoBits;
	SamplerState MaterialTextureBilinearWrapedSampler;
	SamplerState MaterialTextureBilinearClampedSampler;
	Texture3D<uint4> VolumetricLightmapIndirectionTexture;
	Texture3D VolumetricLightmapBrickAmbientVector;
	Texture3D VolumetricLightmapBrickSHCoefficients0;
	Texture3D VolumetricLightmapBrickSHCoefficients1;
	Texture3D VolumetricLightmapBrickSHCoefficients2;
	Texture3D VolumetricLightmapBrickSHCoefficients3;
	Texture3D VolumetricLightmapBrickSHCoefficients4;
	Texture3D VolumetricLightmapBrickSHCoefficients5;
	Texture3D SkyBentNormalBrickTexture;
	Texture3D DirectionalLightShadowingBrickTexture;
	SamplerState VolumetricLightmapBrickAmbientVectorSampler;
	SamplerState VolumetricLightmapTextureSampler0;
	SamplerState VolumetricLightmapTextureSampler1;
	SamplerState VolumetricLightmapTextureSampler2;
	SamplerState VolumetricLightmapTextureSampler3;
	SamplerState VolumetricLightmapTextureSampler4;
	SamplerState VolumetricLightmapTextureSampler5;
	SamplerState SkyBentNormalTextureSampler;
	SamplerState DirectionalLightShadowingTextureSampler;
	Texture3D GlobalDistanceFieldTexture0;
	SamplerState GlobalDistanceFieldSampler0;
	Texture3D GlobalDistanceFieldTexture1;
	SamplerState GlobalDistanceFieldSampler1;
	Texture3D GlobalDistanceFieldTexture2;
	SamplerState GlobalDistanceFieldSampler2;
	Texture3D GlobalDistanceFieldTexture3;
	SamplerState GlobalDistanceFieldSampler3;
	Texture2D AtmosphereTransmittanceTexture;
	SamplerState AtmosphereTransmittanceTextureSampler;
	Texture2D AtmosphereIrradianceTexture;
	SamplerState AtmosphereIrradianceTextureSampler;
	Texture3D AtmosphereInscatterTexture;
	SamplerState AtmosphereInscatterTextureSampler;
	Texture2D PerlinNoiseGradientTexture;
	SamplerState PerlinNoiseGradientTextureSampler;
	Texture3D PerlinNoise3DTexture;
	SamplerState PerlinNoise3DTextureSampler;
	Texture2D<uint> SobolSamplingTexture;
	SamplerState SharedPointWrappedSampler;
	SamplerState SharedPointClampedSampler;
	SamplerState SharedBilinearWrappedSampler;
	SamplerState SharedBilinearClampedSampler;
	SamplerState SharedTrilinearWrappedSampler;
	SamplerState SharedTrilinearClampedSampler;
	Texture2D PreIntegratedBRDF;
	SamplerState PreIntegratedBRDFSampler;
	StructuredBuffer<float4> PrimitiveSceneData;
	Texture2D<float4> PrimitiveSceneDataTexture;
	StructuredBuffer<float4> LightmapSceneData;
	Texture2D TransmittanceLutTexture;
	SamplerState TransmittanceLutTextureSampler;
	Texture2D SkyViewLutTexture;
	SamplerState SkyViewLutTextureSampler;
	Texture2D DistantSkyLightLutTexture;
	SamplerState DistantSkyLightLutTextureSampler;
	Texture3D CameraAerialPerspectiveVolume;
	SamplerState CameraAerialPerspectiveVolumeSampler;
	RWBuffer<uint> VTFeedbackBuffer;
	RWTexture2D<uint> QuadOverdraw;
} View = {View_TranslatedWorldToClip,View_WorldToClip,View_ClipToWorld,View_TranslatedWorldToView,View_ViewToTranslatedWorld,View_TranslatedWorldToCameraView,View_CameraViewToTranslatedWorld,View_ViewToClip,View_ViewToClipNoAA,View_ClipToView,View_ClipToTranslatedWorld,View_SVPositionToTranslatedWorld,View_ScreenToWorld,View_ScreenToTranslatedWorld,View_MobileMultiviewShadowTransform,View_ViewForward,View_ViewUp,View_ViewRight,View_HMDViewNoRollUp,View_HMDViewNoRollRight,View_InvDeviceZToWorldZTransform,View_ScreenPositionScaleBias,View_WorldCameraOrigin,View_TranslatedWorldCameraOrigin,View_WorldViewOrigin,View_PreViewTranslation,View_PrevProjection,View_PrevViewProj,View_PrevViewRotationProj,View_PrevViewToClip,View_PrevClipToView,View_PrevTranslatedWorldToClip,View_PrevTranslatedWorldToView,View_PrevViewToTranslatedWorld,View_PrevTranslatedWorldToCameraView,View_PrevCameraViewToTranslatedWorld,View_PrevWorldCameraOrigin,View_PrevWorldViewOrigin,View_PrevPreViewTranslation,View_PrevInvViewProj,View_PrevScreenToTranslatedWorld,View_ClipToPrevClip,View_TemporalAAJitter,View_GlobalClippingPlane,View_FieldOfViewWideAngles,View_PrevFieldOfViewWideAngles,View_ViewRectMin,View_ViewSizeAndInvSize,View_BufferSizeAndInvSize,View_BufferBilinearUVMinMax,View_ScreenToViewSpace,View_NumSceneColorMSAASamples,View_PreExposure,View_OneOverPreExposure,View_DiffuseOverrideParameter,View_SpecularOverrideParameter,View_NormalOverrideParameter,View_RoughnessOverrideParameter,View_PrevFrameGameTime,View_PrevFrameRealTime,View_OutOfBoundsMask,View_WorldCameraMovementSinceLastFrame,View_CullingSign,View_NearPlane,View_AdaptiveTessellationFactor,View_GameTime,View_RealTime,View_DeltaTime,View_MaterialTextureMipBias,View_MaterialTextureDerivativeMultiply,View_Random,View_FrameNumber,View_StateFrameIndexMod8,View_StateFrameIndex,View_DebugViewModeMask,View_CameraCut,View_UnlitViewmodeMask,View_DirectionalLightColor,View_DirectionalLightDirection,View_TranslucencyLightingVolumeMin,View_TranslucencyLightingVolumeInvSize,View_TemporalAAParams,View_CircleDOFParams,View_DepthOfFieldSensorWidth,View_DepthOfFieldFocalDistance,View_DepthOfFieldScale,View_DepthOfFieldFocalLength,View_DepthOfFieldFocalRegion,View_DepthOfFieldNearTransitionRegion,View_DepthOfFieldFarTransitionRegion,View_MotionBlurNormalizedToPixel,View_bSubsurfacePostprocessEnabled,View_GeneralPurposeTweak,View_DemosaicVposOffset,View_IndirectLightingColorScale,View_AtmosphericFogSunPower,View_AtmosphericFogPower,View_AtmosphericFogDensityScale,View_AtmosphericFogDensityOffset,View_AtmosphericFogGroundOffset,View_AtmosphericFogDistanceScale,View_AtmosphericFogAltitudeScale,View_AtmosphericFogHeightScaleRayleigh,View_AtmosphericFogStartDistance,View_AtmosphericFogDistanceOffset,View_AtmosphericFogSunDiscScale,View_AtmosphereLightDirection,View_AtmosphereLightColor,View_AtmosphereLightColorGlobalPostTransmittance,View_AtmosphereLightDiscLuminance,View_AtmosphereLightDiscCosHalfApexAngle,View_SkyViewLutSizeAndInvSize,View_SkyWorldCameraOrigin,View_SkyPlanetCenterAndViewHeight,View_SkyAtmosphereSkyLuminanceFactor,View_SkyAtmosphereHeightFogContribution,View_SkyAtmosphereBottomRadiusKm,View_SkyAtmosphereTopRadiusKm,View_SkyAtmosphereAerialPerspectiveStartDepthKm,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv,View_SkyAtmosphereApplyCameraAerialPerspectiveVolume,View_AtmosphericFogRenderMask,View_AtmosphericFogInscatterAltitudeSampleNum,View_NormalCurvatureToRoughnessScaleBias,View_RenderingReflectionCaptureMask,View_AmbientCubemapTint,View_AmbientCubemapIntensity,View_SkyLightApplyPrecomputedBentNormalShadowingFlag,View_SkyLightAffectReflectionFlag,View_SkyLightAffectGlobalIlluminationFlag,View_SkyLightColor,View_SkyIrradianceEnvironmentMap,View_MobilePreviewMode,View_HMDEyePaddingOffset,View_ReflectionCubemapMaxMip,View_ShowDecalsMask,View_DistanceFieldAOSpecularOcclusionMode,View_IndirectCapsuleSelfShadowingIntensity,View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,View_StereoPassIndex,View_GlobalVolumeCenterAndExtent,View_GlobalVolumeWorldToUVAddAndMul,View_GlobalVolumeDimension,View_GlobalVolumeTexelSize,View_MaxGlobalDistance,View_CursorPosition,View_bCheckerboardSubsurfaceProfileRendering,View_VolumetricFogInvGridSize,View_VolumetricFogGridZParams,View_VolumetricFogSVPosToVolumeUV,View_VolumetricFogMaxDistance,View_VolumetricLightmapWorldToUVScale,View_VolumetricLightmapWorldToUVAdd,View_VolumetricLightmapIndirectionTextureSize,View_VolumetricLightmapBrickSize,View_VolumetricLightmapBrickTexelSize,View_StereoIPD,View_IndirectLightingCacheShowFlag,View_EyeToPixelSpreadAngle,View_WorldToVirtualTexture,View_XRPassthroughCameraUVs,View_VirtualTextureFeedbackStride,View_RuntimeVirtualTextureMipLevel,View_RuntimeVirtualTexturePackHeight,View_RuntimeVirtualTextureDebugParams,View_FarShadowStaticMeshLODBias,View_MinRoughness,View_HairRenderInfo,View_HairRenderInfoBits,View_MaterialTextureBilinearWrapedSampler,View_MaterialTextureBilinearClampedSampler,View_VolumetricLightmapIndirectionTexture,View_VolumetricLightmapBrickAmbientVector,View_VolumetricLightmapBrickSHCoefficients0,View_VolumetricLightmapBrickSHCoefficients1,View_VolumetricLightmapBrickSHCoefficients2,View_VolumetricLightmapBrickSHCoefficients3,View_VolumetricLightmapBrickSHCoefficients4,View_VolumetricLightmapBrickSHCoefficients5,View_SkyBentNormalBrickTexture,View_DirectionalLightShadowingBrickTexture,View_VolumetricLightmapBrickAmbientVectorSampler,View_VolumetricLightmapTextureSampler0,View_VolumetricLightmapTextureSampler1,View_VolumetricLightmapTextureSampler2,View_VolumetricLightmapTextureSampler3,View_VolumetricLightmapTextureSampler4,View_VolumetricLightmapTextureSampler5,View_SkyBentNormalTextureSampler,View_DirectionalLightShadowingTextureSampler,View_GlobalDistanceFieldTexture0,View_GlobalDistanceFieldSampler0,View_GlobalDistanceFieldTexture1,View_GlobalDistanceFieldSampler1,View_GlobalDistanceFieldTexture2,View_GlobalDistanceFieldSampler2,View_GlobalDistanceFieldTexture3,View_GlobalDistanceFieldSampler3,View_AtmosphereTransmittanceTexture,View_AtmosphereTransmittanceTextureSampler,View_AtmosphereIrradianceTexture,View_AtmosphereIrradianceTextureSampler,View_AtmosphereInscatterTexture,View_AtmosphereInscatterTextureSampler,View_PerlinNoiseGradientTexture,View_PerlinNoiseGradientTextureSampler,View_PerlinNoise3DTexture,View_PerlinNoise3DTextureSampler,View_SobolSamplingTexture,View_SharedPointWrappedSampler,View_SharedPointClampedSampler,View_SharedBilinearWrappedSampler,View_SharedBilinearClampedSampler,View_SharedTrilinearWrappedSampler,View_SharedTrilinearClampedSampler,View_PreIntegratedBRDF,View_PreIntegratedBRDFSampler,  View_PrimitiveSceneData,  View_PrimitiveSceneDataTexture,  View_LightmapSceneData,  View_TransmittanceLutTexture,View_TransmittanceLutTextureSampler,View_SkyViewLutTexture,View_SkyViewLutTextureSampler,View_DistantSkyLightLutTexture,View_DistantSkyLightLutTextureSampler,View_CameraAerialPerspectiveVolume,View_CameraAerialPerspectiveVolumeSampler,View_VTFeedbackBuffer,View_QuadOverdraw,*/
#line 2 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/DrawRectangleParameters.ush"


cbuffer DrawRectangleParameters
{
	float4 DrawRectangleParameters_PosScaleBias;
	float4 DrawRectangleParameters_UVScaleBias;
	float4 DrawRectangleParameters_InvTargetSizeAndTextureSize;
}
/*atic const struct
{
	float4 PosScaleBias;
	float4 UVScaleBias;
	float4 InvTargetSizeAndTextureSize;
} DrawRectangleParameters = {DrawRectangleParameters_PosScaleBias,DrawRectangleParameters_UVScaleBias,DrawRectangleParameters_InvTargetSizeAndTextureSize,*/
#line 3 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"


cbuffer InstancedView
{
	float4x4 InstancedView_TranslatedWorldToClip;
	float4x4 InstancedView_WorldToClip;
	float4x4 InstancedView_ClipToWorld;
	float4x4 InstancedView_TranslatedWorldToView;
	float4x4 InstancedView_ViewToTranslatedWorld;
	float4x4 InstancedView_TranslatedWorldToCameraView;
	float4x4 InstancedView_CameraViewToTranslatedWorld;
	float4x4 InstancedView_ViewToClip;
	float4x4 InstancedView_ViewToClipNoAA;
	float4x4 InstancedView_ClipToView;
	float4x4 InstancedView_ClipToTranslatedWorld;
	float4x4 InstancedView_SVPositionToTranslatedWorld;
	float4x4 InstancedView_ScreenToWorld;
	float4x4 InstancedView_ScreenToTranslatedWorld;
	float4x4 InstancedView_MobileMultiviewShadowTransform;
	float3  InstancedView_ViewForward;
	float  PrePadding_InstancedView_972;
	float3  InstancedView_ViewUp;
	float  PrePadding_InstancedView_988;
	float3  InstancedView_ViewRight;
	float  PrePadding_InstancedView_1004;
	float3  InstancedView_HMDViewNoRollUp;
	float  PrePadding_InstancedView_1020;
	float3  InstancedView_HMDViewNoRollRight;
	float  PrePadding_InstancedView_1036;
	float4 InstancedView_InvDeviceZToWorldZTransform;
	float4  InstancedView_ScreenPositionScaleBias;
	float3 InstancedView_WorldCameraOrigin;
	float PrePadding_InstancedView_1084;
	float3 InstancedView_TranslatedWorldCameraOrigin;
	float PrePadding_InstancedView_1100;
	float3 InstancedView_WorldViewOrigin;
	float PrePadding_InstancedView_1116;
	float3 InstancedView_PreViewTranslation;
	float PrePadding_InstancedView_1132;
	float4x4 InstancedView_PrevProjection;
	float4x4 InstancedView_PrevViewProj;
	float4x4 InstancedView_PrevViewRotationProj;
	float4x4 InstancedView_PrevViewToClip;
	float4x4 InstancedView_PrevClipToView;
	float4x4 InstancedView_PrevTranslatedWorldToClip;
	float4x4 InstancedView_PrevTranslatedWorldToView;
	float4x4 InstancedView_PrevViewToTranslatedWorld;
	float4x4 InstancedView_PrevTranslatedWorldToCameraView;
	float4x4 InstancedView_PrevCameraViewToTranslatedWorld;
	float3 InstancedView_PrevWorldCameraOrigin;
	float PrePadding_InstancedView_1788;
	float3 InstancedView_PrevWorldViewOrigin;
	float PrePadding_InstancedView_1804;
	float3 InstancedView_PrevPreViewTranslation;
	float PrePadding_InstancedView_1820;
	float4x4 InstancedView_PrevInvViewProj;
	float4x4 InstancedView_PrevScreenToTranslatedWorld;
	float4x4 InstancedView_ClipToPrevClip;
	float4 InstancedView_TemporalAAJitter;
	float4 InstancedView_GlobalClippingPlane;
	float2 InstancedView_FieldOfViewWideAngles;
	float2 InstancedView_PrevFieldOfViewWideAngles;
	float4  InstancedView_ViewRectMin;
	float4 InstancedView_ViewSizeAndInvSize;
	float4 InstancedView_BufferSizeAndInvSize;
	float4 InstancedView_BufferBilinearUVMinMax;
	float4 InstancedView_ScreenToViewSpace;
	int InstancedView_NumSceneColorMSAASamples;
	float  InstancedView_PreExposure;
	float  InstancedView_OneOverPreExposure;
	float  PrePadding_InstancedView_2156;
	float4  InstancedView_DiffuseOverrideParameter;
	float4  InstancedView_SpecularOverrideParameter;
	float4  InstancedView_NormalOverrideParameter;
	float2  InstancedView_RoughnessOverrideParameter;
	float InstancedView_PrevFrameGameTime;
	float InstancedView_PrevFrameRealTime;
	float  InstancedView_OutOfBoundsMask;
	float  PrePadding_InstancedView_2228;
	float  PrePadding_InstancedView_2232;
	float  PrePadding_InstancedView_2236;
	float3 InstancedView_WorldCameraMovementSinceLastFrame;
	float InstancedView_CullingSign;
	float  InstancedView_NearPlane;
	float InstancedView_AdaptiveTessellationFactor;
	float InstancedView_GameTime;
	float InstancedView_RealTime;
	float InstancedView_DeltaTime;
	float InstancedView_MaterialTextureMipBias;
	float InstancedView_MaterialTextureDerivativeMultiply;
	uint InstancedView_Random;
	uint InstancedView_FrameNumber;
	uint InstancedView_StateFrameIndexMod8;
	uint InstancedView_StateFrameIndex;
	uint InstancedView_DebugViewModeMask;
	float  InstancedView_CameraCut;
	float  InstancedView_UnlitViewmodeMask;
	float  PrePadding_InstancedView_2312;
	float  PrePadding_InstancedView_2316;
	float4  InstancedView_DirectionalLightColor;
	float3  InstancedView_DirectionalLightDirection;
	float  PrePadding_InstancedView_2348;
	float4 InstancedView_TranslucencyLightingVolumeMin[2];
	float4 InstancedView_TranslucencyLightingVolumeInvSize[2];
	float4 InstancedView_TemporalAAParams;
	float4 InstancedView_CircleDOFParams;
	float InstancedView_DepthOfFieldSensorWidth;
	float InstancedView_DepthOfFieldFocalDistance;
	float InstancedView_DepthOfFieldScale;
	float InstancedView_DepthOfFieldFocalLength;
	float InstancedView_DepthOfFieldFocalRegion;
	float InstancedView_DepthOfFieldNearTransitionRegion;
	float InstancedView_DepthOfFieldFarTransitionRegion;
	float InstancedView_MotionBlurNormalizedToPixel;
	float InstancedView_bSubsurfacePostprocessEnabled;
	float InstancedView_GeneralPurposeTweak;
	float  InstancedView_DemosaicVposOffset;
	float  PrePadding_InstancedView_2492;
	float3 InstancedView_IndirectLightingColorScale;
	float  InstancedView_AtmosphericFogSunPower;
	float  InstancedView_AtmosphericFogPower;
	float  InstancedView_AtmosphericFogDensityScale;
	float  InstancedView_AtmosphericFogDensityOffset;
	float  InstancedView_AtmosphericFogGroundOffset;
	float  InstancedView_AtmosphericFogDistanceScale;
	float  InstancedView_AtmosphericFogAltitudeScale;
	float  InstancedView_AtmosphericFogHeightScaleRayleigh;
	float  InstancedView_AtmosphericFogStartDistance;
	float  InstancedView_AtmosphericFogDistanceOffset;
	float  InstancedView_AtmosphericFogSunDiscScale;
	float  PrePadding_InstancedView_2552;
	float  PrePadding_InstancedView_2556;
	float4 InstancedView_AtmosphereLightDirection[2];
	float4 InstancedView_AtmosphereLightColor[2];
	float4 InstancedView_AtmosphereLightColorGlobalPostTransmittance[2];
	float4 InstancedView_AtmosphereLightDiscLuminance[2];
	float4 InstancedView_AtmosphereLightDiscCosHalfApexAngle[2];
	float4 InstancedView_SkyViewLutSizeAndInvSize;
	float3 InstancedView_SkyWorldCameraOrigin;
	float PrePadding_InstancedView_2748;
	float4 InstancedView_SkyPlanetCenterAndViewHeight;
	float4 InstancedView_SkyAtmosphereSkyLuminanceFactor;
	float InstancedView_SkyAtmosphereHeightFogContribution;
	float InstancedView_SkyAtmosphereBottomRadiusKm;
	float InstancedView_SkyAtmosphereTopRadiusKm;
	float InstancedView_SkyAtmosphereAerialPerspectiveStartDepthKm;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float InstancedView_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	uint InstancedView_AtmosphericFogRenderMask;
	uint InstancedView_AtmosphericFogInscatterAltitudeSampleNum;
	uint PrePadding_InstancedView_2828;
	float3 InstancedView_NormalCurvatureToRoughnessScaleBias;
	float InstancedView_RenderingReflectionCaptureMask;
	float4 InstancedView_AmbientCubemapTint;
	float InstancedView_AmbientCubemapIntensity;
	float InstancedView_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float InstancedView_SkyLightAffectReflectionFlag;
	float InstancedView_SkyLightAffectGlobalIlluminationFlag;
	float4 InstancedView_SkyLightColor;
	float4 InstancedView_SkyIrradianceEnvironmentMap[7];
	float InstancedView_MobilePreviewMode;
	float InstancedView_HMDEyePaddingOffset;
	float  InstancedView_ReflectionCubemapMaxMip;
	float InstancedView_ShowDecalsMask;
	uint InstancedView_DistanceFieldAOSpecularOcclusionMode;
	float InstancedView_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_InstancedView_3032;
	float PrePadding_InstancedView_3036;
	float3 InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int InstancedView_StereoPassIndex;
	float4 InstancedView_GlobalVolumeCenterAndExtent[4];
	float4 InstancedView_GlobalVolumeWorldToUVAddAndMul[4];
	float InstancedView_GlobalVolumeDimension;
	float InstancedView_GlobalVolumeTexelSize;
	float InstancedView_MaxGlobalDistance;
	float PrePadding_InstancedView_3196;
	int2 InstancedView_CursorPosition;
	float InstancedView_bCheckerboardSubsurfaceProfileRendering;
	float PrePadding_InstancedView_3212;
	float3 InstancedView_VolumetricFogInvGridSize;
	float PrePadding_InstancedView_3228;
	float3 InstancedView_VolumetricFogGridZParams;
	float PrePadding_InstancedView_3244;
	float2 InstancedView_VolumetricFogSVPosToVolumeUV;
	float InstancedView_VolumetricFogMaxDistance;
	float PrePadding_InstancedView_3260;
	float3 InstancedView_VolumetricLightmapWorldToUVScale;
	float PrePadding_InstancedView_3276;
	float3 InstancedView_VolumetricLightmapWorldToUVAdd;
	float PrePadding_InstancedView_3292;
	float3 InstancedView_VolumetricLightmapIndirectionTextureSize;
	float InstancedView_VolumetricLightmapBrickSize;
	float3 InstancedView_VolumetricLightmapBrickTexelSize;
	float InstancedView_StereoIPD;
	float InstancedView_IndirectLightingCacheShowFlag;
	float InstancedView_EyeToPixelSpreadAngle;
	float PrePadding_InstancedView_3336;
	float PrePadding_InstancedView_3340;
	float4x4 InstancedView_WorldToVirtualTexture;
	float4 InstancedView_XRPassthroughCameraUVs[2];
	uint InstancedView_VirtualTextureFeedbackStride;
	uint PrePadding_InstancedView_3444;
	uint PrePadding_InstancedView_3448;
	uint PrePadding_InstancedView_3452;
	float4 InstancedView_RuntimeVirtualTextureMipLevel;
	float2 InstancedView_RuntimeVirtualTexturePackHeight;
	float PrePadding_InstancedView_3480;
	float PrePadding_InstancedView_3484;
	float4 InstancedView_RuntimeVirtualTextureDebugParams;
	int InstancedView_FarShadowStaticMeshLODBias;
	float InstancedView_MinRoughness;
	float PrePadding_InstancedView_3512;
	float PrePadding_InstancedView_3516;
	float4 InstancedView_HairRenderInfo;
	uint InstancedView_HairRenderInfoBits;
}
/*atic const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightColor[2];
	float4 AtmosphereLightColorGlobalPostTransmittance[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyWorldCameraOrigin;
	float4 SkyPlanetCenterAndViewHeight;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4x4 WorldToVirtualTexture;
	float4 XRPassthroughCameraUVs[2];
	uint VirtualTextureFeedbackStride;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint HairRenderInfoBits;
} InstancedView = {InstancedView_TranslatedWorldToClip,InstancedView_WorldToClip,InstancedView_ClipToWorld,InstancedView_TranslatedWorldToView,InstancedView_ViewToTranslatedWorld,InstancedView_TranslatedWorldToCameraView,InstancedView_CameraViewToTranslatedWorld,InstancedView_ViewToClip,InstancedView_ViewToClipNoAA,InstancedView_ClipToView,InstancedView_ClipToTranslatedWorld,InstancedView_SVPositionToTranslatedWorld,InstancedView_ScreenToWorld,InstancedView_ScreenToTranslatedWorld,InstancedView_MobileMultiviewShadowTransform,InstancedView_ViewForward,InstancedView_ViewUp,InstancedView_ViewRight,InstancedView_HMDViewNoRollUp,InstancedView_HMDViewNoRollRight,InstancedView_InvDeviceZToWorldZTransform,InstancedView_ScreenPositionScaleBias,InstancedView_WorldCameraOrigin,InstancedView_TranslatedWorldCameraOrigin,InstancedView_WorldViewOrigin,InstancedView_PreViewTranslation,InstancedView_PrevProjection,InstancedView_PrevViewProj,InstancedView_PrevViewRotationProj,InstancedView_PrevViewToClip,InstancedView_PrevClipToView,InstancedView_PrevTranslatedWorldToClip,InstancedView_PrevTranslatedWorldToView,InstancedView_PrevViewToTranslatedWorld,InstancedView_PrevTranslatedWorldToCameraView,InstancedView_PrevCameraViewToTranslatedWorld,InstancedView_PrevWorldCameraOrigin,InstancedView_PrevWorldViewOrigin,InstancedView_PrevPreViewTranslation,InstancedView_PrevInvViewProj,InstancedView_PrevScreenToTranslatedWorld,InstancedView_ClipToPrevClip,InstancedView_TemporalAAJitter,InstancedView_GlobalClippingPlane,InstancedView_FieldOfViewWideAngles,InstancedView_PrevFieldOfViewWideAngles,InstancedView_ViewRectMin,InstancedView_ViewSizeAndInvSize,InstancedView_BufferSizeAndInvSize,InstancedView_BufferBilinearUVMinMax,InstancedView_ScreenToViewSpace,InstancedView_NumSceneColorMSAASamples,InstancedView_PreExposure,InstancedView_OneOverPreExposure,InstancedView_DiffuseOverrideParameter,InstancedView_SpecularOverrideParameter,InstancedView_NormalOverrideParameter,InstancedView_RoughnessOverrideParameter,InstancedView_PrevFrameGameTime,InstancedView_PrevFrameRealTime,InstancedView_OutOfBoundsMask,InstancedView_WorldCameraMovementSinceLastFrame,InstancedView_CullingSign,InstancedView_NearPlane,InstancedView_AdaptiveTessellationFactor,InstancedView_GameTime,InstancedView_RealTime,InstancedView_DeltaTime,InstancedView_MaterialTextureMipBias,InstancedView_MaterialTextureDerivativeMultiply,InstancedView_Random,InstancedView_FrameNumber,InstancedView_StateFrameIndexMod8,InstancedView_StateFrameIndex,InstancedView_DebugViewModeMask,InstancedView_CameraCut,InstancedView_UnlitViewmodeMask,InstancedView_DirectionalLightColor,InstancedView_DirectionalLightDirection,InstancedView_TranslucencyLightingVolumeMin,InstancedView_TranslucencyLightingVolumeInvSize,InstancedView_TemporalAAParams,InstancedView_CircleDOFParams,InstancedView_DepthOfFieldSensorWidth,InstancedView_DepthOfFieldFocalDistance,InstancedView_DepthOfFieldScale,InstancedView_DepthOfFieldFocalLength,InstancedView_DepthOfFieldFocalRegion,InstancedView_DepthOfFieldNearTransitionRegion,InstancedView_DepthOfFieldFarTransitionRegion,InstancedView_MotionBlurNormalizedToPixel,InstancedView_bSubsurfacePostprocessEnabled,InstancedView_GeneralPurposeTweak,InstancedView_DemosaicVposOffset,InstancedView_IndirectLightingColorScale,InstancedView_AtmosphericFogSunPower,InstancedView_AtmosphericFogPower,InstancedView_AtmosphericFogDensityScale,InstancedView_AtmosphericFogDensityOffset,InstancedView_AtmosphericFogGroundOffset,InstancedView_AtmosphericFogDistanceScale,InstancedView_AtmosphericFogAltitudeScale,InstancedView_AtmosphericFogHeightScaleRayleigh,InstancedView_AtmosphericFogStartDistance,InstancedView_AtmosphericFogDistanceOffset,InstancedView_AtmosphericFogSunDiscScale,InstancedView_AtmosphereLightDirection,InstancedView_AtmosphereLightColor,InstancedView_AtmosphereLightColorGlobalPostTransmittance,InstancedView_AtmosphereLightDiscLuminance,InstancedView_AtmosphereLightDiscCosHalfApexAngle,InstancedView_SkyViewLutSizeAndInvSize,InstancedView_SkyWorldCameraOrigin,InstancedView_SkyPlanetCenterAndViewHeight,InstancedView_SkyAtmosphereSkyLuminanceFactor,InstancedView_SkyAtmosphereHeightFogContribution,InstancedView_SkyAtmosphereBottomRadiusKm,InstancedView_SkyAtmosphereTopRadiusKm,InstancedView_SkyAtmosphereAerialPerspectiveStartDepthKm,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv,InstancedView_SkyAtmosphereApplyCameraAerialPerspectiveVolume,InstancedView_AtmosphericFogRenderMask,InstancedView_AtmosphericFogInscatterAltitudeSampleNum,InstancedView_NormalCurvatureToRoughnessScaleBias,InstancedView_RenderingReflectionCaptureMask,InstancedView_AmbientCubemapTint,InstancedView_AmbientCubemapIntensity,InstancedView_SkyLightApplyPrecomputedBentNormalShadowingFlag,InstancedView_SkyLightAffectReflectionFlag,InstancedView_SkyLightAffectGlobalIlluminationFlag,InstancedView_SkyLightColor,InstancedView_SkyIrradianceEnvironmentMap,InstancedView_MobilePreviewMode,InstancedView_HMDEyePaddingOffset,InstancedView_ReflectionCubemapMaxMip,InstancedView_ShowDecalsMask,InstancedView_DistanceFieldAOSpecularOcclusionMode,InstancedView_IndirectCapsuleSelfShadowingIntensity,InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,InstancedView_StereoPassIndex,InstancedView_GlobalVolumeCenterAndExtent,InstancedView_GlobalVolumeWorldToUVAddAndMul,InstancedView_GlobalVolumeDimension,InstancedView_GlobalVolumeTexelSize,InstancedView_MaxGlobalDistance,InstancedView_CursorPosition,InstancedView_bCheckerboardSubsurfaceProfileRendering,InstancedView_VolumetricFogInvGridSize,InstancedView_VolumetricFogGridZParams,InstancedView_VolumetricFogSVPosToVolumeUV,InstancedView_VolumetricFogMaxDistance,InstancedView_VolumetricLightmapWorldToUVScale,InstancedView_VolumetricLightmapWorldToUVAdd,InstancedView_VolumetricLightmapIndirectionTextureSize,InstancedView_VolumetricLightmapBrickSize,InstancedView_VolumetricLightmapBrickTexelSize,InstancedView_StereoIPD,InstancedView_IndirectLightingCacheShowFlag,InstancedView_EyeToPixelSpreadAngle,InstancedView_WorldToVirtualTexture,InstancedView_XRPassthroughCameraUVs,InstancedView_VirtualTextureFeedbackStride,InstancedView_RuntimeVirtualTextureMipLevel,InstancedView_RuntimeVirtualTexturePackHeight,InstancedView_RuntimeVirtualTextureDebugParams,InstancedView_FarShadowStaticMeshLODBias,InstancedView_MinRoughness,InstancedView_HairRenderInfo,InstancedView_HairRenderInfoBits,*/
#line 4 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/MobileSceneTextures.ush"


cbuffer MobileSceneTextures
{
}
Texture2D MobileSceneTextures_SceneColorTexture;
SamplerState MobileSceneTextures_SceneColorTextureSampler;
Texture2D MobileSceneTextures_SceneDepthTexture;
SamplerState MobileSceneTextures_SceneDepthTextureSampler;
Texture2D MobileSceneTextures_SceneAlphaCopyTexture;
SamplerState MobileSceneTextures_SceneAlphaCopyTextureSampler;
Texture2D MobileSceneTextures_CustomDepthTexture;
SamplerState MobileSceneTextures_CustomDepthTextureSampler;
Texture2D MobileSceneTextures_MobileCustomStencilTexture;
SamplerState MobileSceneTextures_MobileCustomStencilTextureSampler;
RWBuffer<uint> MobileSceneTextures_VirtualTextureFeedbackUAV;
Buffer<float4> MobileSceneTextures_EyeAdaptationBuffer;
/*atic const struct
{
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D SceneAlphaCopyTexture;
	SamplerState SceneAlphaCopyTextureSampler;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D MobileCustomStencilTexture;
	SamplerState MobileCustomStencilTextureSampler;
	RWBuffer<uint> VirtualTextureFeedbackUAV;
	Buffer<float4> EyeAdaptationBuffer;
} MobileSceneTextures = {MobileSceneTextures_SceneColorTexture,MobileSceneTextures_SceneColorTextureSampler,MobileSceneTextures_SceneDepthTexture,MobileSceneTextures_SceneDepthTextureSampler,MobileSceneTextures_SceneAlphaCopyTexture,MobileSceneTextures_SceneAlphaCopyTextureSampler,MobileSceneTextures_CustomDepthTexture,MobileSceneTextures_CustomDepthTextureSampler,MobileSceneTextures_MobileCustomStencilTexture,MobileSceneTextures_MobileCustomStencilTextureSampler,MobileSceneTextures_VirtualTextureFeedbackUAV,  MobileSceneTextures_EyeAdaptationBuffer,  */
#line 5 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/SceneTexturesStruct.ush"


cbuffer SceneTexturesStruct
{
}
Texture2D SceneTexturesStruct_SceneColorTexture;
SamplerState SceneTexturesStruct_SceneColorTextureSampler;
Texture2D SceneTexturesStruct_SceneDepthTexture;
SamplerState SceneTexturesStruct_SceneDepthTextureSampler;
Texture2D<float> SceneTexturesStruct_SceneDepthTextureNonMS;
Texture2D SceneTexturesStruct_GBufferATexture;
Texture2D SceneTexturesStruct_GBufferBTexture;
Texture2D SceneTexturesStruct_GBufferCTexture;
Texture2D SceneTexturesStruct_GBufferDTexture;
Texture2D SceneTexturesStruct_GBufferETexture;
Texture2D SceneTexturesStruct_GBufferFTexture;
Texture2D SceneTexturesStruct_GBufferVelocityTexture;
Texture2D<float4> SceneTexturesStruct_GBufferATextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferBTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferCTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferDTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferETextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferFTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferVelocityTextureNonMS;
SamplerState SceneTexturesStruct_GBufferATextureSampler;
SamplerState SceneTexturesStruct_GBufferBTextureSampler;
SamplerState SceneTexturesStruct_GBufferCTextureSampler;
SamplerState SceneTexturesStruct_GBufferDTextureSampler;
SamplerState SceneTexturesStruct_GBufferETextureSampler;
SamplerState SceneTexturesStruct_GBufferFTextureSampler;
SamplerState SceneTexturesStruct_GBufferVelocityTextureSampler;
Texture2D SceneTexturesStruct_ScreenSpaceAOTexture;
SamplerState SceneTexturesStruct_ScreenSpaceAOTextureSampler;
Texture2D<float> SceneTexturesStruct_CustomDepthTextureNonMS;
Texture2D SceneTexturesStruct_CustomDepthTexture;
SamplerState SceneTexturesStruct_CustomDepthTextureSampler;
Texture2D<uint2> SceneTexturesStruct_CustomStencilTexture;
Texture2D<uint2> SceneTexturesStruct_SceneStencilTexture;
Texture2D SceneTexturesStruct_EyeAdaptation;
Texture2D SceneTexturesStruct_SceneColorCopyTexture;
SamplerState SceneTexturesStruct_SceneColorCopyTextureSampler;
/*atic const struct
{
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D<float> SceneDepthTextureNonMS;
	Texture2D GBufferATexture;
	Texture2D GBufferBTexture;
	Texture2D GBufferCTexture;
	Texture2D GBufferDTexture;
	Texture2D GBufferETexture;
	Texture2D GBufferFTexture;
	Texture2D GBufferVelocityTexture;
	Texture2D<float4> GBufferATextureNonMS;
	Texture2D<float4> GBufferBTextureNonMS;
	Texture2D<float4> GBufferCTextureNonMS;
	Texture2D<float4> GBufferDTextureNonMS;
	Texture2D<float4> GBufferETextureNonMS;
	Texture2D<float4> GBufferFTextureNonMS;
	Texture2D<float4> GBufferVelocityTextureNonMS;
	SamplerState GBufferATextureSampler;
	SamplerState GBufferBTextureSampler;
	SamplerState GBufferCTextureSampler;
	SamplerState GBufferDTextureSampler;
	SamplerState GBufferETextureSampler;
	SamplerState GBufferFTextureSampler;
	SamplerState GBufferVelocityTextureSampler;
	Texture2D ScreenSpaceAOTexture;
	SamplerState ScreenSpaceAOTextureSampler;
	Texture2D<float> CustomDepthTextureNonMS;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D<uint2> CustomStencilTexture;
	Texture2D<uint2> SceneStencilTexture;
	Texture2D EyeAdaptation;
	Texture2D SceneColorCopyTexture;
	SamplerState SceneColorCopyTextureSampler;
} SceneTexturesStruct = {SceneTexturesStruct_SceneColorTexture,SceneTexturesStruct_SceneColorTextureSampler,SceneTexturesStruct_SceneDepthTexture,SceneTexturesStruct_SceneDepthTextureSampler,SceneTexturesStruct_SceneDepthTextureNonMS,SceneTexturesStruct_GBufferATexture,SceneTexturesStruct_GBufferBTexture,SceneTexturesStruct_GBufferCTexture,SceneTexturesStruct_GBufferDTexture,SceneTexturesStruct_GBufferETexture,SceneTexturesStruct_GBufferFTexture,SceneTexturesStruct_GBufferVelocityTexture,SceneTexturesStruct_GBufferATextureNonMS,SceneTexturesStruct_GBufferBTextureNonMS,SceneTexturesStruct_GBufferCTextureNonMS,SceneTexturesStruct_GBufferDTextureNonMS,SceneTexturesStruct_GBufferETextureNonMS,SceneTexturesStruct_GBufferFTextureNonMS,SceneTexturesStruct_GBufferVelocityTextureNonMS,SceneTexturesStruct_GBufferATextureSampler,SceneTexturesStruct_GBufferBTextureSampler,SceneTexturesStruct_GBufferCTextureSampler,SceneTexturesStruct_GBufferDTextureSampler,SceneTexturesStruct_GBufferETextureSampler,SceneTexturesStruct_GBufferFTextureSampler,SceneTexturesStruct_GBufferVelocityTextureSampler,SceneTexturesStruct_ScreenSpaceAOTexture,SceneTexturesStruct_ScreenSpaceAOTextureSampler,SceneTexturesStruct_CustomDepthTextureNonMS,SceneTexturesStruct_CustomDepthTexture,SceneTexturesStruct_CustomDepthTextureSampler,  SceneTexturesStruct_CustomStencilTexture,   SceneTexturesStruct_SceneStencilTexture,  SceneTexturesStruct_EyeAdaptation,SceneTexturesStruct_SceneColorCopyTexture,SceneTexturesStruct_SceneColorCopyTextureSampler,*/
#line 6 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"
#line 7 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/DrawRectangleParameters.ush"
#line 8 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"
#line 9 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/MobileSceneTextures.ush"
#line 10 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/SceneTexturesStruct.ush"
#line 11 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 62 "/Engine/Private/Common.ush"
#line 64 "/Engine/Private/Common.ush"
#line 1 "CommonViewUniformBuffer.ush"
#line 12 "/Engine/Private/CommonViewUniformBuffer.ush"
float2 GetTanHalfFieldOfView()
{
	return float2(View_ClipToView[0][0], View_ClipToView[1][1]);
}

float2 GetPrevTanHalfFieldOfView()
{
	return float2(View_PrevClipToView[0][0], View_PrevClipToView[1][1]);
}



float2 GetCotanHalfFieldOfView()
{
	return float2(View_ViewToClip[0][0], View_ViewToClip[1][1]);
}



float2 GetPrevCotanHalfFieldOfView()
{
	return float2(View_PrevViewToClip[0][0], View_PrevViewToClip[1][1]);
}


uint GetPowerOfTwoModulatedFrameIndex(uint Pow2Modulus)
{

	return View_StateFrameIndex & uint(Pow2Modulus - 1);
}
#line 65 "/Engine/Private/Common.ush"
#line 66 "/Engine/Private/Common.ush"
#line 1 "InstancedStereo.ush"
#line 10 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"
#line 11 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"
#line 12 "/Engine/Private/InstancedStereo.ush"
#line 15 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/GeneratedInstancedStereo.ush"
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightColor[2];
	float4 AtmosphereLightColorGlobalPostTransmittance[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyWorldCameraOrigin;
	float4 SkyPlanetCenterAndViewHeight;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4x4 WorldToVirtualTexture;
	float4 XRPassthroughCameraUVs[2];
	uint VirtualTextureFeedbackStride;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint HairRenderInfoBits;
};
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View_TranslatedWorldToClip;
	Result.WorldToClip = View_WorldToClip;
	Result.ClipToWorld = View_ClipToWorld;
	Result.TranslatedWorldToView = View_TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View_ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View_TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View_CameraViewToTranslatedWorld;
	Result.ViewToClip = View_ViewToClip;
	Result.ViewToClipNoAA = View_ViewToClipNoAA;
	Result.ClipToView = View_ClipToView;
	Result.ClipToTranslatedWorld = View_ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View_SVPositionToTranslatedWorld;
	Result.ScreenToWorld = View_ScreenToWorld;
	Result.ScreenToTranslatedWorld = View_ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = View_MobileMultiviewShadowTransform;
	Result.ViewForward = View_ViewForward;
	Result.ViewUp = View_ViewUp;
	Result.ViewRight = View_ViewRight;
	Result.HMDViewNoRollUp = View_HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View_HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View_InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View_ScreenPositionScaleBias;
	Result.WorldCameraOrigin = View_WorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = View_TranslatedWorldCameraOrigin;
	Result.WorldViewOrigin = View_WorldViewOrigin;
	Result.PreViewTranslation = View_PreViewTranslation;
	Result.PrevProjection = View_PrevProjection;
	Result.PrevViewProj = View_PrevViewProj;
	Result.PrevViewRotationProj = View_PrevViewRotationProj;
	Result.PrevViewToClip = View_PrevViewToClip;
	Result.PrevClipToView = View_PrevClipToView;
	Result.PrevTranslatedWorldToClip = View_PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View_PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View_PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View_PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View_PrevCameraViewToTranslatedWorld;
	Result.PrevWorldCameraOrigin = View_PrevWorldCameraOrigin;
	Result.PrevWorldViewOrigin = View_PrevWorldViewOrigin;
	Result.PrevPreViewTranslation = View_PrevPreViewTranslation;
	Result.PrevInvViewProj = View_PrevInvViewProj;
	Result.PrevScreenToTranslatedWorld = View_PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View_ClipToPrevClip;
	Result.TemporalAAJitter = View_TemporalAAJitter;
	Result.GlobalClippingPlane = View_GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View_FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View_PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View_ViewRectMin;
	Result.ViewSizeAndInvSize = View_ViewSizeAndInvSize;
	Result.BufferSizeAndInvSize = View_BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View_BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = View_ScreenToViewSpace;
	Result.NumSceneColorMSAASamples = View_NumSceneColorMSAASamples;
	Result.PreExposure = View_PreExposure;
	Result.OneOverPreExposure = View_OneOverPreExposure;
	Result.DiffuseOverrideParameter = View_DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View_SpecularOverrideParameter;
	Result.NormalOverrideParameter = View_NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View_RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View_PrevFrameGameTime;
	Result.PrevFrameRealTime = View_PrevFrameRealTime;
	Result.OutOfBoundsMask = View_OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View_WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View_CullingSign;
	Result.NearPlane = View_NearPlane;
	Result.AdaptiveTessellationFactor = View_AdaptiveTessellationFactor;
	Result.GameTime = View_GameTime;
	Result.RealTime = View_RealTime;
	Result.DeltaTime = View_DeltaTime;
	Result.MaterialTextureMipBias = View_MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View_MaterialTextureDerivativeMultiply;
	Result.Random = View_Random;
	Result.FrameNumber = View_FrameNumber;
	Result.StateFrameIndexMod8 = View_StateFrameIndexMod8;
	Result.StateFrameIndex = View_StateFrameIndex;
	Result.DebugViewModeMask = View_DebugViewModeMask;
	Result.CameraCut = View_CameraCut;
	Result.UnlitViewmodeMask = View_UnlitViewmodeMask;
	Result.DirectionalLightColor = View_DirectionalLightColor;
	Result.DirectionalLightDirection = View_DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View_TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View_TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View_TemporalAAParams;
	Result.CircleDOFParams = View_CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View_DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View_DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View_DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View_DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View_DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View_DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View_DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View_MotionBlurNormalizedToPixel;
	Result.bSubsurfacePostprocessEnabled = View_bSubsurfacePostprocessEnabled;
	Result.GeneralPurposeTweak = View_GeneralPurposeTweak;
	Result.DemosaicVposOffset = View_DemosaicVposOffset;
	Result.IndirectLightingColorScale = View_IndirectLightingColorScale;
	Result.AtmosphericFogSunPower = View_AtmosphericFogSunPower;
	Result.AtmosphericFogPower = View_AtmosphericFogPower;
	Result.AtmosphericFogDensityScale = View_AtmosphericFogDensityScale;
	Result.AtmosphericFogDensityOffset = View_AtmosphericFogDensityOffset;
	Result.AtmosphericFogGroundOffset = View_AtmosphericFogGroundOffset;
	Result.AtmosphericFogDistanceScale = View_AtmosphericFogDistanceScale;
	Result.AtmosphericFogAltitudeScale = View_AtmosphericFogAltitudeScale;
	Result.AtmosphericFogHeightScaleRayleigh = View_AtmosphericFogHeightScaleRayleigh;
	Result.AtmosphericFogStartDistance = View_AtmosphericFogStartDistance;
	Result.AtmosphericFogDistanceOffset = View_AtmosphericFogDistanceOffset;
	Result.AtmosphericFogSunDiscScale = View_AtmosphericFogSunDiscScale;
	Result.AtmosphereLightDirection = View_AtmosphereLightDirection;
	Result.AtmosphereLightColor = View_AtmosphereLightColor;
	Result.AtmosphereLightColorGlobalPostTransmittance = View_AtmosphereLightColorGlobalPostTransmittance;
	Result.AtmosphereLightDiscLuminance = View_AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle = View_AtmosphereLightDiscCosHalfApexAngle;
	Result.SkyViewLutSizeAndInvSize = View_SkyViewLutSizeAndInvSize;
	Result.SkyWorldCameraOrigin = View_SkyWorldCameraOrigin;
	Result.SkyPlanetCenterAndViewHeight = View_SkyPlanetCenterAndViewHeight;
	Result.SkyAtmosphereSkyLuminanceFactor = View_SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmosphereHeightFogContribution = View_SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = View_SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = View_SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = View_SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = View_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.AtmosphericFogRenderMask = View_AtmosphericFogRenderMask;
	Result.AtmosphericFogInscatterAltitudeSampleNum = View_AtmosphericFogInscatterAltitudeSampleNum;
	Result.NormalCurvatureToRoughnessScaleBias = View_NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View_RenderingReflectionCaptureMask;
	Result.AmbientCubemapTint = View_AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View_AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = View_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = View_SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = View_SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = View_SkyLightColor;
	Result.SkyIrradianceEnvironmentMap = View_SkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View_MobilePreviewMode;
	Result.HMDEyePaddingOffset = View_HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View_ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View_ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View_DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View_IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View_StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = View_GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = View_GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalVolumeDimension = View_GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View_GlobalVolumeTexelSize;
	Result.MaxGlobalDistance = View_MaxGlobalDistance;
	Result.CursorPosition = View_CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = View_bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View_VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View_VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View_VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = View_VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View_VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View_VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View_VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View_VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View_VolumetricLightmapBrickTexelSize;
	Result.StereoIPD = View_StereoIPD;
	Result.IndirectLightingCacheShowFlag = View_IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View_EyeToPixelSpreadAngle;
	Result.WorldToVirtualTexture = View_WorldToVirtualTexture;
	Result.XRPassthroughCameraUVs = View_XRPassthroughCameraUVs;
	Result.VirtualTextureFeedbackStride = View_VirtualTextureFeedbackStride;
	Result.RuntimeVirtualTextureMipLevel = View_RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = View_RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = View_RuntimeVirtualTextureDebugParams;
	Result.FarShadowStaticMeshLODBias = View_FarShadowStaticMeshLODBias;
	Result.MinRoughness = View_MinRoughness;
	Result.HairRenderInfo = View_HairRenderInfo;
	Result.HairRenderInfoBits = View_HairRenderInfoBits;
	return Result;
}
ViewState GetInstancedView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = InstancedView_TranslatedWorldToClip;
	Result.WorldToClip = InstancedView_WorldToClip;
	Result.ClipToWorld = InstancedView_ClipToWorld;
	Result.TranslatedWorldToView = InstancedView_TranslatedWorldToView;
	Result.ViewToTranslatedWorld = InstancedView_ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = InstancedView_TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = InstancedView_CameraViewToTranslatedWorld;
	Result.ViewToClip = InstancedView_ViewToClip;
	Result.ViewToClipNoAA = InstancedView_ViewToClipNoAA;
	Result.ClipToView = InstancedView_ClipToView;
	Result.ClipToTranslatedWorld = InstancedView_ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = InstancedView_SVPositionToTranslatedWorld;
	Result.ScreenToWorld = InstancedView_ScreenToWorld;
	Result.ScreenToTranslatedWorld = InstancedView_ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = InstancedView_MobileMultiviewShadowTransform;
	Result.ViewForward = InstancedView_ViewForward;
	Result.ViewUp = InstancedView_ViewUp;
	Result.ViewRight = InstancedView_ViewRight;
	Result.HMDViewNoRollUp = InstancedView_HMDViewNoRollUp;
	Result.HMDViewNoRollRight = InstancedView_HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = InstancedView_InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = InstancedView_ScreenPositionScaleBias;
	Result.WorldCameraOrigin = InstancedView_WorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = InstancedView_TranslatedWorldCameraOrigin;
	Result.WorldViewOrigin = InstancedView_WorldViewOrigin;
	Result.PreViewTranslation = InstancedView_PreViewTranslation;
	Result.PrevProjection = InstancedView_PrevProjection;
	Result.PrevViewProj = InstancedView_PrevViewProj;
	Result.PrevViewRotationProj = InstancedView_PrevViewRotationProj;
	Result.PrevViewToClip = InstancedView_PrevViewToClip;
	Result.PrevClipToView = InstancedView_PrevClipToView;
	Result.PrevTranslatedWorldToClip = InstancedView_PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = InstancedView_PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = InstancedView_PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = InstancedView_PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = InstancedView_PrevCameraViewToTranslatedWorld;
	Result.PrevWorldCameraOrigin = InstancedView_PrevWorldCameraOrigin;
	Result.PrevWorldViewOrigin = InstancedView_PrevWorldViewOrigin;
	Result.PrevPreViewTranslation = InstancedView_PrevPreViewTranslation;
	Result.PrevInvViewProj = InstancedView_PrevInvViewProj;
	Result.PrevScreenToTranslatedWorld = InstancedView_PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = InstancedView_ClipToPrevClip;
	Result.TemporalAAJitter = InstancedView_TemporalAAJitter;
	Result.GlobalClippingPlane = InstancedView_GlobalClippingPlane;
	Result.FieldOfViewWideAngles = InstancedView_FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = InstancedView_PrevFieldOfViewWideAngles;
	Result.ViewRectMin = InstancedView_ViewRectMin;
	Result.ViewSizeAndInvSize = InstancedView_ViewSizeAndInvSize;
	Result.BufferSizeAndInvSize = InstancedView_BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = InstancedView_BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = InstancedView_ScreenToViewSpace;
	Result.NumSceneColorMSAASamples = InstancedView_NumSceneColorMSAASamples;
	Result.PreExposure = InstancedView_PreExposure;
	Result.OneOverPreExposure = InstancedView_OneOverPreExposure;
	Result.DiffuseOverrideParameter = InstancedView_DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = InstancedView_SpecularOverrideParameter;
	Result.NormalOverrideParameter = InstancedView_NormalOverrideParameter;
	Result.RoughnessOverrideParameter = InstancedView_RoughnessOverrideParameter;
	Result.PrevFrameGameTime = InstancedView_PrevFrameGameTime;
	Result.PrevFrameRealTime = InstancedView_PrevFrameRealTime;
	Result.OutOfBoundsMask = InstancedView_OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = InstancedView_WorldCameraMovementSinceLastFrame;
	Result.CullingSign = InstancedView_CullingSign;
	Result.NearPlane = InstancedView_NearPlane;
	Result.AdaptiveTessellationFactor = InstancedView_AdaptiveTessellationFactor;
	Result.GameTime = InstancedView_GameTime;
	Result.RealTime = InstancedView_RealTime;
	Result.DeltaTime = InstancedView_DeltaTime;
	Result.MaterialTextureMipBias = InstancedView_MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = InstancedView_MaterialTextureDerivativeMultiply;
	Result.Random = InstancedView_Random;
	Result.FrameNumber = InstancedView_FrameNumber;
	Result.StateFrameIndexMod8 = InstancedView_StateFrameIndexMod8;
	Result.StateFrameIndex = InstancedView_StateFrameIndex;
	Result.DebugViewModeMask = InstancedView_DebugViewModeMask;
	Result.CameraCut = InstancedView_CameraCut;
	Result.UnlitViewmodeMask = InstancedView_UnlitViewmodeMask;
	Result.DirectionalLightColor = InstancedView_DirectionalLightColor;
	Result.DirectionalLightDirection = InstancedView_DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = InstancedView_TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = InstancedView_TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = InstancedView_TemporalAAParams;
	Result.CircleDOFParams = InstancedView_CircleDOFParams;
	Result.DepthOfFieldSensorWidth = InstancedView_DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = InstancedView_DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = InstancedView_DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = InstancedView_DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = InstancedView_DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = InstancedView_DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = InstancedView_DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = InstancedView_MotionBlurNormalizedToPixel;
	Result.bSubsurfacePostprocessEnabled = InstancedView_bSubsurfacePostprocessEnabled;
	Result.GeneralPurposeTweak = InstancedView_GeneralPurposeTweak;
	Result.DemosaicVposOffset = InstancedView_DemosaicVposOffset;
	Result.IndirectLightingColorScale = InstancedView_IndirectLightingColorScale;
	Result.AtmosphericFogSunPower = InstancedView_AtmosphericFogSunPower;
	Result.AtmosphericFogPower = InstancedView_AtmosphericFogPower;
	Result.AtmosphericFogDensityScale = InstancedView_AtmosphericFogDensityScale;
	Result.AtmosphericFogDensityOffset = InstancedView_AtmosphericFogDensityOffset;
	Result.AtmosphericFogGroundOffset = InstancedView_AtmosphericFogGroundOffset;
	Result.AtmosphericFogDistanceScale = InstancedView_AtmosphericFogDistanceScale;
	Result.AtmosphericFogAltitudeScale = InstancedView_AtmosphericFogAltitudeScale;
	Result.AtmosphericFogHeightScaleRayleigh = InstancedView_AtmosphericFogHeightScaleRayleigh;
	Result.AtmosphericFogStartDistance = InstancedView_AtmosphericFogStartDistance;
	Result.AtmosphericFogDistanceOffset = InstancedView_AtmosphericFogDistanceOffset;
	Result.AtmosphericFogSunDiscScale = InstancedView_AtmosphericFogSunDiscScale;
	Result.AtmosphereLightDirection = InstancedView_AtmosphereLightDirection;
	Result.AtmosphereLightColor = InstancedView_AtmosphereLightColor;
	Result.AtmosphereLightColorGlobalPostTransmittance = InstancedView_AtmosphereLightColorGlobalPostTransmittance;
	Result.AtmosphereLightDiscLuminance = InstancedView_AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle = InstancedView_AtmosphereLightDiscCosHalfApexAngle;
	Result.SkyViewLutSizeAndInvSize = InstancedView_SkyViewLutSizeAndInvSize;
	Result.SkyWorldCameraOrigin = InstancedView_SkyWorldCameraOrigin;
	Result.SkyPlanetCenterAndViewHeight = InstancedView_SkyPlanetCenterAndViewHeight;
	Result.SkyAtmosphereSkyLuminanceFactor = InstancedView_SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmosphereHeightFogContribution = InstancedView_SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = InstancedView_SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = InstancedView_SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = InstancedView_SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = InstancedView_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.AtmosphericFogRenderMask = InstancedView_AtmosphericFogRenderMask;
	Result.AtmosphericFogInscatterAltitudeSampleNum = InstancedView_AtmosphericFogInscatterAltitudeSampleNum;
	Result.NormalCurvatureToRoughnessScaleBias = InstancedView_NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = InstancedView_RenderingReflectionCaptureMask;
	Result.AmbientCubemapTint = InstancedView_AmbientCubemapTint;
	Result.AmbientCubemapIntensity = InstancedView_AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = InstancedView_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = InstancedView_SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = InstancedView_SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = InstancedView_SkyLightColor;
	Result.SkyIrradianceEnvironmentMap = InstancedView_SkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = InstancedView_MobilePreviewMode;
	Result.HMDEyePaddingOffset = InstancedView_HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = InstancedView_ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = InstancedView_ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = InstancedView_DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = InstancedView_IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = InstancedView_StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = InstancedView_GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = InstancedView_GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalVolumeDimension = InstancedView_GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = InstancedView_GlobalVolumeTexelSize;
	Result.MaxGlobalDistance = InstancedView_MaxGlobalDistance;
	Result.CursorPosition = InstancedView_CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = InstancedView_bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = InstancedView_VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = InstancedView_VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = InstancedView_VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = InstancedView_VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = InstancedView_VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = InstancedView_VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = InstancedView_VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = InstancedView_VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = InstancedView_VolumetricLightmapBrickTexelSize;
	Result.StereoIPD = InstancedView_StereoIPD;
	Result.IndirectLightingCacheShowFlag = InstancedView_IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = InstancedView_EyeToPixelSpreadAngle;
	Result.WorldToVirtualTexture = InstancedView_WorldToVirtualTexture;
	Result.XRPassthroughCameraUVs = InstancedView_XRPassthroughCameraUVs;
	Result.VirtualTextureFeedbackStride = InstancedView_VirtualTextureFeedbackStride;
	Result.RuntimeVirtualTextureMipLevel = InstancedView_RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = InstancedView_RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = InstancedView_RuntimeVirtualTextureDebugParams;
	Result.FarShadowStaticMeshLODBias = InstancedView_FarShadowStaticMeshLODBias;
	Result.MinRoughness = InstancedView_MinRoughness;
	Result.HairRenderInfo = InstancedView_HairRenderInfo;
	Result.HairRenderInfoBits = InstancedView_HairRenderInfoBits;
	return Result;
}
#line 16 "/Engine/Private/InstancedStereo.ush"

static ViewState ResolvedView;

ViewState ResolveView()
{
	return GetPrimaryView();
}
#line 44 "/Engine/Private/InstancedStereo.ush"
bool IsInstancedStereo()
{



	return false;

}

uint GetEyeIndex(uint InstanceId)
{



	return 0;

}

uint GetInstanceId(uint InstanceId)
{



	return InstanceId;

}
#line 67 "/Engine/Private/Common.ush"
#line 68 "/Engine/Private/Common.ush"
#line 1 "Definitions.usf"
#line 69 "/Engine/Private/Common.ush"
#line 82 "/Engine/Private/Common.ush"
const static  float  PI = 3.1415926535897932f;
const static float MaxHalfFloat = 65504.0f;
const static float Max10BitsFloat = 64512.0f;
#line 107 "/Engine/Private/Common.ush"
static float GlobalRayCone_TexArea;
float ComputeRayConeLod(Texture2D Tex)
{






    return  0.0f ;

}

float ClampToHalfFloatRange(float X) { return clamp(X, float(0), MaxHalfFloat); }
float2 ClampToHalfFloatRange(float2 X) { return clamp(X, float(0).xx, MaxHalfFloat.xx); }
float3 ClampToHalfFloatRange(float3 X) { return clamp(X, float(0).xxx, MaxHalfFloat.xxx); }
float4 ClampToHalfFloatRange(float4 X) { return clamp(X, float(0).xxxx, MaxHalfFloat.xxxx); }



float4  Texture1DSample(Texture1D Tex, SamplerState Sampler, float UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 134 "/Engine/Private/Common.ush"
}
float4  Texture2DSample(Texture2D Tex, SamplerState Sampler, float2 UV)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex));
#line 142 "/Engine/Private/Common.ush"
}
float  Texture2DSample_A8(Texture2D Tex, SamplerState Sampler, float2 UV)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex))  .a ;
#line 150 "/Engine/Private/Common.ush"
}
float4  Texture3DSample(Texture3D Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 158 "/Engine/Private/Common.ush"
}
float4  TextureCubeSample(TextureCube Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 166 "/Engine/Private/Common.ush"
}
float4  Texture2DArraySample(Texture2DArray Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 174 "/Engine/Private/Common.ush"
}
float4  Texture1DSampleLevel(Texture1D Tex, SamplerState Sampler, float UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleLevel(Texture2D Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleBias(Texture2D Tex, SamplerState Sampler, float2 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + MipBias);
#line 190 "/Engine/Private/Common.ush"
}
float4  Texture2DSampleGrad(Texture2D Tex, SamplerState Sampler, float2 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  Texture3DSampleLevel(Texture3D Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture3DSampleBias(Texture3D Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleBias(Sampler, UV, 0);
#line 206 "/Engine/Private/Common.ush"
}
float4  Texture3DSampleGrad(Texture3D Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureCubeSampleLevel(TextureCube Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float  TextureCubeSampleDepthLevel(TextureCube TexDepth, SamplerState Sampler, float3 UV,  float  Mip)
{
	return TexDepth.SampleLevel(Sampler, UV, Mip).x;
}
float4  TextureCubeSampleBias(TextureCube Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 226 "/Engine/Private/Common.ush"
}
float4  TextureCubeSampleGrad(TextureCube Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureExternalSample( Texture2D  Tex, SamplerState Sampler, float2 UV)
{




		return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex));
#line 242 "/Engine/Private/Common.ush"
}
float4  TextureExternalSampleGrad( Texture2D  Tex, SamplerState Sampler, float2 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureExternalSampleLevel( Texture2D  Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}




float4  Texture1DSample_Decal(Texture1D Tex, SamplerState Sampler, float UV)
{
	return Texture1DSample(Tex, Sampler, UV);
}
float4  Texture2DSample_Decal(Texture2D Tex, SamplerState Sampler, float2 UV)
{



	return Texture2DSample(Tex, Sampler, UV);

}
float4  Texture3DSample_Decal(Texture3D Tex, SamplerState Sampler, float3 UV)
{



	return Texture3DSample(Tex, Sampler, UV);

}
float4  TextureCubeSample_Decal(TextureCube Tex, SamplerState Sampler, float3 UV)
{



	return TextureCubeSample(Tex, Sampler, UV);

}
float4  TextureExternalSample_Decal( Texture2D  Tex, SamplerState Sampler, float2 UV)
{



	return TextureExternalSample(Tex, Sampler, UV);

}

float4  Texture2DArraySampleLevel(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DArraySampleBias(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 303 "/Engine/Private/Common.ush"
}
float4  Texture2DArraySampleGrad(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}


float2 Tile1Dto2D(float xsize, float idx)
{
	float2 xyidx = 0;
	xyidx.y = floor(idx / xsize);
	xyidx.x = idx - xsize * xyidx.y;

	return xyidx;
}
#line 330 "/Engine/Private/Common.ush"
float4 PseudoVolumeTexture(Texture2D Tex, SamplerState TexSampler, float3 inPos, float2 xysize, float numframes,
	uint mipmode = 0, float miplevel = 0, float2 InDDX = 0, float2 InDDY = 0)
{
	float z = inPos.z - 0.5f / numframes;
	float zframe = floor(z * numframes);
	float zphase = frac(z * numframes);

	float2 uv = frac(inPos.xy) / xysize;

	float2 curframe = Tile1Dto2D(xysize.x, zframe) / xysize;
	float2 nextframe = Tile1Dto2D(xysize.x, zframe + 1) / xysize;

	float2 uvCurFrame = uv + curframe;
	float2 uvNextFrame = uv + nextframe;
#line 350 "/Engine/Private/Common.ush"
	float4 sampleA = 0, sampleB = 0;
	switch (mipmode)
	{
	case 0:
		sampleA = Tex.SampleLevel(TexSampler, uvCurFrame, miplevel);
		sampleB = Tex.SampleLevel(TexSampler, uvNextFrame, miplevel);
		break;
	case 1:
		sampleA = Texture2DSample(Tex, TexSampler, uvCurFrame);
		sampleB = Texture2DSample(Tex, TexSampler, uvNextFrame);
		break;
	case 2:
		sampleA = Tex.SampleGrad(TexSampler, uvCurFrame, InDDX, InDDY);
		sampleB = Tex.SampleGrad(TexSampler, uvNextFrame, InDDX, InDDY);
		break;
	default:
		break;
	}

	return lerp(sampleA, sampleB, zphase);
}


	float4  TextureCubeArraySampleLevel(TextureCubeArray Tex, SamplerState Sampler, float3 UV, float ArrayIndex,  float  Mip)
	{
		return Tex.SampleLevel(Sampler, float4(UV, ArrayIndex), Mip);
	}
#line 416 "/Engine/Private/Common.ush"
float  Luminance(  float3  LinearColor )
{
	return dot( LinearColor,  float3 ( 0.3, 0.59, 0.11 ) );
}

float  length2( float2  v)
{
	return dot(v, v);
}
float  length2( float3  v)
{
	return dot(v, v);
}
float  length2( float4  v)
{
	return dot(v, v);
}

uint Mod(uint a, uint b)
{

	return a % b;
#line 441 "/Engine/Private/Common.ush"
}

uint2 Mod(uint2 a, uint2 b)
{

	return a % b;
#line 450 "/Engine/Private/Common.ush"
}

uint3 Mod(uint3 a, uint3 b)
{

	return a % b;
#line 459 "/Engine/Private/Common.ush"
}

float  UnClampedPow( float  X,  float  Y)
{
	return pow(X,  Y );
}
float2  UnClampedPow( float2  X,  float2  Y)
{
	return pow(X,  Y );
}
float3  UnClampedPow( float3  X,  float3  Y)
{
	return pow(X,  Y );
}
float4  UnClampedPow( float4  X,  float4  Y)
{
	return pow(X,  Y );
}




float  ClampedPow( float  X, float  Y)
{
	return pow(max(abs(X), 0.000001f ),Y);
}
float2  ClampedPow( float2  X, float2  Y)
{
	return pow(max(abs(X), float2 ( 0.000001f , 0.000001f )),Y);
}
float3  ClampedPow( float3  X, float3  Y)
{
	return pow(max(abs(X), float3 ( 0.000001f , 0.000001f , 0.000001f )),Y);
}
float4  ClampedPow( float4  X, float4  Y)
{
	return pow(max(abs(X), float4 ( 0.000001f , 0.000001f , 0.000001f , 0.000001f )),Y);
}

float  PositiveClampedPow( float  X, float  Y)
{
	return pow(max(X, 0.000001f ),Y);
}
float2  PositiveClampedPow( float2  X, float2  Y)
{
	return pow(max(X, float2 ( 0.000001f , 0.000001f )),Y);
}
float3  PositiveClampedPow( float3  X, float3  Y)
{
	return pow(max(X, float3 ( 0.000001f , 0.000001f , 0.000001f )),Y);
}
float4  PositiveClampedPow( float4  X, float4  Y)
{
	return pow(max(X, float4 ( 0.000001f , 0.000001f , 0.000001f , 0.000001f )),Y);
}

float DDX(float Input)
{

	return 0;
#line 522 "/Engine/Private/Common.ush"
}

float2 DDX(float2 Input)
{

	return 0;
#line 531 "/Engine/Private/Common.ush"
}

float3 DDX(float3 Input)
{

	return 0;
#line 540 "/Engine/Private/Common.ush"
}

float4 DDX(float4 Input)
{

	return 0;
#line 549 "/Engine/Private/Common.ush"
}

float DDY(float Input)
{

	return 0;
#line 558 "/Engine/Private/Common.ush"
}

float2 DDY(float2 Input)
{

	return 0;
#line 567 "/Engine/Private/Common.ush"
}

float3 DDY(float3 Input)
{

	return 0;
#line 576 "/Engine/Private/Common.ush"
}

float4 DDY(float4 Input)
{

	return 0;
#line 585 "/Engine/Private/Common.ush"
}
#line 587 "/Engine/Private/Common.ush"
#line 1 "FastMath.ush"
#line 46 "/Engine/Private/FastMath.ush"
float rsqrtFast( float x )
{
	int i = asint(x);
	i = 0x5f3759df - (i >> 1);
	return asfloat(i);
}




float sqrtFast( float x )
{
	int i = asint(x);
	i = 0x1FBD1DF5 + (i >> 1);
	return asfloat(i);
}




float rcpFast( float x )
{
	int i = asint(x);
	i = 0x7EF311C2 - i;
	return asfloat(i);
}





float rcpFastNR1( float x )
{
	int i = asint(x);
	i = 0x7EF311C3 - i;
	float xRcp = asfloat(i);
	xRcp = xRcp * (-xRcp * x + 2.0f);
	return xRcp;
}

float lengthFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return sqrtFast( LengthSqr );
}

float3 normalizeFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return v * rsqrtFast( LengthSqr );
}

float4 fastClamp(float4 x, float4 Min, float4 Max)
{




	return clamp(x, Min, Max);

}

float3 fastClamp(float3 x, float3 Min, float3 Max)
{




	return clamp(x, Min, Max);

}

float2 fastClamp(float2 x, float2 Min, float2 Max)
{




	return clamp(x, Min, Max);

}

float fastClamp(float x, float Min, float Max)
{




	return clamp(x, Min, Max);

}









float acosFast(float inX)
{
    float x = abs(inX);
    float res = -0.156583f * x + (0.5 * PI);
    res *= sqrt(1.0f - x);
    return (inX >= 0) ? res : PI - res;
}




float asinFast( float x )
{
    return (0.5 * PI) - acosFast(x);
}





float atanFastPos( float x )
{
    float t0 = (x < 1.0f) ? x : 1.0f / x;
    float t1 = t0 * t0;
    float poly = 0.0872929f;
    poly = -0.301895f + poly * t1;
    poly = 1.0f + poly * t1;
    poly = poly * t0;
    return (x < 1.0f) ? poly : (0.5 * PI) - poly;
}



float atanFast( float x )
{
    float t0 = atanFastPos( abs(x) );
    return (x < 0) ? -t0: t0;
}

float atan2Fast( float y, float x )
{
	float t0 = max( abs(x), abs(y) );
	float t1 = min( abs(x), abs(y) );
	float t3 = t1 / t0;
	float t4 = t3 * t3;


	t0 = + 0.0872929;
	t0 = t0 * t4 - 0.301895;
	t0 = t0 * t4 + 1.0;
	t3 = t0 * t3;

	t3 = abs(y) > abs(x) ? (0.5 * PI) - t3 : t3;
	t3 = x < 0 ? PI - t3 : t3;
	t3 = y < 0 ? -t3 : t3;

	return t3;
}





float acosFast4(float inX)
{
	float x1 = abs(inX);
	float x2 = x1 * x1;
	float x3 = x2 * x1;
	float s;

	s = -0.2121144f * x1 + 1.5707288f;
	s = 0.0742610f * x2 + s;
	s = -0.0187293f * x3 + s;
	s = sqrt(1.0f - x1) * s;



	return inX >= 0.0f ? s : PI - s;
}




float asinFast4( float x )
{
	return (0.5 * PI) - acosFast4(x);
}




float CosBetweenVectors(float3 A, float3 B)
{

	return dot(A, B) * rsqrt(length2(A) * length2(B));
}



float AngleBetweenVectors(float3 A, float3 B)
{
	return acos(CosBetweenVectors(A, B));
}


float AngleBetweenVectorsFast(float3 A, float3 B)
{
	return acosFast(CosBetweenVectors(A, B));
}


int SignFastInt(float v)
{
	return 1 - int((asuint(v) & 0x7fffffff) >> 30);
}

int2 SignFastInt(float2 v)
{
	return int2(SignFastInt(v.x), SignFastInt(v.y));
}
#line 588 "/Engine/Private/Common.ush"
#line 1 "Random.ush"
#line 12 "/Engine/Private/Random.ush"
float PseudoRandom(float2 xy)
{
	float2 pos = frac(xy / 128.0f) * 128.0f + float2(-64.340622f, -72.465622f);


	return frac(dot(pos.xyx * pos.xyy, float3(20.390625f, 60.703125f, 2.4281209f)));
}







float InterleavedGradientNoise( float2 uv, float FrameId )
{

	uv += FrameId * (float2(47, 17) * 0.695f);

    const float3 magic = float3( 0.06711056f, 0.00583715f, 52.9829189f );
    return frac(magic.z * frac(dot(uv, magic.xy)));
}



float RandFast( uint2 PixelPos, float Magic = 3571.0 )
{
	float2 Random2 = ( 1.0 / 4320.0 ) * PixelPos + float2( 0.25, 0.0 );
	float Random = frac( dot( Random2 * Random2, Magic ) );
	Random = frac( Random * Random * (2 * Magic) );
	return Random;
}
#line 56 "/Engine/Private/Random.ush"
float RandBBSfloat(float seed)
{
	float s = frac(seed /  4093 );
	s = frac(s * s *  4093 );
	s = frac(s * s *  4093 );
	return s;
}








uint3 Rand3DPCG16(int3 p)
{

	uint3 v = uint3(p);




	v = v * 1664525u + 1013904223u;
#line 94 "/Engine/Private/Random.ush"
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;


	return v >> 16u;
}








uint3 Rand3DPCG32(int3 p)
{

	uint3 v = uint3(p);


	v = v * 1664525u + 1013904223u;


	v = v * (1u << 16u) + (v >> 16u);


	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;

	return v;
}










uint4 Rand4DPCG32(int4 p)
{

	uint4 v = uint4(p);


	v = v * 1664525u + 1013904223u;


	v = v * (1u << 16u) + (v >> 16u);


	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;
	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;

	return v;
}
#line 174 "/Engine/Private/Random.ush"
void FindBestAxisVectors(float3 In, out float3 Axis1, out float3 Axis2 )
{
	const float3 N = abs(In);


	if( N.z > N.x && N.z > N.y )
	{
		Axis1 = float3(1, 0, 0);
	}
	else
	{
		Axis1 = float3(0, 0, 1);
	}

	Axis1 = normalize(Axis1 - In * dot(Axis1, In));
	Axis2 = cross(Axis1, In);
}
#line 215 "/Engine/Private/Random.ush"
uint2 ScrambleTEA(uint2 v, uint IterationCount = 3)
{

	uint k[4] ={ 0xA341316Cu , 0xC8013EA4u , 0xAD90777Du , 0x7E95761Eu };

	uint y = v[0];
	uint z = v[1];
	uint sum = 0;

	[unroll]  for(uint i = 0; i < IterationCount; ++i)
	{
		sum += 0x9e3779b9;
		y += ((z << 4u) + k[0]) ^ (z + sum) ^ ((z >> 5u) + k[1]);
		z += ((y << 4u) + k[2]) ^ (y + sum) ^ ((y >> 5u) + k[3]);
	}

	return uint2(y, z);
}






float3 NoiseTileWrap(float3 v, bool bTiling, float RepeatSize)
{
	return bTiling ? (frac(v / RepeatSize) * RepeatSize) : v;
}




float4 PerlinRamp(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}




float4 PerlinRampDerivative(float4 t)
{
	return t * t * (t * (t * 30 - 60) + 30);
}







float4 MGradient(int seed, float3 offset)
{
	uint rand = Rand3DPCG16(int3(seed,0,0)).x;
	float3 direction = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	return float4(direction, dot(direction, offset));
}







float3 NoiseSeeds(float3 v, bool bTiling, float RepeatSize,
	out float seed000, out float seed001, out float seed010, out float seed011,
	out float seed100, out float seed101, out float seed110, out float seed111)
{
	float3 fv = frac(v);
	float3 iv = floor(v);

	const float3 primes = float3(19, 47, 101);

	if (bTiling)
	{
		seed000 = dot(primes, NoiseTileWrap(iv, true, RepeatSize));
		seed100 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 0), true, RepeatSize));
		seed010 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 0), true, RepeatSize));
		seed110 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 0), true, RepeatSize));
		seed001 = dot(primes, NoiseTileWrap(iv + float3(0, 0, 1), true, RepeatSize));
		seed101 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 1), true, RepeatSize));
		seed011 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 1), true, RepeatSize));
		seed111 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 1), true, RepeatSize));
	}
	else
	{
		seed000 = dot(iv, primes);
		seed100 = seed000 + primes.x;
		seed010 = seed000 + primes.y;
		seed110 = seed100 + primes.y;
		seed001 = seed000 + primes.z;
		seed101 = seed100 + primes.z;
		seed011 = seed010 + primes.z;
		seed111 = seed110 + primes.z;
	}

	return fv;
}







float GradientNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = MGradient(int(seed000), fv - float3(0, 0, 0)).w;
	float rand100 = MGradient(int(seed100), fv - float3(1, 0, 0)).w;
	float rand010 = MGradient(int(seed010), fv - float3(0, 1, 0)).w;
	float rand110 = MGradient(int(seed110), fv - float3(1, 1, 0)).w;
	float rand001 = MGradient(int(seed001), fv - float3(0, 0, 1)).w;
	float rand101 = MGradient(int(seed101), fv - float3(1, 0, 1)).w;
	float rand011 = MGradient(int(seed011), fv - float3(0, 1, 1)).w;
	float rand111 = MGradient(int(seed111), fv - float3(1, 1, 1)).w;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}





float4x3 SimplexCorners(float3 v)
{

	float3 tet = floor(v + v.x/3 + v.y/3 + v.z/3);
	float3 base = tet - tet.x/6 - tet.y/6 - tet.z/6;
	float3 f = v - base;



	float3 g = step(f.yzx, f.xyz), h = 1 - g.zxy;
	float3 a1 = min(g, h) - 1. / 6., a2 = max(g, h) - 1. / 3.;


	return float4x3(base, base + a1, base + a2, base + 0.5);
}




float4 SimplexSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	return (1 * scale + s*(-3 * scale + s*(3 * scale - s*scale)));
}




float3x4 SimplexDSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	s = -12 * scale + s*(24 * scale - s * 12 * scale);

	return float3x4(
		s * float4(f[0][0], f[1][0], f[2][0], f[3][0]),
		s * float4(f[0][1], f[1][1], f[2][1], f[3][1]),
		s * float4(f[0][2], f[1][2], f[2][2], f[3][2]));
}
#line 403 "/Engine/Private/Random.ush"
float3x4 JacobianSimplex_ALU(float3 v, bool bTiling, float RepeatSize)
{

	float4x3 T = SimplexCorners(v);
	uint3 rand;
	float4x3 gvec[3], fv;
	float3x4 grad;



	fv[0] = v - T[0];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[0] + 0.5, bTiling, RepeatSize))));
	gvec[0][0] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][0] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][0] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][0] = dot(gvec[0][0], fv[0]);
	grad[1][0] = dot(gvec[1][0], fv[0]);
	grad[2][0] = dot(gvec[2][0], fv[0]);

	fv[1] = v - T[1];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[1] + 0.5, bTiling, RepeatSize))));
	gvec[0][1] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][1] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][1] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][1] = dot(gvec[0][1], fv[1]);
	grad[1][1] = dot(gvec[1][1], fv[1]);
	grad[2][1] = dot(gvec[2][1], fv[1]);

	fv[2] = v - T[2];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[2] + 0.5, bTiling, RepeatSize))));
	gvec[0][2] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][2] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][2] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][2] = dot(gvec[0][2], fv[2]);
	grad[1][2] = dot(gvec[1][2], fv[2]);
	grad[2][2] = dot(gvec[2][2], fv[2]);

	fv[3] = v - T[3];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[3] + 0.5, bTiling, RepeatSize))));
	gvec[0][3] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][3] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][3] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][3] = dot(gvec[0][3], fv[3]);
	grad[1][3] = dot(gvec[1][3], fv[3]);
	grad[2][3] = dot(gvec[2][3], fv[3]);


	float4 sv = SimplexSmooth(fv);
	float3x4 ds = SimplexDSmooth(fv);

	float3x4 jacobian;
	jacobian[0] = float4(mul(sv, gvec[0]) + mul(ds, grad[0]), dot(sv, grad[0]));
	jacobian[1] = float4(mul(sv, gvec[1]) + mul(ds, grad[1]), dot(sv, grad[1]));
	jacobian[2] = float4(mul(sv, gvec[2]) + mul(ds, grad[2]), dot(sv, grad[2]));

	return jacobian;
}






float ValueNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = RandBBSfloat(seed000) * 2 - 1;
	float rand100 = RandBBSfloat(seed100) * 2 - 1;
	float rand010 = RandBBSfloat(seed010) * 2 - 1;
	float rand110 = RandBBSfloat(seed110) * 2 - 1;
	float rand001 = RandBBSfloat(seed001) * 2 - 1;
	float rand101 = RandBBSfloat(seed101) * 2 - 1;
	float rand011 = RandBBSfloat(seed011) * 2 - 1;
	float rand111 = RandBBSfloat(seed111) * 2 - 1;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}









float GradientNoise3D_TEX(float3 v, bool bTiling, float RepeatSize)
{
	bTiling = true;
	float3 fv = frac(v);
	float3 iv0 = NoiseTileWrap(floor(v), bTiling, RepeatSize);
	float3 iv1 = NoiseTileWrap(iv0 + 1, bTiling, RepeatSize);

	const int2 ZShear = int2(17, 89);

	float2 OffsetA = iv0.z * ZShear;
	float2 OffsetB = OffsetA + ZShear;
	if (bTiling)
	{
		OffsetB = iv1.z * ZShear;
	}


	float ts = 1 / 128.0f;


	float2 TexA0 = (iv0.xy + OffsetA + 0.5f) * ts;
	float2 TexB0 = (iv0.xy + OffsetB + 0.5f) * ts;


	float2 TexA1 = TexA0 + ts;
	float2 TexB1 = TexB0 + ts;
	if (bTiling)
	{
		TexA1 = (iv1.xy + OffsetA + 0.5f) * ts;
		TexB1 = (iv1.xy + OffsetB + 0.5f) * ts;
	}



	float3 A = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA0.y), 0).xyz * 2 - 1;
	float3 B = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA0.y), 0).xyz * 2 - 1;
	float3 C = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA1.y), 0).xyz * 2 - 1;
	float3 D = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA1.y), 0).xyz * 2 - 1;
	float3 E = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB0.y), 0).xyz * 2 - 1;
	float3 F = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB0.y), 0).xyz * 2 - 1;
	float3 G = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB1.y), 0).xyz * 2 - 1;
	float3 H = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB1.y), 0).xyz * 2 - 1;

	float a = dot(A, fv - float3(0, 0, 0));
	float b = dot(B, fv - float3(1, 0, 0));
	float c = dot(C, fv - float3(0, 1, 0));
	float d = dot(D, fv - float3(1, 1, 0));
	float e = dot(E, fv - float3(0, 0, 1));
	float f = dot(F, fv - float3(1, 0, 1));
	float g = dot(G, fv - float3(0, 1, 1));
	float h = dot(H, fv - float3(1, 1, 1));

	float3 Weights = PerlinRamp(frac(float4(fv, 0))).xyz;

	float i = lerp(lerp(a, b, Weights.x), lerp(c, d, Weights.x), Weights.y);
	float j = lerp(lerp(e, f, Weights.x), lerp(g, h, Weights.x), Weights.y);

	return lerp(i, j, Weights.z);
}



float FastGradientPerlinNoise3D_TEX(float3 xyz)
{

	float Extent = 16;



	xyz = frac(xyz / (Extent - 1)) * (Extent - 1);


	float3 uvw = frac(xyz);


	float3 p0 = xyz - uvw;


	float3 f = PerlinRamp(float4(uvw, 0)).xyz;

	float3 p = p0 + f;

	float4 NoiseSample = Texture3DSampleLevel(View_PerlinNoise3DTexture, View_PerlinNoise3DTextureSampler, p / Extent + 0.5f / Extent, 0);



	float3 n = NoiseSample.xyz * 255.0f / 127.0f - 1.0f;
	float d = NoiseSample.w * 255.f - 127;
	return dot(xyz, n) - d;
}





float3 VoronoiCornerSample(float3 pos, int Quality)
{

	float3 noise = float3(Rand3DPCG16(int3(pos))) / 0xffff - 0.5;



	if (Quality <= 2)
	{
		return normalize(noise) * 0.2588;
	}



	if (Quality == 3)
	{
		return normalize(noise) * 0.3090;
	}


	return noise;
}








float4 VoronoiCompare(float4 minval, float3 candidate, float3 offset, bool bDistanceOnly)
{
	if (bDistanceOnly)
	{
		return float4(0, 0, 0, min(minval.w, dot(offset, offset)));
	}
	else
	{
		float newdist = dot(offset, offset);
		return newdist > minval.w ? minval : float4(candidate, newdist);
	}
}


float4 VoronoiNoise3D_ALU(float3 v, int Quality, bool bTiling, float RepeatSize, bool bDistanceOnly)
{
	float3 fv = frac(v), fv2 = frac(v + 0.5);
	float3 iv = floor(v), iv2 = floor(v + 0.5);


	float4 mindist = float4(0,0,0,100);
	float3 p, offset;


	if (Quality == 3)
	{
		[unroll]  for (offset.x = -1; offset.x <= 1; ++offset.x)
		{
			[unroll]  for (offset.y = -1; offset.y <= 1; ++offset.y)
			{
				[unroll]  for (offset.z = -1; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
				}
			}
		}
	}


	else
	{
		[unroll(3)]  for (offset.x = 0; offset.x <= 1; ++offset.x)
		{
			[unroll(3)]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll(3)]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					if (Quality == 2)
					{

						p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize) + 467, Quality);
						mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
					}
				}
			}
		}
	}


	if (Quality >= 4)
	{
		[unroll(3)]  for (offset.x = -1; offset.x <= 2; offset.x += 3)
		{
			[unroll(3)]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll(3)]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{

					p = offset.xyz + VoronoiCornerSample(NoiseTileWrap(iv + offset.xyz, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.yzx + VoronoiCornerSample(NoiseTileWrap(iv + offset.yzx, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.zxy + VoronoiCornerSample(NoiseTileWrap(iv + offset.zxy, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
				}
			}
		}
	}


	return float4(mindist.xyz, sqrt(mindist.w));
}







float3 ComputeSimplexWeights2D(float2 OrthogonalPos, out float2 PosA, out float2 PosB, out float2 PosC)
{
	float2 OrthogonalPosFloor = floor(OrthogonalPos);
	PosA = OrthogonalPosFloor;
	PosB = PosA + float2(1, 1);

	float2 LocalPos = OrthogonalPos - OrthogonalPosFloor;

	PosC = PosA + ((LocalPos.x > LocalPos.y) ? float2(1,0) : float2(0,1));

	float b = min(LocalPos.x, LocalPos.y);
	float c = abs(LocalPos.y - LocalPos.x);
	float a = 1.0f - b - c;

	return float3(a, b, c);
}



float4 ComputeSimplexWeights3D(float3 OrthogonalPos, out float3 PosA, out float3 PosB, out float3 PosC, out float3 PosD)
{
	float3 OrthogonalPosFloor = floor(OrthogonalPos);

	PosA = OrthogonalPosFloor;
	PosB = PosA + float3(1, 1, 1);

	OrthogonalPos -= OrthogonalPosFloor;

	float Largest = max(OrthogonalPos.x, max(OrthogonalPos.y, OrthogonalPos.z));
	float Smallest = min(OrthogonalPos.x, min(OrthogonalPos.y, OrthogonalPos.z));

	PosC = PosA + float3(Largest == OrthogonalPos.x, Largest == OrthogonalPos.y, Largest == OrthogonalPos.z);
	PosD = PosA + float3(Smallest != OrthogonalPos.x, Smallest != OrthogonalPos.y, Smallest != OrthogonalPos.z);

	float4 ret;

	float RG = OrthogonalPos.x - OrthogonalPos.y;
	float RB = OrthogonalPos.x - OrthogonalPos.z;
	float GB = OrthogonalPos.y - OrthogonalPos.z;

	ret.b =
		  min(max(0, RG), max(0, RB))
		+ min(max(0, -RG), max(0, GB))
		+ min(max(0, -RB), max(0, -GB));

	ret.a =
		  min(max(0, -RG), max(0, -RB))
		+ min(max(0, RG), max(0, -GB))
		+ min(max(0, RB), max(0, GB));

	ret.g = Smallest;
	ret.r = 1.0f - ret.g - ret.b - ret.a;

	return ret;
}

float2 GetPerlinNoiseGradientTextureAt(float2 v)
{
	float2 TexA = (v.xy + 0.5f) / 128.0f;


	float3 p = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA, 0).xyz * 2 - 1;
	return normalize(p.xy + p.z * 0.33f);
}

float3 GetPerlinNoiseGradientTextureAt(float3 v)
{
	const float2 ZShear = float2(17.0f, 89.0f);

	float2 OffsetA = v.z * ZShear;
	float2 TexA = (v.xy + OffsetA + 0.5f) / 128.0f;

	return Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA , 0).xyz * 2 - 1;
}

float2 SkewSimplex(float2 In)
{
	return In + dot(In, (sqrt(3.0f) - 1.0f) * 0.5f );
}
float2 UnSkewSimplex(float2 In)
{
	return In - dot(In, (3.0f - sqrt(3.0f)) / 6.0f );
}
float3 SkewSimplex(float3 In)
{
	return In + dot(In, 1.0 / 3.0f );
}
float3 UnSkewSimplex(float3 In)
{
	return In - dot(In, 1.0 / 6.0f );
}




float GradientSimplexNoise2D_TEX(float2 EvalPos)
{
	float2 OrthogonalPos = SkewSimplex(EvalPos);

	float2 PosA, PosB, PosC, PosD;
	float3 Weights = ComputeSimplexWeights2D(OrthogonalPos, PosA, PosB, PosC);


	float2 A = GetPerlinNoiseGradientTextureAt(PosA);
	float2 B = GetPerlinNoiseGradientTextureAt(PosB);
	float2 C = GetPerlinNoiseGradientTextureAt(PosC);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);

	float DistanceWeight;

	DistanceWeight = saturate(0.5f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;

	return 70 * (a + b + c);
}






float SimplexNoise3D_TEX(float3 EvalPos)
{
	float3 OrthogonalPos = SkewSimplex(EvalPos);

	float3 PosA, PosB, PosC, PosD;
	float4 Weights = ComputeSimplexWeights3D(OrthogonalPos, PosA, PosB, PosC, PosD);


	float3 A = GetPerlinNoiseGradientTextureAt(PosA);
	float3 B = GetPerlinNoiseGradientTextureAt(PosB);
	float3 C = GetPerlinNoiseGradientTextureAt(PosC);
	float3 D = GetPerlinNoiseGradientTextureAt(PosD);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);
	PosD = UnSkewSimplex(PosD);

	float DistanceWeight;

	DistanceWeight = saturate(0.6f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosD)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float d = dot(D, EvalPos - PosD) * DistanceWeight;

	return 32 * (a + b + c + d);
}


float VolumeRaymarch(float3 posPixelWS, float3 posCameraWS)
{
	float ret = 0;
	int cnt = 60;

	[loop]  for(int i=0; i < cnt; ++i)
	{
		ret += saturate(FastGradientPerlinNoise3D_TEX(lerp(posPixelWS, posCameraWS, i/(float)cnt) * 0.01) - 0.2f);
	}

	return ret / cnt * (length(posPixelWS - posCameraWS) * 0.001f );
}
#line 589 "/Engine/Private/Common.ush"
#line 594 "/Engine/Private/Common.ush"
float  PhongShadingPow( float  X,  float  Y)
{
#line 612 "/Engine/Private/Common.ush"
	return ClampedPow(X, Y);
}
#line 646 "/Engine/Private/Common.ush"
Texture2D LightAttenuationTexture;
SamplerState LightAttenuationTextureSampler;





float ConvertTangentUnormToSnorm8(float Input)
{
	int IntVal = int(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float2 ConvertTangentUnormToSnorm8(float2 Input)
{
	int2 IntVal = int2(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float3 ConvertTangentUnormToSnorm8(float3 Input)
{
	int3 IntVal = int3(round(Input * 255.0f));
	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float4 ConvertTangentUnormToSnorm8(float4 Input)
{
	int4 IntVal = int4(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float ConvertTangentUnormToSnorm16(float Input)
{
	int IntVal = int(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFF8000) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float2 ConvertTangentUnormToSnorm16(float2 Input)
{
	int2 IntVal = int2(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float3 ConvertTangentUnormToSnorm16(float3 Input)
{
	int3 IntVal = int3(round(Input * 65535.0f));
	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float4 ConvertTangentUnormToSnorm16(float4 Input)
{
	int4 IntVal = int4(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float ConvertTangentSnormToUnorm8(float Input)
{
	float Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float2 ConvertTangentSnormToUnorm8(float2 Input)
{
	float2 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float3 ConvertTangentSnormToUnorm8(float3 Input)
{
	float3 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float4 ConvertTangentSnormToUnorm8(float4 Input)
{
	float4 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float ConvertTangentSnormToUnorm16(float Input)
{
	float Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float2 ConvertTangentSnormToUnorm16(float2 Input)
{
	float2 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float3 ConvertTangentSnormToUnorm16(float3 Input)
{
	float3 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float4 ConvertTangentSnormToUnorm16(float4 Input)
{
	float4 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}






float Square( float x )
{
	return x*x;
}

float2 Square( float2 x )
{
	return x*x;
}

float3 Square( float3 x )
{
	return x*x;
}

float4 Square( float4 x )
{
	return x*x;
}

float Pow2( float x )
{
	return x*x;
}

float2 Pow2( float2 x )
{
	return x*x;
}

float3 Pow2( float3 x )
{
	return x*x;
}

float4 Pow2( float4 x )
{
	return x*x;
}

float Pow3( float x )
{
	return x*x*x;
}

float2 Pow3( float2 x )
{
	return x*x*x;
}

float3 Pow3( float3 x )
{
	return x*x*x;
}

float4 Pow3( float4 x )
{
	return x*x*x;
}

float Pow4( float x )
{
	float xx = x*x;
	return xx * xx;
}

float2 Pow4( float2 x )
{
	float2 xx = x*x;
	return xx * xx;
}

float3 Pow4( float3 x )
{
	float3 xx = x*x;
	return xx * xx;
}

float4 Pow4( float4 x )
{
	float4 xx = x*x;
	return xx * xx;
}

float Pow5( float x )
{
	float xx = x*x;
	return xx * xx * x;
}

float2 Pow5( float2 x )
{
	float2 xx = x*x;
	return xx * xx * x;
}

float3 Pow5( float3 x )
{
	float3 xx = x*x;
	return xx * xx * x;
}

float4 Pow5( float4 x )
{
	float4 xx = x*x;
	return xx * xx * x;
}

float Pow6( float x )
{
	float xx = x*x;
	return xx * xx * xx;
}

float2 Pow6( float2 x )
{
	float2 xx = x*x;
	return xx * xx * xx;
}

float3 Pow6( float3 x )
{
	float3 xx = x*x;
	return xx * xx * xx;
}

float4 Pow6( float4 x )
{
	float4 xx = x*x;
	return xx * xx * xx;
}


float  AtanFast(  float  x )
{

	float3  A = x < 1 ?  float3 ( x, 0, 1 ) :  float3 ( 1/x, 0.5 * PI, -1 );
	return A.y + A.z * ( ( ( -0.130234 * A.x - 0.0954105 ) * A.x + 1.00712 ) * A.x - 0.00001203333 );
}


float  EncodeLightAttenuation( float  InColor)
{


	return sqrt(InColor);
}


float4  EncodeLightAttenuation( float4  InColor)
{
	return sqrt(InColor);
}


float4  RGBTEncode( float3  Color)
{
	float4  RGBT;
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	RGBT.a = Max * rcp(1.0 + Max);
	return RGBT;
}

float3  RGBTDecode( float4  RGBT)
{
	RGBT.a = RGBT.a * rcp(1.0 - RGBT.a);
	return RGBT.rgb * RGBT.a;
}



float4  RGBMEncode(  float3  Color )
{
	Color *= 1.0 / 64.0;

	float4 rgbm;
	rgbm.a = saturate( max( max( Color.r, Color.g ), max( Color.b, 1e-6 ) ) );
	rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
	rgbm.rgb = Color / rgbm.a;
	return rgbm;
}

float4  RGBMEncodeFast(  float3  Color )
{

	float4  rgbm;
	rgbm.a = dot( Color, 255.0 / 64.0 );
	rgbm.a = ceil( rgbm.a );
	rgbm.rgb = Color / rgbm.a;
	rgbm *=  float4 ( 255.0 / 64.0, 255.0 / 64.0, 255.0 / 64.0, 1.0 / 255.0 );
	return rgbm;
}

float3  RGBMDecode(  float4  rgbm,  float  MaxValue )
{
	return rgbm.rgb * (rgbm.a * MaxValue);
}

float3  RGBMDecode(  float4  rgbm )
{
	return rgbm.rgb * (rgbm.a * 64.0f);
}

float4  RGBTEncode8BPC( float3  Color,  float  Range)
{
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	Max = min(Max, Range);

	float4  RGBT;
	RGBT.a = (Range + 1) / Range * Max / (1 + Max);


	RGBT.a = ceil(RGBT.a*255.0) / 255.0;
	Max = RGBT.a / (1 + 1 / Range - RGBT.a);

	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	return RGBT;
}

float3  RGBTDecode8BPC( float4  RGBT,  float  Range)
{
	RGBT.a = RGBT.a / (1 + 1 / Range - RGBT.a);
	return RGBT.rgb * RGBT.a;
}
#line 1015 "/Engine/Private/Common.ush"
float2 CalcScreenUVFromOffsetFraction(float4 ScreenPosition, float2 OffsetFraction)
{
	float2 NDC = ScreenPosition.xy / ScreenPosition.w;



	float2 OffsetNDC = clamp(NDC + OffsetFraction * float2(2, -2), -.999f, .999f);
	return float2(OffsetNDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float4 GetPerPixelLightAttenuation(float2 UV)
{
	return Square(Texture2DSampleLevel(LightAttenuationTexture, LightAttenuationTextureSampler, UV, 0));
}




float ConvertFromDeviceZ(float DeviceZ)
{

	return DeviceZ * View_InvDeviceZToWorldZTransform[0] + View_InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * View_InvDeviceZToWorldZTransform[2] - View_InvDeviceZToWorldZTransform[3]);
}




float ConvertToDeviceZ(float SceneDepth)
{
	[flatten]
	if (View_ViewToClip[3][3] < 1.0f)
	{

		return 1.0f / ((SceneDepth + View_InvDeviceZToWorldZTransform[3]) * View_InvDeviceZToWorldZTransform[2]);
	}
	else
	{

		return SceneDepth * View_ViewToClip[2][2] + View_ViewToClip[3][2];
	}
}

float2 ScreenPositionToBufferUV(float4 ScreenPosition)
{
	return float2(ScreenPosition.xy / ScreenPosition.w * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float2 SvPositionToBufferUV(float4 SvPosition)
{
	return SvPosition.xy * View_BufferSizeAndInvSize.zw;
}


float3 SvPositionToTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), View_SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


float3 SvPositionToResolvedTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), ResolvedView.SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


float3 SvPositionToWorld(float4 SvPosition)
{
	return SvPositionToTranslatedWorld(SvPosition) - View_PreViewTranslation;
}


float4 SvPositionToScreenPosition(float4 SvPosition)
{



	float2 PixelPos = SvPosition.xy - View_ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * View_ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}


float4 SvPositionToResolvedScreenPosition(float4 SvPosition)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}

float2 SvPositionToViewportUV(float4 SvPosition)
{

	float2 PixelPos = SvPosition.xy - View_ViewRectMin.xy;

	return PixelPos.xy * View_ViewSizeAndInvSize.zw;
}

float2 BufferUVToViewportUV(float2 BufferUV)
{
	float2 PixelPos = BufferUV.xy * View_BufferSizeAndInvSize.xy - View_ViewRectMin.xy;
	return PixelPos.xy * View_ViewSizeAndInvSize.zw;
}

float2 ViewportUVToBufferUV(float2 ViewportUV)
{
	float2 PixelPos = ViewportUV * View_ViewSizeAndInvSize.xy;
	return (PixelPos + View_ViewRectMin.xy) * View_BufferSizeAndInvSize.zw;
}


float2 ViewportUVToScreenPos(float2 ViewportUV)
{
	return float2(2 * ViewportUV.x - 1, 1 - 2 * ViewportUV.y);
}

float2 ScreenPosToViewportUV(float2 ScreenPos)
{
	return float2(0.5 + 0.5 * ScreenPos.x, 0.5 - 0.5 * ScreenPos.y);
}



float3 ScreenToViewPos(float2 ViewportUV, float SceneDepth)
{
	float2 ProjViewPos;

	ProjViewPos.x = ViewportUV.x * View_ScreenToViewSpace.x + View_ScreenToViewSpace.z;
	ProjViewPos.y = ViewportUV.y * View_ScreenToViewSpace.y + View_ScreenToViewSpace.w;
	return float3(ProjViewPos * SceneDepth, SceneDepth);
}
#line 1164 "/Engine/Private/Common.ush"
float2  ScreenAlignedPosition( float4 ScreenPosition )
{
	return  float2 (ScreenPositionToBufferUV(ScreenPosition));
}
#line 1172 "/Engine/Private/Common.ush"
float2  ScreenAlignedUV(  float2  UV )
{
	return (UV* float2 (2,-2) +  float2 (-1,1))*View_ScreenPositionScaleBias.xy + View_ScreenPositionScaleBias.wz;
}
#line 1180 "/Engine/Private/Common.ush"
float2  GetViewportCoordinates( float2  InFragmentCoordinates)
{
	return InFragmentCoordinates;
}
#line 1188 "/Engine/Private/Common.ush"
float4  UnpackNormalMap(  float4  TextureSample )
{



		float2  NormalXY = TextureSample.rg;


	NormalXY = NormalXY *  float2 (2.0f,2.0f) -  float2 (1.0f,1.0f);
	float  NormalZ = sqrt( saturate( 1.0f - dot( NormalXY, NormalXY ) ) );
	return  float4 ( NormalXY.xy, NormalZ, 1.0f );
}


float AntialiasedTextureMask( Texture2D Tex, SamplerState Sampler, float2 UV, float ThresholdConst, int Channel )
{

	float4  MaskConst =  float4 (Channel == 0, Channel == 1, Channel == 2, Channel == 3);


	const float WidthConst = 1.0f;
	float InvWidthConst = 1 / WidthConst;
#line 1232 "/Engine/Private/Common.ush"
	float Result;
	{

		float Sample1 = dot(MaskConst, Texture2DSample(Tex, Sampler, UV));


		float2 TexDD = float2(DDX(Sample1), DDY(Sample1));

		float TexDDLength = max(abs(TexDD.x), abs(TexDD.y));
		float Top = InvWidthConst * (Sample1 - ThresholdConst);
		Result = Top / TexDDLength + ThresholdConst;
	}

	Result = saturate(Result);

	return Result;
}



float Noise3D_Multiplexer(int Function, float3 Position, int Quality, bool bTiling, float RepeatSize)
{

	switch(Function)
	{
		case 0:
			return SimplexNoise3D_TEX(Position);
		case 1:
			return GradientNoise3D_TEX(Position, bTiling, RepeatSize);
		case 2:
			return FastGradientPerlinNoise3D_TEX(Position);
		case 3:
			return GradientNoise3D_ALU(Position, bTiling, RepeatSize);
		case 4:
			return ValueNoise3D_ALU(Position, bTiling, RepeatSize);
		default:
			return VoronoiNoise3D_ALU(Position, Quality, bTiling, RepeatSize, true).w * 2. - 1.;
	}
	return 0;
}



float  MaterialExpressionNoise(float3 Position, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	Position *= Scale;
	FilterWidth *= Scale;

	float Out = 0.0f;
	float OutScale = 1.0f;
	float InvLevelScale = 1.0f / LevelScale;

	[loop]  for(uint i = 0; i < Levels; ++i)
	{

		OutScale *= saturate(1.0 - FilterWidth);

		if(bTurbulence)
		{
			Out += abs(Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize)) * OutScale;
		}
		else
		{
			Out += Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize) * OutScale;
		}

		Position *= LevelScale;
		RepeatSize *= LevelScale;
		OutScale *= InvLevelScale;
		FilterWidth *= LevelScale;
	}

	if(!bTurbulence)
	{

		Out = Out * 0.5f + 0.5f;
	}


	return lerp(OutputMin, OutputMax, Out);
}





float4  MaterialExpressionVectorNoise( float3  Position, int Quality, int Function, bool bTiling, float TileSize)
{
	float4 result = float4(0,0,0,1);
	float3x4 Jacobian = JacobianSimplex_ALU(Position, bTiling, TileSize);


	switch (Function)
	{
	case 0:
		result.xyz = float3(Rand3DPCG16(int3(floor(NoiseTileWrap(Position, bTiling, TileSize))))) / 0xffff;
		break;
	case 1:
		result.xyz = float3(Jacobian[0].w, Jacobian[1].w, Jacobian[2].w);
		break;
	case 2:
		result = Jacobian[0];
		break;
	case 3:
		result.xyz = float3(Jacobian[2][1] - Jacobian[1][2], Jacobian[0][2] - Jacobian[2][0], Jacobian[1][0] - Jacobian[0][1]);
		break;
	default:
		result = VoronoiNoise3D_ALU(Position, Quality, bTiling, TileSize, false);
		break;
	}
	return result;
}
#line 1359 "/Engine/Private/Common.ush"
float2 LineBoxIntersect(float3 RayOrigin, float3 RayEnd, float3 BoxMin, float3 BoxMax)
{
	float3 InvRayDir = 1.0f / (RayEnd - RayOrigin);


	float3 FirstPlaneIntersections = (BoxMin - RayOrigin) * InvRayDir;

	float3 SecondPlaneIntersections = (BoxMax - RayOrigin) * InvRayDir;

	float3 ClosestPlaneIntersections = min(FirstPlaneIntersections, SecondPlaneIntersections);

	float3 FurthestPlaneIntersections = max(FirstPlaneIntersections, SecondPlaneIntersections);

	float2 BoxIntersections;

	BoxIntersections.x = max(ClosestPlaneIntersections.x, max(ClosestPlaneIntersections.y, ClosestPlaneIntersections.z));

	BoxIntersections.y = min(FurthestPlaneIntersections.x, min(FurthestPlaneIntersections.y, FurthestPlaneIntersections.z));

	return saturate(BoxIntersections);
}


float  ComputeDistanceFromBoxToPoint( float3  Mins,  float3  Maxs,  float3  InPoint)
{
	float3  DistancesToMin = InPoint < Mins ? abs(InPoint - Mins) : 0;
	float3  DistancesToMax = InPoint > Maxs ? abs(InPoint - Maxs) : 0;


	float  Distance = dot(DistancesToMin, 1);
	Distance += dot(DistancesToMax, 1);
	return Distance;
}


float  ComputeSquaredDistanceFromBoxToPoint( float3  BoxCenter,  float3  BoxExtent,  float3  InPoint)
{
	float3  AxisDistances = max(abs(InPoint - BoxCenter) - BoxExtent, 0);
	return dot(AxisDistances, AxisDistances);
}


float ComputeDistanceFromBoxToPointInside(float3 BoxCenter, float3 BoxExtent, float3 InPoint)
{
	float3 DistancesToMin = max(InPoint - BoxCenter + BoxExtent, 0);
	float3 DistancesToMax = max(BoxCenter + BoxExtent - InPoint, 0);
	float3 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return min(ClosestDistances.x, min(ClosestDistances.y, ClosestDistances.z));
}

bool RayHitSphere(float3 RayOrigin, float3 UnitRayDirection, float3 SphereCenter, float SphereRadius)
{
	float3 ClosestPointOnRay = max(0, dot(SphereCenter - RayOrigin, UnitRayDirection)) * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius);
}

bool RaySegmentHitSphere(float3 RayOrigin, float3 UnitRayDirection, float RayLength, float3 SphereCenter, float SphereRadius)
{
	float DistanceAlongRay = dot(SphereCenter - RayOrigin, UnitRayDirection);
	float3 ClosestPointOnRay = DistanceAlongRay * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius) && DistanceAlongRay > -SphereRadius && DistanceAlongRay - SphereRadius < RayLength;
}
#line 1428 "/Engine/Private/Common.ush"
float2 RayIntersectSphere(float3 RayOrigin, float3 RayDirection, float4 Sphere)
{
	float3 LocalPosition = RayOrigin - Sphere.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);

	float3 QuadraticCoef;
	QuadraticCoef.x = dot(RayDirection, RayDirection);
	QuadraticCoef.y = 2 * dot(RayDirection, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - Sphere.w * Sphere.w;

	float Discriminant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * QuadraticCoef.z;

	float2 Intersections = -1;


	[flatten]
	if (Discriminant >= 0)
	{
		float SqrtDiscriminant = sqrt(Discriminant);
		Intersections = (-QuadraticCoef.y + float2(-1, 1) * SqrtDiscriminant) / (2 * QuadraticCoef.x);
	}

	return Intersections;
}


float3  TransformTangentVectorToWorld( float3x3  TangentToWorld,  float3  InTangentVector)
{


	return mul(InTangentVector, TangentToWorld);
}


float3  TransformWorldVectorToTangent( float3x3  TangentToWorld,  float3  InWorldVector)
{


	return mul(TangentToWorld, InWorldVector);
}

float3 TransformWorldVectorToView(float3 InTangentVector)
{

	return mul(InTangentVector, (float3x3)ResolvedView.TranslatedWorldToView);
}


float  GetBoxPushout( float3  Normal, float3  Extent)
{
	return dot(abs(Normal * Extent),  float3 (1.0f, 1.0f, 1.0f));
}


void GenerateCoordinateSystem(float3 ZAxis, out float3 XAxis, out float3 YAxis)
{
	if (abs(ZAxis.x) > abs(ZAxis.y))
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.xz, ZAxis.xz));
		XAxis = float3(-ZAxis.z * InverseLength, 0.0f, ZAxis.x * InverseLength);
	}
	else
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.yz, ZAxis.yz));
		XAxis = float3(0.0f, ZAxis.z * InverseLength, -ZAxis.y * InverseLength);
	}

	YAxis = cross(ZAxis, XAxis);
}
#line 1507 "/Engine/Private/Common.ush"
struct FScreenVertexOutput
{




	noperspective  float2  UV : TEXCOORD0;

	float4 Position : SV_POSITION;
};





float2 EncodeVelocityToTexture(float2 In)
{


	return In * (0.499f * 0.5f) + 32767.0f / 65535.0f;
}

float2 DecodeVelocityFromTexture(float2 In)
{
	const float InvDiv = 1.0f / (0.499f * 0.5f);



	return In * InvDiv - 32767.0f / 65535.0f * InvDiv;
}


bool GetGIReplaceState()
{



	return false;

}

bool GetRayTracingQualitySwitch()
{



	return false;

}



bool GetRuntimeVirtualTextureOutputSwitch()
{



	return false;

}


struct FWriteToSliceGeometryOutput
{
	FScreenVertexOutput Vertex;
	uint LayerIndex : SV_RenderTargetArrayIndex;
};







void DrawRectangle(
	in float4 InPosition,
	in float2 InTexCoord,
	out float4 OutPosition,
	out float2 OutTexCoord)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters_PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters_PosScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
	OutTexCoord.xy = (DrawRectangleParameters_UVScaleBias.zw + (InTexCoord.xy * DrawRectangleParameters_UVScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.zw;
}


void DrawRectangle(
	in float4 InPosition,
	in float2 InTexCoord,
	out float4 OutPosition,
	out float4 OutUVAndScreenPos)
{
	DrawRectangle(InPosition, InTexCoord, OutPosition, OutUVAndScreenPos.xy);
	OutUVAndScreenPos.zw = OutPosition.xy;
}


void DrawRectangle(in float4 InPosition, out float4 OutPosition)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters_PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters_PosScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
}
#line 1623 "/Engine/Private/Common.ush"
float SafeSaturate(float In) { return saturate(In);}
float2 SafeSaturate(float2 In) { return saturate(In);}
float3 SafeSaturate(float3 In) { return saturate(In);}
float4 SafeSaturate(float4 In) { return saturate(In);}
#line 1652 "/Engine/Private/Common.ush"
bool IsFinite(float In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool IsPositiveFinite(float In) { return asuint(In) < 0x7F800000; }float MakeFinite(float In) { return !IsFinite(In)? 0 : In; }float MakePositiveFinite(float In) { return !IsPositiveFinite(In)? 0 : In; }
bool2 IsFinite(float2 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool2 IsPositiveFinite(float2 In) { return asuint(In) < 0x7F800000; }float2 MakeFinite(float2 In) { return !IsFinite(In)? 0 : In; }float2 MakePositiveFinite(float2 In) { return !IsPositiveFinite(In)? 0 : In; }
bool3 IsFinite(float3 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool3 IsPositiveFinite(float3 In) { return asuint(In) < 0x7F800000; }float3 MakeFinite(float3 In) { return !IsFinite(In)? 0 : In; }float3 MakePositiveFinite(float3 In) { return !IsPositiveFinite(In)? 0 : In; }
bool4 IsFinite(float4 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool4 IsPositiveFinite(float4 In) { return asuint(In) < 0x7F800000; }float4 MakeFinite(float4 In) { return !IsFinite(In)? 0 : In; }float4 MakePositiveFinite(float4 In) { return !IsPositiveFinite(In)? 0 : In; }





bool GetShadowReplaceState()
{



	return false;

}

float IsShadowDepthShader()
{
	return GetShadowReplaceState() ? 1.0f : 0.0f;
}




float DecodePackedTwoChannelValue(float2 PackedHeight)
{
	return PackedHeight.x * 255.0 * 256.0 + PackedHeight.y * 255.0;
}

float DecodeHeightValue(float InValue)
{
	return (InValue - 32768.0) *  (1.0f/128.0f) ;
}

float DecodePackedHeight(float2 PackedHeight)
{
	return DecodeHeightValue(DecodePackedTwoChannelValue(PackedHeight));
}


uint ReverseBits32( uint bits )
{

	return reversebits( bits );
#line 1706 "/Engine/Private/Common.ush"
}


uint ReverseBitsN(uint Bitfield, const uint BitCount)
{
	return ReverseBits32(Bitfield) >> (32 - BitCount);
}


struct FPixelShaderIn
{

	float4 SvPosition;


	uint Coverage;


	bool bIsFrontFace;
};

struct FPixelShaderOut
{

	float4 MRT[8];


	uint Coverage;


	float Depth;
};
#line 12 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 1 "/Engine/Private/GlobalDistanceFieldShared.ush"
#line 12 "/Engine/Private/GlobalDistanceFieldShared.ush"
float MaxGlobalDistance;
#line 37 "/Engine/Private/GlobalDistanceFieldShared.ush"
	Texture3D GlobalDistanceFieldTexture0;
	Texture3D GlobalDistanceFieldTexture1;
	Texture3D GlobalDistanceFieldTexture2;
	Texture3D GlobalDistanceFieldTexture3;
	SamplerState GlobalDistanceFieldSampler0;
	SamplerState GlobalDistanceFieldSampler1;
	SamplerState GlobalDistanceFieldSampler2;
	SamplerState GlobalDistanceFieldSampler3;
	float4 GlobalVolumeCenterAndExtent[ 4 ];
	float4 GlobalVolumeWorldToUVAddAndMul[ 4 ];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
#line 63 "/Engine/Private/GlobalDistanceFieldShared.ush"
float4 SampleGlobalDistanceField(int ClipmapIndex, float3 UV)
{
	if (ClipmapIndex == 0)
	{
		return Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , UV, 0);
	}
	else if (ClipmapIndex == 1)
	{
		return Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , UV, 0);
	}
	else if (ClipmapIndex == 2)
	{
		return Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , UV, 0);
	}
	else
	{
		return Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , UV, 0);
	}
}

float3 ComputeGlobalUV(float3 WorldPosition, uint ClipmapIndex)
{

	float4 WorldToUVAddAndMul = GlobalVolumeWorldToUVAddAndMul[ClipmapIndex];
	return WorldPosition * WorldToUVAddAndMul.www + WorldToUVAddAndMul.xyz;
}

float GetDistanceToNearestSurfaceGlobalClipmap(float3 WorldPosition, uint ClipmapIndex, float OuterClipmapFade)
{
	float3 GlobalUV = ComputeGlobalUV(WorldPosition, ClipmapIndex);
	float DistanceToSurface = 0;
	if (ClipmapIndex == 0)
	{
		DistanceToSurface = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , GlobalUV, 0).x;
	}
	else if (ClipmapIndex == 1)
	{
		DistanceToSurface = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , GlobalUV, 0).x;
	}
	else if (ClipmapIndex == 2)
	{
		DistanceToSurface = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , GlobalUV, 0).x;
	}
	else if (ClipmapIndex == 3)
	{
		DistanceToSurface = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , GlobalUV, 0).x;
		DistanceToSurface = lerp(MaxGlobalDistance, DistanceToSurface, OuterClipmapFade);
	}
	return DistanceToSurface;
}

float GetDistanceToNearestSurfaceGlobal(float3 WorldPosition)
{
	float DistanceToSurface = MaxGlobalDistance;
	float DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[0].xyz, GlobalVolumeCenterAndExtent[0].www, WorldPosition);


	[branch]
	if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[0].w * GlobalVolumeTexelSize)
	{
		DistanceToSurface = GetDistanceToNearestSurfaceGlobalClipmap(WorldPosition, 0, 0);
	}
	else
	{
		DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[1].xyz, GlobalVolumeCenterAndExtent[1].www, WorldPosition);

		[branch]
		if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[1].w * GlobalVolumeTexelSize)
		{
			DistanceToSurface = GetDistanceToNearestSurfaceGlobalClipmap(WorldPosition, 1, 0);
		}
		else
		{
			DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[2].xyz, GlobalVolumeCenterAndExtent[2].www, WorldPosition);
			float DistanceFromLastClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[3].xyz, GlobalVolumeCenterAndExtent[3].www, WorldPosition);

			[branch]
			if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[2].w * GlobalVolumeTexelSize)
			{
				DistanceToSurface = GetDistanceToNearestSurfaceGlobalClipmap(WorldPosition, 2, 0);
			}
			else if (DistanceFromLastClipmap > GlobalVolumeCenterAndExtent[3].w * GlobalVolumeTexelSize)
			{

				float OuterClipmapFade = saturate(DistanceFromLastClipmap * 10 * GlobalVolumeWorldToUVAddAndMul[3].w);
				DistanceToSurface = GetDistanceToNearestSurfaceGlobalClipmap(WorldPosition, 3, OuterClipmapFade);
			}
		}
	}

	return DistanceToSurface;
}

float3 GetDistanceFieldGradientGlobalClipmap(float3 WorldPosition, uint ClipmapIndex)
{
	float3 GlobalUV = ComputeGlobalUV(WorldPosition, ClipmapIndex);

	float R = 0;
	float L = 0;
	float F = 0;
	float B = 0;
	float U = 0;
	float D = 0;

	if (ClipmapIndex == 0)
	{
		R = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x + GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		L = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x - GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		F = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y + GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		B = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y - GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		U = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z + GlobalVolumeTexelSize), 0).x;
		D = Texture3DSampleLevel(GlobalDistanceFieldTexture0,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z - GlobalVolumeTexelSize), 0).x;
	}
	else if (ClipmapIndex == 1)
	{
		R = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x + GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		L = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x - GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		F = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y + GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		B = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y - GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		U = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z + GlobalVolumeTexelSize), 0).x;
		D = Texture3DSampleLevel(GlobalDistanceFieldTexture1,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z - GlobalVolumeTexelSize), 0).x;
	}
	else if (ClipmapIndex == 2)
	{
		R = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x + GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		L = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x - GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		F = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y + GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		B = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y - GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		U = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z + GlobalVolumeTexelSize), 0).x;
		D = Texture3DSampleLevel(GlobalDistanceFieldTexture2,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z - GlobalVolumeTexelSize), 0).x;
	}
	else if (ClipmapIndex == 3)
	{
		R = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x + GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		L = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x - GlobalVolumeTexelSize, GlobalUV.y, GlobalUV.z), 0).x;
		F = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y + GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		B = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y - GlobalVolumeTexelSize, GlobalUV.z), 0).x;
		U = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z + GlobalVolumeTexelSize), 0).x;
		D = Texture3DSampleLevel(GlobalDistanceFieldTexture3,  GlobalDistanceFieldSampler0 , float3(GlobalUV.x, GlobalUV.y, GlobalUV.z - GlobalVolumeTexelSize), 0).x;
	}

	float Extent = GlobalVolumeCenterAndExtent[ClipmapIndex].w;
	float3 Gradient = .5f * float3(R - L, F - B, U - D) / Extent;
	return Gradient;
}

float3 GetDistanceFieldGradientGlobal(float3 WorldPosition)
{
	float3 Gradient = float3(0, 0, .001f);
	float DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[0].xyz, GlobalVolumeCenterAndExtent[0].www, WorldPosition);

	float BorderTexels = GlobalVolumeTexelSize * 4;

	[branch]
	if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[0].w * BorderTexels)
	{
		Gradient = GetDistanceFieldGradientGlobalClipmap(WorldPosition, 0);
	}
	else
	{
		DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[1].xyz, GlobalVolumeCenterAndExtent[1].www, WorldPosition);

		[branch]
		if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[1].w * BorderTexels)
		{
			Gradient = GetDistanceFieldGradientGlobalClipmap(WorldPosition, 1);
		}
		else
		{
			DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[2].xyz, GlobalVolumeCenterAndExtent[2].www, WorldPosition);
			float DistanceFromLastClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[3].xyz, GlobalVolumeCenterAndExtent[3].www, WorldPosition);

			[branch]
			if (DistanceFromClipmap > GlobalVolumeCenterAndExtent[2].w * BorderTexels)
			{
				Gradient = GetDistanceFieldGradientGlobalClipmap(WorldPosition, 2);
			}
			else if (DistanceFromLastClipmap > GlobalVolumeCenterAndExtent[3].w * BorderTexels)
			{
				Gradient = GetDistanceFieldGradientGlobalClipmap(WorldPosition, 3);
			}
		}
	}

	return Gradient;
}
#line 13 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 16 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	const static float TWO_PI = 3.1415926535897932f*2.0f;




float4 ModuloPrecise(float4 x, float4 y){ return x - y * trunc(x/y); }
float3 ModuloPrecise(float3 x, float3 y){ return x - y * trunc(x/y); }
float2 ModuloPrecise(float2 x, float2 y){ return x - y * trunc(x/y);}
float ModuloPrecise(float x, float y){ return x - y * trunc(x/y); }
int ModuloPrecise(int x, int y){ return x - y * (x/y); }
int Modulo(int x, int y){ return x - y * (x/y); }



float4 Reciprocal(float4 x){ return 1.0f/x;}
float3 Reciprocal(float3 x){ return 1.0f/x; }
float2 Reciprocal(float2 x){ return 1.0f/x;}
float Reciprocal(float x){ return 1.0f/x; }



bool NiagaraAll(bool b) { return b; }
bool NiagaraAny(bool b) { return b; }

bool NiagaraAll(bool2 b) { return all(b); }
bool NiagaraAll(bool3 b) { return all(b); }
bool NiagaraAll(bool4 b) { return all(b); }
bool NiagaraAny(bool2 b) { return any(b); }
bool NiagaraAny(bool3 b) { return any(b); }
bool NiagaraAny(bool4 b) { return any(b); }
#line 62 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	static uint3 GDispatchThreadId;
	static uint3 GGroupThreadId;
	static uint GCurrentPhase;
	static uint GEmitterTickCounter;
	static uint GSimStart;
	static uint GRandomSeedOffset = 0;
	static bool GStageWritesAlive = false;

	const static uint GSpawnPhase = 0;
	const static uint GUpdatePhase = 1;
#line 74 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 1 "/Engine/Private/SceneTexturesCommon.ush"
#line 19 "/Engine/Private/SceneTexturesCommon.ush"
float3 CalcSceneColor(float2 ScreenUV)
{



	return Texture2DSampleLevel(SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct_SceneColorTextureSampler, ScreenUV, 0).rgb;

}


float4 CalcFullSceneColor(float2 ScreenUV)
{



	return Texture2DSample(SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct_SceneColorTextureSampler,ScreenUV);

}

float CalcSceneDepth(float2 ScreenUV)
{



	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct_SceneDepthTextureSampler, ScreenUV, 0).r);

}
#line 50 "/Engine/Private/SceneTexturesCommon.ush"
float4 CalcSceneColorAndDepth( float2 ScreenUV )
{
	return float4(CalcSceneColor(ScreenUV), CalcSceneDepth(ScreenUV));
}


float LookupDeviceZ( float2 ScreenUV )
{




	return Texture2DSampleLevel(SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct_SceneDepthTextureSampler, ScreenUV, 0).r;

}


float CalcSceneDepth(uint2 PixelPos)
{



	float DeviceZ = SceneTexturesStruct_SceneDepthTextureNonMS.Load(int3(PixelPos, 0));


	return ConvertFromDeviceZ(DeviceZ);

}
#line 75 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 81 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	uint EmitterTickCounter;



	float4 Modulo(float4 x, float4 y){ return fmod(x,y); }
	float3 Modulo(float3 x, float3 y){ return fmod(x,y); }
	float2 Modulo(float2 x, float2 y){ return fmod(x,y); }
	float Modulo(float x, float y){ return fmod(x,y); }


	float3 WorldPositionFromSceneDepth(float2 ScreenPosition, float SceneDepth)
	{
		float4 HomogeneousWorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View_ScreenToWorld);
		return HomogeneousWorldPosition.xyz / HomogeneousWorldPosition.w;
	}





	float NiagaraInternalNoise(uint u, uint v, uint s)
	{
		uint Seed = (u * 1664525u + v) + s + GRandomSeedOffset;
		GRandomSeedOffset += Seed;
		return float(Rand3DPCG32(int3(u,v,Seed)).x) / 4294967296.0f;
	}




	int4 EmitterSpawnInfoOffsets[ (( 8 + 3) / 4) ];
	float4 EmitterSpawnInfoParams[ 8 ];

	static int GInterpSpawnIndex;
	static float Emitter_SpawnInterval;
	static float Emitter_InterpSpawnStartDt;
	static int Emitter_SpawnGroup;

	static int Engine_ExecutionCount;
	static int GGPUExecIndex;

	static uint GSpawnStartInstance;
	uint SpawnedInstances;
	uint UpdateStartInstance;

	void SetupExecIndexForGPU()
	{
		GGPUExecIndex = UpdateStartInstance + GDispatchThreadId.x;
		Engine_ExecutionCount = GSpawnStartInstance;
	}

	void SetupExecIndexAndSpawnInfoForGPU()
	{
		GGPUExecIndex = UpdateStartInstance + GDispatchThreadId.x - GSpawnStartInstance;

		int SpawnInfoIndex = 0;
		[unroll]
		for (int i = 0; i <  (( 8 + 3) / 4) ; ++i)
		{


			int4 CompareResults = GGPUExecIndex >= EmitterSpawnInfoOffsets[i];
			CompareResults = CompareResults & int4(1, 1, 1, 1);
			SpawnInfoIndex += CompareResults.x + CompareResults.y + CompareResults.z + CompareResults.w;
		}

		Emitter_SpawnInterval = EmitterSpawnInfoParams[SpawnInfoIndex].x;
		Emitter_InterpSpawnStartDt = EmitterSpawnInfoParams[SpawnInfoIndex].y;
		Emitter_SpawnGroup = asint(EmitterSpawnInfoParams[SpawnInfoIndex].z);

		int GroupSpawnStartIndex = asint(EmitterSpawnInfoParams[SpawnInfoIndex].w);
		GGPUExecIndex = GGPUExecIndex - GroupSpawnStartIndex;
		if ( SpawnInfoIndex == ( 8  - 1) )
		{
			Engine_ExecutionCount = int(SpawnedInstances) - GroupSpawnStartIndex;
		}
		else
		{
			int NextGroupSpawnStartIndex = asint(EmitterSpawnInfoParams[SpawnInfoIndex + 1].w);
			Engine_ExecutionCount = NextGroupSpawnStartIndex - GroupSpawnStartIndex;
		}
	}
#line 166 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	int ExecIndex()
	{
		return GGPUExecIndex;
	}
#line 193 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
float4 rand4(int Seed1, int Seed2, int Seed3, int Seed4)
{
	int4 v = int4(Seed4, Seed1, Seed2, Seed3) * 1664525 + 1013904223;

	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;
	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;






	return float4((v >> 8) & 0x00ffffff) / 16777216.0;

}







float3 rand3(int Seed1, int Seed2, int Seed3, int Seed4)
{
	int3 v = int3(Seed1, Seed2, Seed4 | (Seed3 << 16)) * 1664525 + 1013904223;

	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;

	return float3((v >> 8) & 0x00ffffff) / 16777216.0;
}


static int RandomCounterDeterministic = 0;


float rand(float x, int Seed1, int Seed2, int Seed3)
{
	RandomCounterDeterministic += 1;
	return rand3(Seed1, Seed2, Seed3, RandomCounterDeterministic).x * x;
}


float2 rand(float2 x, int Seed1, int Seed2, int Seed3)
{
	RandomCounterDeterministic += 1;
	return rand3(Seed1, Seed2, Seed3, RandomCounterDeterministic).xy * x;
}


float3 rand(float3 x, int Seed1, int Seed2, int Seed3)
{
	RandomCounterDeterministic += 1;
	return rand3(Seed1, Seed2, Seed3, RandomCounterDeterministic).xyz * x;
}


float4 rand(float4 x, int Seed1, int Seed2, int Seed3)
{
	RandomCounterDeterministic += 1;
	return rand4(Seed1, Seed2, Seed3, RandomCounterDeterministic).xyzw * x;
}


int rand(int x, int Seed1, int Seed2, int Seed3)
{


	RandomCounterDeterministic += 1;
	return int(rand3(Seed1, Seed2, Seed3, RandomCounterDeterministic).x * (x+1));
}
#line 288 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	static int RandomCounterNonDeterministic = -1;

	float rand(float x)
	{
		RandomCounterNonDeterministic -= 1;
		return rand4(GDispatchThreadId.x, EmitterTickCounter, GDispatchThreadId.x, RandomCounterNonDeterministic).x * x;
	}

	float2 rand(float2 x)
	{
		RandomCounterNonDeterministic -= 1;
		return rand4(GDispatchThreadId.x, EmitterTickCounter, GDispatchThreadId.x, RandomCounterNonDeterministic).xy * x;
	}

	float3 rand(float3 x)
	{
		RandomCounterNonDeterministic -= 1;
		return rand4(GDispatchThreadId.x, EmitterTickCounter, GDispatchThreadId.x, RandomCounterNonDeterministic).xyz * x;
	}

	float4 rand(float4 x)
	{
		RandomCounterNonDeterministic -= 1;
		return rand4(GDispatchThreadId.x, EmitterTickCounter, GDispatchThreadId.x, RandomCounterNonDeterministic).xyzw * x;
	}


	int rand(int x)
	{
		RandomCounterNonDeterministic -= 1;
		return int(rand4(GDispatchThreadId.x, EmitterTickCounter, GDispatchThreadId.x, RandomCounterNonDeterministic).x * (x+1));
	}
#line 344 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
float rand_float(float x)
{
	return rand(x.x);
}

float2 rand_float(float2 x)
{
	return float2(rand_float(x.x), rand_float(x.y));
}

float3 rand_float(float3 x)
{
	return float3(rand_float(x.x), rand_float(x.y), rand_float(x.z));
}

float4 rand_float(float4 x)
{
	return float4(rand_float(x.x), rand_float(x.y), rand_float(x.z), rand_float(x.w));
}

int rand_int(int x)
{



	return rand_float(x.x);
}


float rand_float(float x, int Seed1, int Seed2, int Seed3)
{
	return rand(x.x, Seed1, Seed2, Seed3);
}

float2 rand_float(float2 x, int Seed1, int Seed2, int Seed3)
{
	return rand(x, Seed1, Seed2, Seed3);
}

float3 rand_float(float3 x, int Seed1, int Seed2, int Seed3)
{
	return rand(x, Seed1, Seed2, Seed3);
}

float4 rand_float(float4 x, int Seed1, int Seed2, int Seed3)
{
	return rand(x, Seed1, Seed2, Seed3);
}

int rand_int(int x, int Seed1, int Seed2, int Seed3)
{


	return rand(x.x-1, Seed1, Seed2, Seed3);
}
#line 451 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	int DefaultSimulationStageIndex;
	int SimulationStageIndex;

	int IterationInterfaceCount;

	uint ComponentBufferSizeRead;
	uint ComponentBufferSizeWrite;
	int NumEventsPerParticle;
	int NumParticlesPerEvent;
	uint CopyInstancesBeforeStart;

	uint SimStart;
#line 466 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	Buffer<float> InputFloat;
	Buffer<int> InputInt;
	RWBuffer<int> RWOutputInt;
	RWBuffer<float> RWOutputFloat;

	RWBuffer<uint> RWInstanceCounts;
	uint ReadInstanceCountOffset;
	uint WriteInstanceCountOffset;

	Buffer<int> FreeIDList;
	RWBuffer<int> RWIDToIndexTable;

	void AcquireID(int DataSetID, out int IDIndex, out int IDAcquireTag)
	{

		int MustBe0[1];
		MustBe0[DataSetID] = 0;




		int SpawnIndex = UpdateStartInstance + GDispatchThreadId.x - GSpawnStartInstance;
		IDIndex = FreeIDList[SpawnIndex];
		IDAcquireTag = EmitterTickCounter;
	}

 	void UpdateID(int DataSetID, int IDIndex, int InstanceIndex)
	{

		int MustBe0[1];
		MustBe0[DataSetID] = 0;


		RWIDToIndexTable[IDIndex] = InstanceIndex;
	}
#line 512 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
		groupshared uint GroupSharedIndex[32];
		groupshared uint GroupSharedIndex4[8];
		groupshared uint GroupSharedIndex16[2];
		groupshared uint GroupSharedIndex64;
#line 522 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	int AcquireIndex(uniform int DataSetID, bool bDoAcquire)
	{

		int MustBe0[1];
		MustBe0[DataSetID] = 0;


		int PrevIdx = GSpawnStartInstance + SpawnedInstances;
#line 553 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
			GroupSharedIndex[GGroupThreadId.x] = bDoAcquire ? 1 : 0;
			GroupMemoryBarrierWithGroupSync();


			if ((GGroupThreadId.x & 0x3) == 0)
			{
				const uint Index = GGroupThreadId.x;

				const uint ActiveCount1 = GroupSharedIndex[Index];
				const uint ActiveCount2 = ActiveCount1 + GroupSharedIndex[Index + 1];
				const uint ActiveCount3 = ActiveCount2 + GroupSharedIndex[Index + 2];
				const uint ActiveCount4 = ActiveCount3 + GroupSharedIndex[Index + 3];

				GroupSharedIndex[Index] = 0;
				GroupSharedIndex[Index + 1] = ActiveCount1;
				GroupSharedIndex[Index + 2] = ActiveCount2;
				GroupSharedIndex[Index + 3] = ActiveCount3;
				GroupSharedIndex4[Index / 4] = ActiveCount4;
			}
			GroupMemoryBarrierWithGroupSync();


			if ((GGroupThreadId.x & 0xF) == 0)
			{
				const uint Index = GGroupThreadId.x / 4;

				const uint ActiveCount1 = GroupSharedIndex4[Index];
				const uint ActiveCount2 = ActiveCount1 + GroupSharedIndex4[Index + 1];
				const uint ActiveCount3 = ActiveCount2 + GroupSharedIndex4[Index + 2];
				const uint ActiveCount4 = ActiveCount3 + GroupSharedIndex4[Index + 3];

				GroupSharedIndex4[Index] = 0;
				GroupSharedIndex4[Index + 1] = ActiveCount1;
				GroupSharedIndex4[Index + 2] = ActiveCount2;
				GroupSharedIndex4[Index + 3] = ActiveCount3;
				GroupSharedIndex16[Index / 4] = ActiveCount4;
			}
			GroupMemoryBarrierWithGroupSync();


			if ((GGroupThreadId.x & 0x3F) == 0)
			{
				const uint Index = GGroupThreadId.x / 16;
				uint RetPrevIdx = 0;

				const uint ActiveCount1 = GroupSharedIndex16[Index];
				const uint ActiveCount2 = ActiveCount1 + GroupSharedIndex16[Index + 1];
#line 605 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
				GroupSharedIndex16[Index] = 0;
				GroupSharedIndex16[Index + 1] = ActiveCount1;






				InterlockedAdd(RWInstanceCounts[WriteInstanceCountOffset], ActiveCount2, RetPrevIdx);

				GroupSharedIndex64 = RetPrevIdx;
			}
			GroupMemoryBarrierWithGroupSync();

			PrevIdx = GroupSharedIndex64 + GroupSharedIndex16[GGroupThreadId.x / 16] + GroupSharedIndex4[GGroupThreadId.x / 4] + GroupSharedIndex[GGroupThreadId.x];
#line 634 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
		return PrevIdx;
	}
#line 641 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	float InputDataFloat(int DataSetIndex, int RegisterIdx, int InstanceIdx)
	{
		return InputFloat[RegisterIdx*ComponentBufferSizeRead + InstanceIdx];
	}

	int InputDataInt(int DataSetIndex, int RegisterIdx, int InstanceIdx)
	{
		return InputInt[RegisterIdx*ComponentBufferSizeRead + InstanceIdx];
	}

	bool InputDataBool(int DataSetIndex, int RegisterIdx, int InstanceIdx)
	{
		return InputInt[RegisterIdx*ComponentBufferSizeRead + InstanceIdx] == -1;
	}
#line 661 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	void OutputDataFloat(int DataSetIndex, int RegisterIndex, int InstanceIndex, float Value)
	{
		RWOutputFloat[RegisterIndex*ComponentBufferSizeWrite + InstanceIndex + UpdateStartInstance] = Value;
	}

	void OutputDataInt(int DataSetIndex, int RegisterIndex, int InstanceIndex, int Value)
	{
		RWOutputInt[RegisterIndex*ComponentBufferSizeWrite + InstanceIndex + UpdateStartInstance] = Value;
	}

	void OutputDataBool(int DataSetIndex, int RegisterIndex, int InstanceIndex, bool Value)
	{
		RWOutputInt[RegisterIndex*ComponentBufferSizeWrite + InstanceIndex + UpdateStartInstance] = Value ? -1 : 0;
	}

	void EnterStatScope(int ID) {}
	void ExitStatScope() {}
#line 683 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
	int OutputIndex(const int DataSetID, const bool bStageKillsParticles, const bool bIsValid)
	{
#line 698 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
			return AcquireIndex(DataSetID, bIsValid);
	}
#line 702 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"
#line 1 "/Engine/Generated/NiagaraEmitterInstance.ush"




struct NiagaraRandInfo
{
	int Seed1;
	int Seed2;
	int Seed3;
};

struct NiagaraID
{
	int Index;
	int AcquireTag;
};

struct MeshTriCoordinate
{
	int Tri;
	float3 BaryCoord;
};

cbuffer FNiagaraGlobalParameters
{
	float Engine_DeltaTime;
	float Engine_InverseDeltaTime;
	float Engine_Time;
	float Engine_RealTime;
}

cbuffer FNiagaraSystemParameters
{
	float Engine_Owner_TimeSinceRendered;
	float Engine_Owner_LODDistance;
	float Engine_Owner_LODDistanceFraction;
	float Engine_System_Age;
	int Engine_Owner_ExecutionState;
	int Engine_System_TickCount;
	int Engine_System_NumEmitters;
	int Engine_System_NumEmittersAlive;
}

cbuffer FNiagaraOwnerParameters
{
	float4x4 Engine_Owner_SystemLocalToWorld;
	float4x4 Engine_Owner_SystemWorldToLocal;
	float4x4 Engine_Owner_SystemLocalToWorldTransposed;
	float4x4 Engine_Owner_SystemWorldToLocalTransposed;
	float4x4 Engine_Owner_SystemLocalToWorldNoScale;
	float4x4 Engine_Owner_SystemWorldToLocalNoScale;
	float4 Engine_Owner_Rotation;
	float4 Engine_Owner_Position;
	float4 Engine_Owner_Velocity;
	float4 Engine_Owner_SystemXAxis;
	float4 Engine_Owner_SystemYAxis;
	float4 Engine_Owner_SystemZAxis;
	float4 Engine_Owner_Scale;
}

cbuffer FNiagaraEmitterParameters
{
	int Engine_Emitter_NumParticles;
	int Engine_Emitter_TotalSpawnedParticles;
	float Engine_Emitter_SpawnCountScale;
	float Emitter_Age;
	int Emitter_RandomSeed;
	int Engine_Emitter_PaddingInt32_0;
	int Engine_Emitter_PaddingInt32_1;
	int Engine_Emitter_PaddingInt32_2;
}

cbuffer FNiagaraExternalParameters
{
	float Constants_Emitter_UniformRangedFloat005_Minimum;
	float Constants_Emitter_UniformRangedFloat005_Maximum;
	int Constants_Emitter_UniformRangedFloat005_RandomSeed;
	float Constants_Emitter_UniformRangedFloat004_Minimum;
	float Constants_Emitter_UniformRangedFloat004_Maximum;
	int Constants_Emitter_UniformRangedFloat004_RandomSeed;
	float Constants_Emitter_UniformRangedFloat003_Minimum;
	float Constants_Emitter_UniformRangedFloat003_Maximum;
	int Constants_Emitter_UniformRangedFloat003_RandomSeed;
	float4 Constants_Emitter_InitializeParticle_Color;
	float4 Constants_Emitter_InitializeParticle_SpriteSize;
	float4 Constants_Emitter_InitializeParticle_MeshScale;
	int Constants_Emitter_SkeletalMeshLocation_RandomSeed;
	int Constants_Emitter_SkeletalMeshLocation_SampledUVIndex;
	int Constants_Emitter_SkeletalMeshLocation_SpawnGroupMask;
	float4 Constants_Emitter_SkeletalMeshLocation_SampledPositionOffset;
	float Constants_Emitter_SkeletalMeshLocation_OffsetPositionAlongSampledNormal;
	float Constants_Emitter_SkeletalMeshLocation_InheritVelocityASC40ScaleASC41;
	float Constants_Emitter_Color_ScaleAlpha;
	float Emitter_AlphaScale;
	float Constants_Emitter_Collision_ParticleRadiusScale;
	float Constants_Emitter_Collision_Friction;
	float Constants_Emitter_Collision_StaticFriction;
	float Constants_Emitter_Collision_StaticFrictionEngagementSpeed;
	float Constants_Emitter_Collision_Restitution;
	float Constants_Emitter_Collision_RandomizeCollisionNormal;
	float Constants_Emitter_Collision_FrictionDuringaBounce;
	float Constants_Emitter_Collision_Maximumtimeoffscreen;
	float Constants_Emitter_Collision_PercentageofPenetrationBeforeRest;
	float Constants_Emitter_Collision_RestStateTimeRange;
	float Constants_Emitter_Collision_MaximumPenetrationCorrectionDistance;
	float4 Constants_Emitter_Collision_ValidCollisionPlaneNormalForRest;
	float Constants_Emitter_Collision_MinimumCollisionNormalASC47RestNormalAlignmentPercentage;
	float Constants_Emitter_Collision_AdvancedAgingRate;
	float Constants_Emitter_SolveForcesAndVelocity_SpeedLimit;
	float Constants_Emitter_SolveForcesAndVelocity_AccelerationLimit;
	float Emitter_SpawnRate;
}

cbuffer PREV_FNiagaraGlobalParameters
{
	float PREV_Engine_DeltaTime;
	float PREV_Engine_InverseDeltaTime;
	float PREV_Engine_Time;
	float PREV_Engine_RealTime;
}

cbuffer PREV_FNiagaraSystemParameters
{
	float PREV_Engine_Owner_TimeSinceRendered;
	float PREV_Engine_Owner_LODDistance;
	float PREV_Engine_Owner_LODDistanceFraction;
	float PREV_Engine_System_Age;
	int PREV_Engine_Owner_ExecutionState;
	int PREV_Engine_System_TickCount;
	int PREV_Engine_System_NumEmitters;
	int PREV_Engine_System_NumEmittersAlive;
}

cbuffer PREV_FNiagaraOwnerParameters
{
	float4x4 PREV_Engine_Owner_SystemLocalToWorld;
	float4x4 PREV_Engine_Owner_SystemWorldToLocal;
	float4x4 PREV_Engine_Owner_SystemLocalToWorldTransposed;
	float4x4 PREV_Engine_Owner_SystemWorldToLocalTransposed;
	float4x4 PREV_Engine_Owner_SystemLocalToWorldNoScale;
	float4x4 PREV_Engine_Owner_SystemWorldToLocalNoScale;
	float4 PREV_Engine_Owner_Rotation;
	float4 PREV_Engine_Owner_Position;
	float4 PREV_Engine_Owner_Velocity;
	float4 PREV_Engine_Owner_SystemXAxis;
	float4 PREV_Engine_Owner_SystemYAxis;
	float4 PREV_Engine_Owner_SystemZAxis;
	float4 PREV_Engine_Owner_Scale;
}

cbuffer PREV_FNiagaraEmitterParameters
{
	int PREV_Engine_Emitter_NumParticles;
	int PREV_Engine_Emitter_TotalSpawnedParticles;
	float PREV_Engine_Emitter_SpawnCountScale;
	float PREV_Emitter_Age;
	int PREV_Emitter_RandomSeed;
	int PREV_Engine_Emitter_PaddingInt32_0;
	int PREV_Engine_Emitter_PaddingInt32_1;
	int PREV_Engine_Emitter_PaddingInt32_2;
}

cbuffer PREV_FNiagaraExternalParameters
{
	float PREV_Constants_Emitter_UniformRangedFloat005_Minimum;
	float PREV_Constants_Emitter_UniformRangedFloat005_Maximum;
	int PREV_Constants_Emitter_UniformRangedFloat005_RandomSeed;
	float PREV_Constants_Emitter_UniformRangedFloat004_Minimum;
	float PREV_Constants_Emitter_UniformRangedFloat004_Maximum;
	int PREV_Constants_Emitter_UniformRangedFloat004_RandomSeed;
	float PREV_Constants_Emitter_UniformRangedFloat003_Minimum;
	float PREV_Constants_Emitter_UniformRangedFloat003_Maximum;
	int PREV_Constants_Emitter_UniformRangedFloat003_RandomSeed;
	float4 PREV_Constants_Emitter_InitializeParticle_Color;
	float4 PREV_Constants_Emitter_InitializeParticle_SpriteSize;
	float4 PREV_Constants_Emitter_InitializeParticle_MeshScale;
	int PREV_Constants_Emitter_SkeletalMeshLocation_RandomSeed;
	int PREV_Constants_Emitter_SkeletalMeshLocation_SampledUVIndex;
	int PREV_Constants_Emitter_SkeletalMeshLocation_SpawnGroupMask;
	float4 PREV_Constants_Emitter_SkeletalMeshLocation_SampledPositionOffset;
	float PREV_Constants_Emitter_SkeletalMeshLocation_OffsetPositionAlongSampledNormal;
	float PREV_Constants_Emitter_SkeletalMeshLocation_InheritVelocityASC40ScaleASC41;
	float PREV_Constants_Emitter_Color_ScaleAlpha;
	float PREV_Emitter_AlphaScale;
	float PREV_Constants_Emitter_Collision_ParticleRadiusScale;
	float PREV_Constants_Emitter_Collision_Friction;
	float PREV_Constants_Emitter_Collision_StaticFriction;
	float PREV_Constants_Emitter_Collision_StaticFrictionEngagementSpeed;
	float PREV_Constants_Emitter_Collision_Restitution;
	float PREV_Constants_Emitter_Collision_RandomizeCollisionNormal;
	float PREV_Constants_Emitter_Collision_FrictionDuringaBounce;
	float PREV_Constants_Emitter_Collision_Maximumtimeoffscreen;
	float PREV_Constants_Emitter_Collision_PercentageofPenetrationBeforeRest;
	float PREV_Constants_Emitter_Collision_RestStateTimeRange;
	float PREV_Constants_Emitter_Collision_MaximumPenetrationCorrectionDistance;
	float4 PREV_Constants_Emitter_Collision_ValidCollisionPlaneNormalForRest;
	float PREV_Constants_Emitter_Collision_MinimumCollisionNormalASC47RestNormalAlignmentPercentage;
	float PREV_Constants_Emitter_Collision_AdvancedAgingRate;
	float PREV_Constants_Emitter_SolveForcesAndVelocity_SpeedLimit;
	float PREV_Constants_Emitter_SolveForcesAndVelocity_AccelerationLimit;
	float PREV_Emitter_SpawnRate;
}

struct FParamMap0_UpdateAge
{
	float DeltaTime;
	float Lifetime;
};

struct FParamMap0_UniformRangedFloat005
{
	bool FixedRandomSeed;
	float Maximum;
	float Minimum;
	bool OverrideRandomness;
	bool OverrideSeed;
	int RandomnessMode;
	int RandomSeed;
};

struct FParamMap0_UniformRangedFloat004
{
	bool FixedRandomSeed;
	float Maximum;
	float Minimum;
	bool OverrideRandomness;
	bool OverrideSeed;
	int RandomnessMode;
	int RandomSeed;
};

struct FParamMap0_UniformRangedFloat003
{
	bool FixedRandomSeed;
	float Maximum;
	float Minimum;
	bool OverrideRandomness;
	bool OverrideSeed;
	int RandomnessMode;
	int RandomSeed;
};

struct FParamMap0_Transient
{
	float CollisionDistanceToCollision;
	float CollisionFriction;
	bool CollisionIsResting;
	float3 CollisionNormal;
	float3 CollisionParticleRelativeCollisionLocation;
	float3 CollisionParticleWorldPosition;
	float CollisionRestitution;
	float CollisionSize;
	bool CollisionValid;
	float3 CollisionVelocity;
	float3 CollisionWorldPosition;
	float PhysicsDeltaTime;
	float PhysicsDrag;
	float3 PhysicsForce;
};

struct FParamMap0_SolveForcesAndVelocity
{
	float AccelerationLimit;
	float DeltaTime;
	float3 Force;
	float Mass;
	float3 Position;
	float3 PreviousVelocity;
	float SpeedLimit;
	float3 Velocity;
	bool WritetoIntrinsicProperties;
};

struct FParamMap0_SkeletalMeshLocation
{
	bool ApplyToParticlePosition;
	bool FixedRandomSeed;
	float InheritVelocityASC40ScaleASC41;
	float OffsetPositionAlongSampledNormal;
	bool OverrideRandomness;
	bool OverrideSeed;
	int RandomnessMode;
	int RandomSeed;
	float3 SampledPositionOffset;
	int SampledUVIndex;
	int SpawnGroupMask;
	bool UseSampledMeshAttributeasRibbonID;
};

struct FParamMap0_Particles_SkeletalMeshLocation
{
	bool FirstFrameBool;
};

struct FParamMap0_Particles_Collision_CollisionQueryAndResponse001
{
	int CollisionID;
};

struct FParamMap0_Particles_Collision_CollisionQueryAndResponse
{
	int CollisionID;
};

struct FParamMap0_Particles_Collision
{
	FParamMap0_Particles_Collision_CollisionQueryAndResponse CollisionQueryAndResponse;
	FParamMap0_Particles_Collision_CollisionQueryAndResponse001 CollisionQueryAndResponse001;
	float OffscreenCounter;
};

struct FParamMap0_Particles
{
	float Age;
	bool CheckOnScreen;
	float CheckScreenCounter;
	FParamMap0_Particles_Collision Collision;
	float4 Color;
	bool HasCollided;
	NiagaraRandInfo InitRandom;
	float Lifetime;
	float Mass;
	float MaterialRandom;
	float3 NewPosition_Skeletal;
	float NormalizedAge;
	int NumberOfCollisions;
	float3 Position;
	float3 PreviousVelocity;
	float RestCounter;
	NiagaraID RibbonID;
	float3 Scale;
	FParamMap0_Particles_SkeletalMeshLocation SkeletalMeshLocation;
	float SpriteRotation;
	float2 SpriteSize;
	int UniqueID;
	float3 Velocity;
};

struct FParamMap0_OUTPUT_VAR_UpdateAge
{
	bool FirstFrame;
};

struct FParamMap0_OUTPUT_VAR_SolveForcesAndVelocity
{
	float IncomingPhysicsDrag;
	float3 IncomingPhysicsForce;
	float3 Position;
	float3 Velocity;
};

struct FParamMap0_OUTPUT_VAR_SkeletalMeshLocation
{
	float3 SampledBitangent;
	float3 SampledNormal;
	float3 SampledPosition;
	float4 SampledRotation;
	float3 SampledTangent;
	MeshTriCoordinate SampledTriCoord;
	float2 SampledUV;
	float3 SampledVelocity;
	float4 SampledVertexColor;
};

struct FParamMap0_OUTPUT_VAR_SampleTexture
{
	float4 SampledColor;
};

struct FParamMap0_OUTPUT_VAR_ParticleState
{
	bool FirstFrame;
};

struct FParamMap0_OUTPUT_VAR_Collision_CollisionQueryAndResponse001
{
	float CollisionPenetrationDistance;
	bool DepthBasedCollisionParticleOccluded;
	bool ParticleOnScreen;
	bool PhysicsCollidesThisFrame;
};

struct FParamMap0_OUTPUT_VAR_Collision_CollisionQueryAndResponse
{
	float CollisionPenetrationDistance;
	bool DepthBasedCollisionParticleOccluded;
	bool ParticleOnScreen;
	bool PhysicsCollidesThisFrame;
};

struct FParamMap0_OUTPUT_VAR_Collision
{
	FParamMap0_OUTPUT_VAR_Collision_CollisionQueryAndResponse CollisionQueryAndResponse;
	FParamMap0_OUTPUT_VAR_Collision_CollisionQueryAndResponse001 CollisionQueryAndResponse001;
	bool CollisionValid;
	float3 ModuleCollision1Normal;
	bool ModuleCollision1Valid;
	float3 ModuleCollision2Normal;
	bool ModuleCollision2Valid;
	float3 ModuleCombinedCollisionNormal;
	float3 TempPreviousForce;
	float3 TempPreviousPosition;
	float3 TempPreviousVelocity;
};

struct FParamMap0_OUTPUT_VAR
{
	FParamMap0_OUTPUT_VAR_Collision Collision;
	FParamMap0_OUTPUT_VAR_ParticleState ParticleState;
	FParamMap0_OUTPUT_VAR_SampleTexture SampleTexture;
	FParamMap0_OUTPUT_VAR_SkeletalMeshLocation SkeletalMeshLocation;
	FParamMap0_OUTPUT_VAR_SolveForcesAndVelocity SolveForcesAndVelocity;
	FParamMap0_OUTPUT_VAR_UpdateAge UpdateAge;
};

struct FParamMap0_NormalizedAngleToDegrees001
{
	float NormalizedAngle;
};

struct FParamMap0_MakeVector3_FromColor001
{
	float4 Color;
};

struct FParamMap0_Local_SolveForcesAndVelocity
{
	float DeltaTime;
	float Mass;
	float3 PhysicsForce;
};

struct FParamMap0_Local_SkeletalMeshLocation
{
	NiagaraRandInfo RandomInfo;
	float3 SampledBitangent;
	int SampledBoneIndex;
	MeshTriCoordinate SampledMeshTriCoord;
	float2 SampledMeshUV;
	int SampledMeshVertexID;
	float3 SampledNormal;
	float3 SampledPosition;
	float4 SampledRotation;
	float3 SampledTangent;
	float3 SampledVelocity;
	float4 SampledVertexColor;
	bool SpawnGroupMaskBool;
	int SpawnGroupMaskValue;
};

struct FParamMap0_Local_Collision_CollisionQueryAndResponse001
{
	float3 ModuleAttemptedMovementThisUpdate;
	float3 ModuleForceContribution;
	float3 ModuleFrictionForceVectorInNewtons;
	float3 ModuleFrictionForceVelocityVector;
	bool ModuleInitialDataInstanceAlive;
	float3 ModuleInitialForceDividedByMass;
	float ModuleNormalForceInNewtons;
	float ModulePercentageOfTickDedicatedToUpdatingPosition;
	float ModulePhysicsDeltaTime;
	float3 ModulePlaneNormal;
	float3 ModulePlanePivotPoint;
	float3 ModuleReflectedVelocity;
	float3 ModuleReflectedVelocityWithFrictionApplied;
	bool ModuleRemoveRestitution;
	float3 ModuleReturnedCollisionNormal;
	bool ModuleReturnedCollisionValidBool;
	float3 ModuleReturnedCollisionWorldPosition;
	float ModuleReturnedFriction;
	float ModuleReturnedRestitution;
	float ModuleTickDeltaForThisCollisionUpdate;
	float3 ModuleTraceDirection;
	float3 ModuleTraceOrigin;
	float3 ModuleTraceVector;
	float3 ModuleTraceWorldEnd;
	float3 ModuleTraceWorldStart;
};

struct FParamMap0_Local_Collision_CollisionQueryAndResponse
{
	float3 ModuleAttemptedMovementThisUpdate;
	float3 ModuleForceContribution;
	float3 ModuleFrictionForceVectorInNewtons;
	float3 ModuleFrictionForceVelocityVector;
	bool ModuleInitialDataInstanceAlive;
	float3 ModuleInitialForceDividedByMass;
	float ModuleNormalForceInNewtons;
	float ModulePercentageOfTickDedicatedToUpdatingPosition;
	float ModulePhysicsDeltaTime;
	float3 ModulePlaneNormal;
	float3 ModulePlanePivotPoint;
	float3 ModuleReflectedVelocity;
	float3 ModuleReflectedVelocityWithFrictionApplied;
	bool ModuleRemoveRestitution;
	float3 ModuleReturnedCollisionNormal;
	bool ModuleReturnedCollisionValidBool;
	float3 ModuleReturnedCollisionWorldPosition;
	float ModuleReturnedFriction;
	float ModuleReturnedRestitution;
	float ModuleTickDeltaForThisCollisionUpdate;
	float3 ModuleTraceDirection;
	float3 ModuleTraceOrigin;
	float3 ModuleTraceVector;
	float3 ModuleTraceWorldEnd;
	float3 ModuleTraceWorldStart;
};

struct FParamMap0_Local_Collision
{
	FParamMap0_Local_Collision_CollisionQueryAndResponse CollisionQueryAndResponse;
	FParamMap0_Local_Collision_CollisionQueryAndResponse001 CollisionQueryAndResponse001;
	float ModuleParticleRadius;
	bool UpdateMeshRotation;
};

struct FParamMap0_Local
{
	FParamMap0_Local_Collision Collision;
	FParamMap0_Local_SkeletalMeshLocation SkeletalMeshLocation;
	FParamMap0_Local_SolveForcesAndVelocity SolveForcesAndVelocity;
};

struct FParamMap0_Interpolation
{
	float Emitter_InterpSpawnStartDt;
	int Emitter_SpawnGroup;
	float Emitter_SpawnInterval;
	int InterpSpawn_Index;
	float InterpSpawn_InvSpawnTime;
	float InterpSpawn_InvUpdateTime;
	float InterpSpawn_SpawnTime;
	float InterpSpawn_UpdateTime;
	float SpawnInterp;
};

struct FParamMap0_InitializeParticle
{
	float4 Color;
	float Lifetime;
	float Mass;
	float MaterialRandom;
	float3 MeshScale;
	float3 Position;
	float SpriteRotation;
	float2 SpriteSize;
	bool WriteColor;
	bool WriteLifetime;
	bool WriteMass;
	bool WriteMaterialRandom;
	bool WritePosition;
	bool WriteScale;
	bool WriteSpriteRotation;
	bool WriteSpriteSize;
};

struct FParamMap0_Engine_System
{
	float Age;
	int NumEmitters;
	int NumEmittersAlive;
	int TickCount;
};

struct FParamMap0_Engine_Owner
{
	int ExecutionState;
	float LODDistance;
	float LODDistanceFraction;
	float3 Position;
	float4 Rotation;
	float3 Scale;
	float4x4 SystemLocalToWorld;
	float4x4 SystemLocalToWorldNoScale;
	float4x4 SystemLocalToWorldTransposed;
	float4x4 SystemWorldToLocal;
	float4x4 SystemWorldToLocalNoScale;
	float4x4 SystemWorldToLocalTransposed;
	float3 SystemXAxis;
	float3 SystemYAxis;
	float3 SystemZAxis;
	float TimeSinceRendered;
	float3 Velocity;
};

struct FParamMap0_Engine_Emitter
{
	int NumParticles;
	int PaddingInt32_0;
	int PaddingInt32_1;
	int PaddingInt32_2;
	float SpawnCountScale;
	int TotalSpawnedParticles;
};

struct FParamMap0_Engine
{
	float DeltaTime;
	FParamMap0_Engine_Emitter Emitter;
	int ExecutionCount;
	float InverseDeltaTime;
	FParamMap0_Engine_Owner Owner;
	float RealTime;
	FParamMap0_Engine_System System;
	float Time;
};

struct FParamMap0_Emitter
{
	float Age;
	float AlphaScale;
	bool LocalSpace;
	int RandomSeed;
	int SpawnGroup;
	float SpawnRate;
};

struct FParamMap0_DataInstance
{
	bool Alive;
};

struct FParamMap0_Constants_Emitter_UniformRangedFloat005
{
	float Maximum;
	float Minimum;
	int RandomSeed;
};

struct FParamMap0_Constants_Emitter_UniformRangedFloat004
{
	float Maximum;
	float Minimum;
	int RandomSeed;
};

struct FParamMap0_Constants_Emitter_UniformRangedFloat003
{
	float Maximum;
	float Minimum;
	int RandomSeed;
};

struct FParamMap0_Constants_Emitter_SolveForcesAndVelocity
{
	float AccelerationLimit;
	float SpeedLimit;
};

struct FParamMap0_Constants_Emitter_SkeletalMeshLocation
{
	float InheritVelocityASC40ScaleASC41;
	float OffsetPositionAlongSampledNormal;
	int RandomSeed;
	float3 SampledPositionOffset;
	int SampledUVIndex;
	int SpawnGroupMask;
};

struct FParamMap0_Constants_Emitter_InitializeParticle
{
	float4 Color;
	float3 MeshScale;
	float2 SpriteSize;
};

struct FParamMap0_Constants_Emitter_Color
{
	float ScaleAlpha;
};

struct FParamMap0_Constants_Emitter_Collision
{
	float AdvancedAgingRate;
	float Friction;
	float FrictionDuringaBounce;
	float MaximumPenetrationCorrectionDistance;
	float Maximumtimeoffscreen;
	float MinimumCollisionNormalASC47RestNormalAlignmentPercentage;
	float ParticleRadiusScale;
	float PercentageofPenetrationBeforeRest;
	float RandomizeCollisionNormal;
	float Restitution;
	float RestStateTimeRange;
	float StaticFriction;
	float StaticFrictionEngagementSpeed;
	float3 ValidCollisionPlaneNormalForRest;
};

struct FParamMap0_Constants_Emitter
{
	FParamMap0_Constants_Emitter_Collision Collision;
	FParamMap0_Constants_Emitter_Color Color;
	FParamMap0_Constants_Emitter_InitializeParticle InitializeParticle;
	FParamMap0_Constants_Emitter_SkeletalMeshLocation SkeletalMeshLocation;
	FParamMap0_Constants_Emitter_SolveForcesAndVelocity SolveForcesAndVelocity;
	FParamMap0_Constants_Emitter_UniformRangedFloat003 UniformRangedFloat003;
	FParamMap0_Constants_Emitter_UniformRangedFloat004 UniformRangedFloat004;
	FParamMap0_Constants_Emitter_UniformRangedFloat005 UniformRangedFloat005;
};

struct FParamMap0_Constants
{
	FParamMap0_Constants_Emitter Emitter;
};

struct FParamMap0_ColorFromCurve
{
	float CurveIndex;
};

struct FParamMap0_Color
{
	float4 Color;
	float ScaleAlpha;
	float3 ScaleColor;
};

struct FParamMap0_Collision_CollisionQueryAndResponse001
{
	bool AllowOffscreenDepthBufferParticlesToLive;
	float BounceCollisionFriction;
	bool CollisionEnabled;
	float CollisionNormalRandomizationPercentage;
	int CPUFrictionMergeType;
	float DeltaTime;
	float DepthBufferBackfaceThickness;
	float DynamicFrictionCoefficient;
	bool KillOccludedParticles;
	float MaxIntersectionCorrectionDistance;
	float MaxTraceLength;
	float ParticleRadius;
	float ParticleRestitutionCoeffiecient;
	bool RandomizeCollisionNormal;
	float StaticFrictionCoefficient;
	float StaticFrictionEngagementSpeed;
	float TraceVectorLengthMultiplier;
	bool UpdateRotationalVelocity;
};

struct FParamMap0_Collision_CollisionQueryAndResponse
{
	bool AllowOffscreenDepthBufferParticlesToLive;
	float BounceCollisionFriction;
	bool CollisionEnabled;
	float CollisionNormalRandomizationPercentage;
	int CPUFrictionMergeType;
	float DeltaTime;
	float DepthBufferBackfaceThickness;
	float DynamicFrictionCoefficient;
	bool KillOccludedParticles;
	float MaxIntersectionCorrectionDistance;
	float MaxTraceLength;
	float ParticleRadius;
	float ParticleRestitutionCoeffiecient;
	bool RandomizeCollisionNormal;
	float StaticFrictionCoefficient;
	float StaticFrictionEngagementSpeed;
	float TraceVectorLengthMultiplier;
	bool UpdateRotationalVelocity;
};

struct FParamMap0_Collision
{
	float AdvancedAgingRate;
	bool AllowOffscreenDepthBufferCollisionParticlesToLiveAfteraBounce;
	bool CollisionEnabled;
	FParamMap0_Collision_CollisionQueryAndResponse CollisionQueryAndResponse;
	FParamMap0_Collision_CollisionQueryAndResponse001 CollisionQueryAndResponse001;
	bool ControlRestStateViaSurfaceNormal;
	bool CorrectInterpenetration;
	bool EnableRestState;
	float Friction;
	float FrictionDuringaBounce;
	bool KillOccludedParticles;
	float MaximumPenetrationCorrectionDistance;
	float Maximumtimeoffscreen;
	float MinimumCollisionNormalASC47RestNormalAlignmentPercentage;
	float ParticleRadiusScale;
	float PercentageofPenetrationBeforeRest;
	float RandomizeCollisionNormal;
	bool RandomizeCollisionNormalVector;
	float Restitution;
	float RestStateTimeRange;
	float StaticFriction;
	float StaticFrictionEngagementSpeed;
	float3 ValidCollisionPlaneNormalForRest;
};

struct FParamMap0
{
	FParamMap0_Collision Collision;
	FParamMap0_Color Color;
	FParamMap0_ColorFromCurve ColorFromCurve;
	FParamMap0_Constants Constants;
	FParamMap0_DataInstance DataInstance;
	FParamMap0_Emitter Emitter;
	FParamMap0_Engine Engine;
	FParamMap0_InitializeParticle InitializeParticle;
	FParamMap0_Interpolation Interpolation;
	FParamMap0_Local Local;
	FParamMap0_MakeVector3_FromColor001 MakeVector3_FromColor001;
	FParamMap0_NormalizedAngleToDegrees001 NormalizedAngleToDegrees001;
	FParamMap0_OUTPUT_VAR OUTPUT_VAR;
	FParamMap0_Particles Particles;
	FParamMap0_SkeletalMeshLocation SkeletalMeshLocation;
	FParamMap0_SolveForcesAndVelocity SolveForcesAndVelocity;
	FParamMap0_Transient Transient;
	FParamMap0_UniformRangedFloat003 UniformRangedFloat003;
	FParamMap0_UniformRangedFloat004 UniformRangedFloat004;
	FParamMap0_UniformRangedFloat005 UniformRangedFloat005;
	FParamMap0_UpdateAge UpdateAge;
};

struct FSimulationContext
{
	FParamMap0 MapSpawn;
	FParamMap0 MapUpdate;
};

static float HackSpawnInterp = 1.0;
void GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(int In_Seed, int In_Engine_System_TickCount, bool In_OverrideSeed, int In_Particles_UniqueID, int In_Emitter_RandomSeed, bool In_FixedOverrideSeed, int In_RandomnessMode, out NiagaraRandInfo Out_RandomInfo, out bool Out_UseDeterministicRandoms, inout FSimulationContext Context);
void RandomRangeFloat_Func_(float In_Min, float In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, bool In_FixedOverrideSeed, out float Out_Result, inout FSimulationContext Context);
void UniformRangedFloat005_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context);
void UniformRangedFloat004_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context);
void NormalizedAngleToDegrees001_Emitter_Func_(out float Out_NewOutput, inout FSimulationContext Context);
void ParticleOwnerPosition_Emitter_Func_(out float3 Out_OutPosition, inout FSimulationContext Context);
void UniformRangedFloat003_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context);
void InitializeParticle_SimulationPosition_Emitter_Func_(out float3 Out_OutPosition, inout FSimulationContext Context);
void RandomRangeFloat_Func_(float In_Min, float In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, out float Out_Result, inout FSimulationContext Context);
void InitializeParticle_Emitter_Func_(inout FSimulationContext Context);
void UpdateAge_Emitter_Func_(inout FSimulationContext Context);
void RandomTriangle_EmitterSkeletalMesh(NiagaraRandInfo In_RandomInfo, out MeshTriCoordinate Out_Coord);
void GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMesh(MeshTriCoordinate In_Coord, float In_Interp, out float3 Out_Position, out float3 Out_Velocity, out float3 Out_Normal, out float3 Out_Binormal, out float3 Out_Tangent);
void GetTriUV_EmitterSkeletalMesh(MeshTriCoordinate In_Coord, int In_UVSet, out float2 Out_UV);
void GetTriColor_EmitterSkeletalMesh(MeshTriCoordinate In_Coord, out float4 Out_Color);
void FastMatrixToQuaternion_FastPathLibrary(float4x4 In_Mat, out float4 Out_Quat);
void MatrixToQuaternion_Func_(float4x4 In_NewInput, out float4 Out_Quat, inout FSimulationContext Context);
void MakeQuaternionFrom3BasisVectors_Func_(float3 In_XVector, float3 In_YVector, float3 In_ZVector, out float4 Out_Quat, inout FSimulationContext Context);
void SkeletalMeshLocation_Emitter_Func_(inout FSimulationContext Context);
void GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(int In_Seed, int In_Engine_System_TickCount, bool In_OverrideSeed, int In_Particles_UniqueID, int In_Emitter_RandomSeed, int In_RandomnessMode, out NiagaraRandInfo Out_RandomInfo, out bool Out_UseDeterministicRandoms, inout FSimulationContext Context);
void RandomTriCoord_ParticlesSkeletalMesh(NiagaraRandInfo In_RandomInfo, out MeshTriCoordinate Out_Coord);
void GetSkinnedTriangleDataWS_ParticlesSkeletalMesh(MeshTriCoordinate In_Coord, out float3 Out_Position, out float3 Out_Velocity, out float3 Out_Normal, out float3 Out_Binormal, out float3 Out_Tangent);
void TransformBase_Func_(int In_SourceSpace, int In_DestinationSpace, float4x4 In_LocalToWorldTransform, float4x4 In_WorldToLocalTransform, bool In_bLocalSpace, out bool Out_bUseOriginal, out float4x4 Out_OutTransform, inout FSimulationContext Context);
void SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context);
void SelectV3Channel_Func_(float3 In_VECTOR_VAR, int In_TargetChannel, out float Out_Float, inout FSimulationContext Context);
void SmoothLerpOverTime_Func_(float In_SmoothValue, float In_TargetValue, float In_ConvergenceRate, float In_DeltaTime, out float Out_NewSmoothValue, inout FSimulationContext Context);
void SampleMeshScript_Skeletal_Emitter_Func_(inout FSimulationContext Context);
void SampleColorCurve_EmitterColorColorCurve(float In_X, out float4 Out_Value);
void ColorFromCurve_Emitter_Func_(out float4 Out_Value, inout FSimulationContext Context);
void MakeVector3_FromColor001_Emitter_Func_(out float3 Out_Vector, inout FSimulationContext Context);
void Color_Emitter_Func_(inout FSimulationContext Context);
void CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_(float2 In_SpriteSize, out float Out_Radius, inout FSimulationContext Context);
void Collision_TransformPosition_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context);
void Collision_TransformVector002_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context);
void Collision_TransformVector003_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context);
void DirectionAndLengthSafe_Func_(float3 In_V, float3 In_Fallback, float In_Threshold, float In_FallbackLength, out float3 Out_Direction, out float Out_Length, out bool Out_BelowThreshold, inout FSimulationContext Context);
void QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQuery(float3 In_DepthSamplePosWorld, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_SamplePosWorld, out float3 Out_SampleWorldNormal);
void Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_(float In_CollisionBackfaceThickness, float3 In_ParticlePosition, float In_ParticleRadius, float3 In_StartTrace, float3 In_EndTrace, bool In_KillOccludedParticles, out float3 Out_ImpactPosition, out float3 Out_ImpactNormal, out bool Out_Occluded, out bool Out_Collides, out bool Out_Onscreentest, out bool Out_KillBecauseofOcclusion, inout FSimulationContext Context);
void PlaneSphereCollisionDetection_Func_(float3 In_PlaneNormal, float3 In_PlanePivotPoint, float3 In_InitialSphereLocation, float3 In_SpherePositionDelta, float In_CollisionRadius, float In_PhysicsDeltaTime, float In_MaxCorrectiondistance, out bool Out_Collides, out float3 Out_IntersectionLocation, out float3 Out_PreASC45IntersectionSphereCenterLocation, out float3 Out_InitialPositionRelativeCollisionLocation, out float Out_TimeElapsedToCollision, out float Out_RemainingTimePostCollision, out float Out_PercentageofTimeUsedToPerformCollision, out float Out_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision, out float Out_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane, inout FSimulationContext Context);
void RandomRangeFloat_Func_(float2 In_Min, float2 In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, out float2 Out_Result, inout FSimulationContext Context);
void CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_(bool In_InputsAreNormalized, float3 In_From, float3 In_To, out float4 Out_Result);
void FindQuatBetween_Func_(float3 In_From, float3 In_To, bool In_InputsAreNormalized, out float4 Out_NewOutput, inout FSimulationContext Context);
void MultiplyVectorWithQuaternion_Func_(float3 In_VECTOR_VAR, float4 In_Quaternion, out float3 Out_Vector, inout FSimulationContext Context);
void RandomizeCollisionNormals_Func_(float3 In_ConeAxis, float In_Scale, float In_Spread, out float3 Out_Ouput, inout FSimulationContext Context);
void ReflectVector_Func_(float3 In_InVector, float3 In_Normal, out float3 Out_Reflected, inout FSimulationContext Context);
void CentimeterMeterConversion_Func_(float3 In_INPUT_VAR, out float3 Out_CentimeterstoMeters, out float3 Out_MeterstoCentimeters, inout FSimulationContext Context);
void ProjectVectorOnPlane_Func_(float3 In_VECTOR_VAR, float3 In_Normal, out float3 Out_Ouput, inout FSimulationContext Context);
void Collision_CollisionQueryAndResponse_Emitter_Func_(inout FSimulationContext Context);
void QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001Query(float3 In_DepthSamplePosWorld, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_SamplePosWorld, out float3 Out_SampleWorldNormal);
void Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_(float In_CollisionBackfaceThickness, float3 In_ParticlePosition, float In_ParticleRadius, float3 In_StartTrace, float3 In_EndTrace, bool In_KillOccludedParticles, out float3 Out_ImpactPosition, out float3 Out_ImpactNormal, out bool Out_Occluded, out bool Out_Collides, out bool Out_Onscreentest, out bool Out_KillBecauseofOcclusion, inout FSimulationContext Context);
void Collision_CollisionQueryAndResponse001_Emitter_Func_(inout FSimulationContext Context);
void Collision_TransformPosition001_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context);
void Collision_TransformVector001_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context);
void Collision_TransformVector_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context);
void Collision_Emitter_Func_(inout FSimulationContext Context);
void SolveForcesAndVelocity_Emitter_Func_(inout FSimulationContext Context);
float GetSpawnInterpolation();
void GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(int In_Seed, int In_Engine_System_TickCount, bool In_OverrideSeed, int In_Particles_UniqueID, int In_Emitter_RandomSeed, bool In_FixedOverrideSeed, int In_RandomnessMode, out NiagaraRandInfo Out_RandomInfo, out bool Out_UseDeterministicRandoms, inout FSimulationContext Context)
{
	bool Constant32 = false;
	int Constant33 = 0;
	bool Result = NiagaraAll(In_RandomnessMode == Constant33);
	bool Result1 = Constant32 && Result;
	int Constant34 = 1;
	bool Result2 = NiagaraAll(In_RandomnessMode == Constant34);
	bool Result3 = Result1 || Result2;
	int Seed_IfResult;
	if(In_OverrideSeed)
	{
	Seed_IfResult = In_Seed;
	}
	else
	{
	Seed_IfResult = Context.MapSpawn.Emitter.RandomSeed;
	}
	int Constant35 = 0;
	int Constant36 = 0;
	int Seed1_IfResult;
	int Seed2_IfResult;
	int Seed3_IfResult;
	if(In_FixedOverrideSeed)
	{
	Seed1_IfResult = Seed_IfResult;
	Seed2_IfResult = Constant35;
	Seed3_IfResult = Constant36;
	}
	else
	{
	Seed1_IfResult = Context.MapSpawn.Particles.UniqueID;
	Seed2_IfResult = Context.MapSpawn.Engine.System.TickCount;
	Seed3_IfResult = Seed_IfResult;
	}
	int Constant37 = -1;
	int Constant38 = -1;
	int Constant39 = -1;
	int Seed1_IfResult1;
	int Seed2_IfResult1;
	int Seed3_IfResult1;
	if(Result3)
	{
	Seed1_IfResult1 = Seed1_IfResult;
	Seed2_IfResult1 = Seed2_IfResult;
	Seed3_IfResult1 = Seed3_IfResult;
	}
	else
	{
	Seed1_IfResult1 = Constant37;
	Seed2_IfResult1 = Constant38;
	Seed3_IfResult1 = Constant39;
	}
	NiagaraRandInfo Output1;
	Output1.Seed1 = Seed1_IfResult1;
	Output1.Seed2 = Seed2_IfResult1;
	Output1.Seed3 = Seed3_IfResult1;
	Out_RandomInfo = Output1;
	Out_UseDeterministicRandoms = Result3;
}

void RandomRangeFloat_Func_(float In_Min, float In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, bool In_FixedOverrideSeed, out float Out_Result, inout FSimulationContext Context)
{
	int Constant28 = (0);
	bool Constant29 = false;
	int Constant30 = 0;
	int Constant31 = (0);
	NiagaraRandInfo GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo;
	bool GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms;
	GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(In_Seed, Constant28, In_OverrideSeed, Constant30, Constant31, In_FixedOverrideSeed, In_RandomnessMode, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms, Context);
	float Result4 = In_Max - In_Min;
	int Seed1;
	int Seed2;
	int Seed3;
	Seed1 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo.Seed1;
	Seed2 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo.Seed2;
	Seed3 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo.Seed3;
	float Result5 = rand_float(Result4, Seed1, Seed2, Seed3);
	float Result6 = rand_float(Result4);
	float Random_IfResult;
	if(GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms)
	{
	Random_IfResult = Result5;
	}
	else
	{
	Random_IfResult = Result6;
	}
	float Result7 = In_Min + Random_IfResult;
	Out_Result = Result7;
}

void UniformRangedFloat005_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context)
{
	int Constant26 = 0;
	bool Constant27 = false;
	int Mode_IfResult;
	bool Override_IfResult;
	if(Context.MapSpawn.UniformRangedFloat005.OverrideRandomness)
	{
	Mode_IfResult = Context.MapSpawn.UniformRangedFloat005.RandomnessMode;
	Override_IfResult = Context.MapSpawn.UniformRangedFloat005.OverrideSeed;
	}
	else
	{
	Mode_IfResult = Constant26;
	Override_IfResult = Constant27;
	}
	float RandomRangeFloat_Func_Output_Result;
	RandomRangeFloat_Func_(Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.Minimum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.Maximum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.RandomSeed, Mode_IfResult, Override_IfResult, Context.MapSpawn.UniformRangedFloat005.FixedRandomSeed, RandomRangeFloat_Func_Output_Result, Context);
	Out_UniformRangedFloat = RandomRangeFloat_Func_Output_Result;
}

void UniformRangedFloat004_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context)
{
	int Constant44 = 0;
	bool Constant45 = false;
	int Mode_IfResult1;
	bool Override_IfResult1;
	if(Context.MapSpawn.UniformRangedFloat004.OverrideRandomness)
	{
	Mode_IfResult1 = Context.MapSpawn.UniformRangedFloat004.RandomnessMode;
	Override_IfResult1 = Context.MapSpawn.UniformRangedFloat004.OverrideSeed;
	}
	else
	{
	Mode_IfResult1 = Constant44;
	Override_IfResult1 = Constant45;
	}
	float RandomRangeFloat_Func_Output_Result1;
	RandomRangeFloat_Func_(Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.Minimum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.Maximum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.RandomSeed, Mode_IfResult1, Override_IfResult1, Context.MapSpawn.UniformRangedFloat004.FixedRandomSeed, RandomRangeFloat_Func_Output_Result1, Context);
	Out_UniformRangedFloat = RandomRangeFloat_Func_Output_Result1;
}

void NormalizedAngleToDegrees001_Emitter_Func_(out float Out_NewOutput, inout FSimulationContext Context)
{
	float Constant48 = 360;
	float Result8 = Context.MapSpawn.NormalizedAngleToDegrees001.NormalizedAngle * Constant48;
	Out_NewOutput = Result8;
}

void ParticleOwnerPosition_Emitter_Func_(out float3 Out_OutPosition, inout FSimulationContext Context)
{
	bool Constant51 = false;
	float3 Constant52 = float3(0,0,0);
	float3 Vector_IfResult;
	if(Constant51)
	{
	Vector_IfResult = Constant52;
	}
	else
	{
	Vector_IfResult = Context.MapSpawn.Engine.Owner.Position;
	}
	Out_OutPosition = Vector_IfResult;
}

void UniformRangedFloat003_Emitter_Func_(out float Out_UniformRangedFloat, inout FSimulationContext Context)
{
	int Constant59 = 0;
	bool Constant60 = false;
	int Mode_IfResult2;
	bool Override_IfResult2;
	if(Context.MapSpawn.UniformRangedFloat003.OverrideRandomness)
	{
	Mode_IfResult2 = Context.MapSpawn.UniformRangedFloat003.RandomnessMode;
	Override_IfResult2 = Context.MapSpawn.UniformRangedFloat003.OverrideSeed;
	}
	else
	{
	Mode_IfResult2 = Constant59;
	Override_IfResult2 = Constant60;
	}
	float RandomRangeFloat_Func_Output_Result2;
	RandomRangeFloat_Func_(Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.Minimum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.Maximum, Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.RandomSeed, Mode_IfResult2, Override_IfResult2, Context.MapSpawn.UniformRangedFloat003.FixedRandomSeed, RandomRangeFloat_Func_Output_Result2, Context);
	Out_UniformRangedFloat = RandomRangeFloat_Func_Output_Result2;
}

void InitializeParticle_SimulationPosition_Emitter_Func_(out float3 Out_OutPosition, inout FSimulationContext Context)
{
	bool Constant63 = false;
	float3 Constant64 = float3(0,0,0);
	float3 Vector_IfResult1;
	if(Constant63)
	{
	Vector_IfResult1 = Constant64;
	}
	else
	{
	Vector_IfResult1 = Context.MapSpawn.Engine.Owner.Position;
	}
	Out_OutPosition = Vector_IfResult1;
}

void RandomRangeFloat_Func_(float In_Min, float In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, out float Out_Result, inout FSimulationContext Context)
{
	int Constant71 = (0);
	bool Constant72 = false;
	int Constant73 = 0;
	int Constant74 = (0);
	bool Constant75 = false;
	NiagaraRandInfo GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo1;
	bool GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms1;
	GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(In_Seed, Constant71, In_OverrideSeed, Constant73, Constant74, Constant75, In_RandomnessMode, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo1, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms1, Context);
	float Result9 = In_Max - In_Min;
	int Seed11;
	int Seed21;
	int Seed31;
	Seed11 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo1.Seed1;
	Seed21 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo1.Seed2;
	Seed31 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo1.Seed3;
	float Result10 = rand_float(Result9, Seed11, Seed21, Seed31);
	float Result11 = rand_float(Result9);
	float Random_IfResult1;
	if(GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms1)
	{
	Random_IfResult1 = Result10;
	}
	else
	{
	Random_IfResult1 = Result11;
	}
	float Result12 = In_Min + Random_IfResult1;
	Out_Result = Result12;
}

void InitializeParticle_Emitter_Func_(inout FSimulationContext Context)
{
	float Lifetime_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteLifetime)
	{
	Lifetime_IfResult = Context.MapSpawn.InitializeParticle.Lifetime;
	}
	else
	{
	Lifetime_IfResult = Context.MapSpawn.Particles.Lifetime;
	}
	Context.MapSpawn.Particles.Lifetime = Lifetime_IfResult;
	float4 Color_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteColor)
	{
	Color_IfResult = Context.MapSpawn.Constants.Emitter.InitializeParticle.Color;
	}
	else
	{
	Color_IfResult = Context.MapSpawn.Particles.Color;
	}
	Context.MapSpawn.Particles.Color = Color_IfResult;
	float Mass_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteMass)
	{
	Mass_IfResult = Context.MapSpawn.InitializeParticle.Mass;
	}
	else
	{
	Mass_IfResult = Context.MapSpawn.Particles.Mass;
	}
	Context.MapSpawn.Particles.Mass = Mass_IfResult;
	float2 SpriteSize_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteSpriteSize)
	{
	SpriteSize_IfResult = Context.MapSpawn.Constants.Emitter.InitializeParticle.SpriteSize;
	}
	else
	{
	SpriteSize_IfResult = Context.MapSpawn.Particles.SpriteSize;
	}
	Context.MapSpawn.Particles.SpriteSize = SpriteSize_IfResult;
	float SpriteRotation_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteSpriteRotation)
	{
	SpriteRotation_IfResult = Context.MapSpawn.InitializeParticle.SpriteRotation;
	}
	else
	{
	SpriteRotation_IfResult = Context.MapSpawn.Particles.SpriteRotation;
	}
	Context.MapSpawn.Particles.SpriteRotation = SpriteRotation_IfResult;
	float3 Scale_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteScale)
	{
	Scale_IfResult = Context.MapSpawn.Constants.Emitter.InitializeParticle.MeshScale;
	}
	else
	{
	Scale_IfResult = Context.MapSpawn.Particles.Scale;
	}
	Context.MapSpawn.Particles.Scale = Scale_IfResult;
	float3 Scale_IfResult1;
	if(Context.MapSpawn.InitializeParticle.WritePosition)
	{
	Scale_IfResult1 = Context.MapSpawn.InitializeParticle.Position;
	}
	else
	{
	Scale_IfResult1 = Context.MapSpawn.Particles.Position;
	}
	Context.MapSpawn.Particles.Position = Scale_IfResult1;
	float MaterialRandom_IfResult;
	if(Context.MapSpawn.InitializeParticle.WriteMaterialRandom)
	{
	MaterialRandom_IfResult = Context.MapSpawn.InitializeParticle.MaterialRandom;
	}
	else
	{
	MaterialRandom_IfResult = Context.MapSpawn.Particles.MaterialRandom;
	}
	Context.MapSpawn.Particles.MaterialRandom = MaterialRandom_IfResult;
}

void UpdateAge_Emitter_Func_(inout FSimulationContext Context)
{
	bool Result13 = NiagaraAll(Context.MapUpdate.Particles.Age <= Context.MapUpdate.Engine.DeltaTime);
	Context.MapUpdate.OUTPUT_VAR.UpdateAge.FirstFrame = Result13;
	float Result14 = Context.MapUpdate.Particles.Age + Context.MapUpdate.UpdateAge.DeltaTime;
	float Constant77 = 1e-05;
	float Result15 = max(Context.MapUpdate.UpdateAge.Lifetime, Constant77);
	float Constant78 = 0.0001;
	float Result16 = Result15 - Constant78;
	bool Result17 = NiagaraAll(Result14 < Result16);
	bool Constant79 = false;
	bool bool_IfResult;
	if(Result17)
	{
	bool_IfResult = Context.MapUpdate.DataInstance.Alive;
	}
	else
	{
	bool_IfResult = Constant79;
	}
	float Result18 = Result14 / Result15;
	Context.MapUpdate.DataInstance.Alive = bool_IfResult;
	Context.MapUpdate.Particles.Age = Result14;
	Context.MapUpdate.Particles.NormalizedAge = Result18;
}

void MatrixToQuaternion_Func_(float4x4 In_NewInput, out float4 Out_Quat, inout FSimulationContext Context)
{
	float4 FastMatrixToQuaternion_FastPathLibraryOutput_Quat;
	FastMatrixToQuaternion_FastPathLibrary(In_NewInput, FastMatrixToQuaternion_FastPathLibraryOutput_Quat);
	Out_Quat = FastMatrixToQuaternion_FastPathLibraryOutput_Quat;
}

void MakeQuaternionFrom3BasisVectors_Func_(float3 In_XVector, float3 In_YVector, float3 In_ZVector, out float4 Out_Quat, inout FSimulationContext Context)
{
	float Constant106 = 0;
	float4 Output11;
	Output11.x = In_XVector.x;
	Output11.y = In_XVector.y;
	Output11.z = In_XVector.z;
	Output11.w = Constant106;
	float Constant107 = 0;
	float4 Output12;
	Output12.x = In_YVector.x;
	Output12.y = In_YVector.y;
	Output12.z = In_YVector.z;
	Output12.w = Constant107;
	float Constant108 = 0;
	float4 Output13;
	Output13.x = In_ZVector.x;
	Output13.y = In_ZVector.y;
	Output13.z = In_ZVector.z;
	Output13.w = Constant108;
	float4 Constant109 = float4(0,0,0,0);
	float4x4 Output14;
	Output14[0] = Output11;
	Output14[1] = Output12;
	Output14[2] = Output13;
	Output14[3] = Constant109;
	float4 MatrixToQuaternion_Func_Output_Quat;
	MatrixToQuaternion_Func_(Output14, MatrixToQuaternion_Func_Output_Quat, Context);
	Out_Quat = MatrixToQuaternion_Func_Output_Quat;
}

void SkeletalMeshLocation_Emitter_Func_(inout FSimulationContext Context)
{
	int Constant98 = (0);
	bool Constant99 = false;
	int Constant100 = 0;
	bool Constant101 = false;
	int Mode_IfResult3;
	bool Override_IfResult3;
	if(Context.MapUpdate.SkeletalMeshLocation.OverrideRandomness)
	{
	Mode_IfResult3 = Context.MapUpdate.SkeletalMeshLocation.RandomnessMode;
	Override_IfResult3 = Context.MapUpdate.SkeletalMeshLocation.OverrideSeed;
	}
	else
	{
	Mode_IfResult3 = Constant100;
	Override_IfResult3 = Constant101;
	}
	int Constant102 = 0;
	int Constant103 = (0);
	NiagaraRandInfo GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo2;
	bool GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms2;
	GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.RandomSeed, Constant98, Override_IfResult3, Constant102, Constant103, Context.MapUpdate.SkeletalMeshLocation.FixedRandomSeed, Mode_IfResult3, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo2, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms2, Context);
	Context.MapUpdate.Local.SkeletalMeshLocation.RandomInfo = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo2;
	bool Constant104 = true;
	bool Constant105 = true;
	NiagaraRandInfo NiagaraRandInfo_IfResult;
	bool bool_IfResult1;
	if(Context.MapUpdate.Particles.SkeletalMeshLocation.FirstFrameBool)
	{
	NiagaraRandInfo_IfResult = Context.MapUpdate.Particles.InitRandom;
	bool_IfResult1 = Constant104;
	}
	else
	{
	NiagaraRandInfo_IfResult = Context.MapUpdate.Local.SkeletalMeshLocation.RandomInfo;
	bool_IfResult1 = Constant105;
	}
	Context.MapUpdate.Local.SkeletalMeshLocation.RandomInfo = NiagaraRandInfo_IfResult;
	Context.MapUpdate.Particles.SkeletalMeshLocation.FirstFrameBool = bool_IfResult1;
	Context.MapUpdate.Particles.InitRandom = NiagaraRandInfo_IfResult;
	MeshTriCoordinate RandomTriangle_EmitterSkeletalMeshOutput_Coord;
	RandomTriangle_EmitterSkeletalMesh(Context.MapUpdate.Local.SkeletalMeshLocation.RandomInfo, RandomTriangle_EmitterSkeletalMeshOutput_Coord);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord = RandomTriangle_EmitterSkeletalMeshOutput_Coord;
	float Result19 = GetSpawnInterpolation();
	float3 GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Position;
	float3 GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Velocity;
	float3 GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Normal;
	float3 GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Binormal;
	float3 GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Tangent;
	GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMesh(Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord, Result19, GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Position, GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Velocity, GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Normal, GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Binormal, GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Tangent);
	float2 GetTriUV_EmitterSkeletalMeshOutput_UV;
	GetTriUV_EmitterSkeletalMesh(Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord, Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SampledUVIndex, GetTriUV_EmitterSkeletalMeshOutput_UV);
	float4 GetTriColor_EmitterSkeletalMeshOutput_Color;
	GetTriColor_EmitterSkeletalMesh(Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord, GetTriColor_EmitterSkeletalMeshOutput_Color);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledPosition = GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Position;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledVelocity = GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Velocity;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledNormal = GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Normal;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledBitangent = GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Binormal;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledTangent = GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMeshOutput_Tangent;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshUV = GetTriUV_EmitterSkeletalMeshOutput_UV;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledVertexColor = GetTriColor_EmitterSkeletalMeshOutput_Color;
	float4 MakeQuaternionFrom3BasisVectors_Func_Output_Quat;
	MakeQuaternionFrom3BasisVectors_Func_(Context.MapUpdate.Local.SkeletalMeshLocation.SampledNormal, Context.MapUpdate.Local.SkeletalMeshLocation.SampledTangent, Context.MapUpdate.Local.SkeletalMeshLocation.SampledBitangent, MakeQuaternionFrom3BasisVectors_Func_Output_Quat, Context);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledRotation = MakeQuaternionFrom3BasisVectors_Func_Output_Quat;
	bool Constant110 = true;
	Context.MapUpdate.Local.SkeletalMeshLocation.SpawnGroupMaskValue = Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SpawnGroupMask;
	Context.MapUpdate.Local.SkeletalMeshLocation.SpawnGroupMaskBool = Constant110;
	float3 Result20 = Context.MapUpdate.Local.SkeletalMeshLocation.SampledPosition + Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SampledPositionOffset;
	float Constant111 = 0;
	float Result21 = Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.OffsetPositionAlongSampledNormal * Constant111;
	float3 Result22 = Result20 + Result21;
	float3 Position_IfResult;
	if(Context.MapUpdate.SkeletalMeshLocation.ApplyToParticlePosition)
	{
	Position_IfResult = Result22;
	}
	else
	{
	Position_IfResult = Context.MapUpdate.Particles.Position;
	}
	Context.MapUpdate.Particles.Position = Position_IfResult;
	Context.MapUpdate.SkeletalMeshLocation.InheritVelocityASC40ScaleASC41 = Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.InheritVelocityASC40ScaleASC41;
	int Tri;
	float3 BaryCoord;
	Tri = Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord.Tri;
	BaryCoord = Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord.BaryCoord;
	int Constant112 = 0;
	NiagaraID Output15;
	Output15.Index = Tri;
	Output15.AcquireTag = Constant112;
	NiagaraID NiagaraID_IfResult;
	if(Context.MapUpdate.SkeletalMeshLocation.UseSampledMeshAttributeasRibbonID)
	{
	NiagaraID_IfResult = Output15;
	}
	else
	{
	NiagaraID_IfResult = Context.MapUpdate.Particles.RibbonID;
	}
	Context.MapUpdate.Particles.RibbonID = NiagaraID_IfResult;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledPosition = Context.MapUpdate.Local.SkeletalMeshLocation.SampledPosition;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledVelocity = Context.MapUpdate.Local.SkeletalMeshLocation.SampledVelocity;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledNormal = Context.MapUpdate.Local.SkeletalMeshLocation.SampledNormal;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledTangent = Context.MapUpdate.Local.SkeletalMeshLocation.SampledTangent;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledBitangent = Context.MapUpdate.Local.SkeletalMeshLocation.SampledBitangent;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledUV = Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshUV;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledVertexColor = Context.MapUpdate.Local.SkeletalMeshLocation.SampledVertexColor;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledTriCoord = Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord;
	Context.MapUpdate.OUTPUT_VAR.SkeletalMeshLocation.SampledRotation = Context.MapUpdate.Local.SkeletalMeshLocation.SampledRotation;
}

void GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(int In_Seed, int In_Engine_System_TickCount, bool In_OverrideSeed, int In_Particles_UniqueID, int In_Emitter_RandomSeed, int In_RandomnessMode, out NiagaraRandInfo Out_RandomInfo, out bool Out_UseDeterministicRandoms, inout FSimulationContext Context)
{
	bool Constant121 = false;
	int Constant122 = 0;
	bool Result23 = NiagaraAll(In_RandomnessMode == Constant122);
	bool Result24 = Constant121 && Result23;
	int Constant123 = 1;
	bool Result25 = NiagaraAll(In_RandomnessMode == Constant123);
	bool Result26 = Result24 || Result25;
	bool Constant124 = false;
	int Seed_IfResult1;
	if(In_OverrideSeed)
	{
	Seed_IfResult1 = In_Seed;
	}
	else
	{
	Seed_IfResult1 = Context.MapUpdate.Emitter.RandomSeed;
	}
	int Constant125 = 0;
	int Constant126 = 0;
	int Seed1_IfResult2;
	int Seed2_IfResult2;
	int Seed3_IfResult2;
	if(Constant124)
	{
	Seed1_IfResult2 = Seed_IfResult1;
	Seed2_IfResult2 = Constant125;
	Seed3_IfResult2 = Constant126;
	}
	else
	{
	Seed1_IfResult2 = Context.MapUpdate.Particles.UniqueID;
	Seed2_IfResult2 = Context.MapUpdate.Engine.System.TickCount;
	Seed3_IfResult2 = Seed_IfResult1;
	}
	int Constant127 = -1;
	int Constant128 = -1;
	int Constant129 = -1;
	int Seed1_IfResult3;
	int Seed2_IfResult3;
	int Seed3_IfResult3;
	if(Result26)
	{
	Seed1_IfResult3 = Seed1_IfResult2;
	Seed2_IfResult3 = Seed2_IfResult2;
	Seed3_IfResult3 = Seed3_IfResult2;
	}
	else
	{
	Seed1_IfResult3 = Constant127;
	Seed2_IfResult3 = Constant128;
	Seed3_IfResult3 = Constant129;
	}
	NiagaraRandInfo Output16;
	Output16.Seed1 = Seed1_IfResult3;
	Output16.Seed2 = Seed2_IfResult3;
	Output16.Seed3 = Seed3_IfResult3;
	Out_RandomInfo = Output16;
	Out_UseDeterministicRandoms = Result26;
}

void TransformBase_Func_(int In_SourceSpace, int In_DestinationSpace, float4x4 In_LocalToWorldTransform, float4x4 In_WorldToLocalTransform, bool In_bLocalSpace, out bool Out_bUseOriginal, out float4x4 Out_OutTransform, inout FSimulationContext Context)
{
	int Constant134 = 0;
	bool Result27 = NiagaraAll(In_SourceSpace == Constant134);
	int Constant135 = 0;
	bool Result28 = NiagaraAll(In_DestinationSpace == Constant135);
	bool Result29 = Result27 && Result28;
	int Constant136 = 1;
	bool Result30 = NiagaraAll(In_SourceSpace == Constant136);
	int Constant137 = 1;
	bool Result31 = NiagaraAll(In_DestinationSpace == Constant137);
	bool Result32 = Result30 && Result31;
	bool Result33 = Result29 || Result32;
	int Constant138 = 2;
	bool Result34 = NiagaraAll(In_SourceSpace == Constant138);
	int Constant139 = 2;
	bool Result35 = NiagaraAll(In_DestinationSpace == Constant139);
	bool Result36 = Result34 && Result35;
	bool Result37 = Result33 || Result36;
	bool Result38 = Result27 && Result35;
	bool Result39 = Result34 && Result28;
	bool Result40 = Result38 || Result39;
	bool Result41 = In_bLocalSpace && Result40;
	bool Result42 = Result37 || Result41;
	bool Result43 = !In_bLocalSpace;
	bool Result44 = Result27 && Result31;
	bool Result45 = Result30 && Result28;
	bool Result46 = Result44 || Result45;
	bool Result47 = Result43 && Result46;
	bool Result48 = Result42 || Result47;
	bool Result49 = In_bLocalSpace && Result44;
	bool Result50 = Result34 && Result31;
	bool Result51 = Result49 || Result50;
	bool Result52 = Result43 && Result39;
	bool Result53 = Result51 || Result52;
	float4x4 Matrix_IfResult1;
	if(Result53)
	{
	Matrix_IfResult1 = In_LocalToWorldTransform;
	}
	else
	{
	Matrix_IfResult1 = In_WorldToLocalTransform;
	}
	Out_bUseOriginal = Result48;
	Out_OutTransform = Matrix_IfResult1;
}

void SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context)
{
	bool Constant133 = false;
	float4x4 Matrix_IfResult;
	float4x4 Matrix001_IfResult;
	if(In_ApplyScale)
	{
	Matrix_IfResult = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal;
	float4x4 TransformBase_Func_Output_OutTransform;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult, Matrix001_IfResult, Constant133, TransformBase_Func_Output_bUseOriginal, TransformBase_Func_Output_OutTransform, Context);
	float3 Result54 = mul(float4(In_InPosition,1.0),TransformBase_Func_Output_OutTransform).xyz;
	float3 Vector_IfResult2;
	if(TransformBase_Func_Output_bUseOriginal)
	{
	Vector_IfResult2 = In_InPosition;
	}
	else
	{
	Vector_IfResult2 = Result54;
	}
	Out_OutPosition = Vector_IfResult2;
}

void SelectV3Channel_Func_(float3 In_VECTOR_VAR, int In_TargetChannel, out float Out_Float, inout FSimulationContext Context)
{
	int Constant141 = 0;
	bool Result55 = NiagaraAll(In_TargetChannel == Constant141);
	float X;
	float Y;
	float Z;
	X = In_VECTOR_VAR.x;
	Y = In_VECTOR_VAR.y;
	Z = In_VECTOR_VAR.z;
	int Constant142 = 1;
	bool Result56 = NiagaraAll(In_TargetChannel == Constant142);
	float float_IfResult;
	if(Result56)
	{
	float_IfResult = Y;
	}
	else
	{
	float_IfResult = Z;
	}
	float float_IfResult1;
	if(Result55)
	{
	float_IfResult1 = X;
	}
	else
	{
	float_IfResult1 = float_IfResult;
	}
	Out_Float = float_IfResult1;
}

void SmoothLerpOverTime_Func_(float In_SmoothValue, float In_TargetValue, float In_ConvergenceRate, float In_DeltaTime, out float Out_NewSmoothValue, inout FSimulationContext Context)
{
	float Result57 = In_ConvergenceRate * In_DeltaTime;
	float Constant146 = 0;
	float Constant147 = 1;
	float Result58 = clamp(Result57,Constant146,Constant147);
	float Result59 = lerp(In_SmoothValue,In_TargetValue,Result58);
	Out_NewSmoothValue = Result59;
}

void SampleMeshScript_Skeletal_Emitter_Func_(inout FSimulationContext Context)
{
	int Constant114 = -1;
	int Constant115 = (0);
	bool Constant116 = false;
	bool Constant117 = false;
	int Constant118 = 0;
	int Constant119 = (0);
	int Constant120 = 1;
	NiagaraRandInfo GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo3;
	bool GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms3;
	GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(Constant114, Constant115, Constant117, Constant118, Constant119, Constant120, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo3, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms3, Context);
	MeshTriCoordinate RandomTriCoord_ParticlesSkeletalMeshOutput_Coord;
	RandomTriCoord_ParticlesSkeletalMesh(GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo3, RandomTriCoord_ParticlesSkeletalMeshOutput_Coord);
	float3 GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Position;
	float3 GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Velocity;
	float3 GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Normal;
	float3 GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Binormal;
	float3 GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Tangent;
	GetSkinnedTriangleDataWS_ParticlesSkeletalMesh(RandomTriCoord_ParticlesSkeletalMeshOutput_Coord, GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Position, GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Velocity, GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Normal, GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Binormal, GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Tangent);
	int Constant130 = 1;
	int Constant131 = 2;
	bool Constant132 = false;
	float3 SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_Output_OutPosition;
	SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_(GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Position, Constant130, Constant131, Constant132, SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_Output_OutPosition, Context);
	int Constant140 = 2;
	float SelectV3Channel_Func_Output_Float;
	SelectV3Channel_Func_(SampleMeshScript_Skeletal_TransformPosition_Emitter_Func_Output_OutPosition, Constant140, SelectV3Channel_Func_Output_Float, Context);
	float Constant143 = 0;
	float Output17;
	Output17 = Constant143;
	float Constant144 = 200;
	float Output18;
	Output18 = Constant144;
	float Constant145 = 0.3;
	float SmoothLerpOverTime_Func_Output_NewSmoothValue;
	SmoothLerpOverTime_Func_(Output17, Output18, Constant145, Context.MapUpdate.Emitter.Age, SmoothLerpOverTime_Func_Output_NewSmoothValue, Context);
	bool Result60 = NiagaraAll(SelectV3Channel_Func_Output_Float < SmoothLerpOverTime_Func_Output_NewSmoothValue);
	float3 Vector_IfResult3;
	if(Result60)
	{
	Vector_IfResult3 = GetSkinnedTriangleDataWS_ParticlesSkeletalMeshOutput_Position;
	}
	else
	{
	Vector_IfResult3 = Context.MapUpdate.Engine.Owner.Position;
	}
	Context.MapUpdate.Particles.NewPosition_Skeletal = Vector_IfResult3;
}

void ColorFromCurve_Emitter_Func_(out float4 Out_Value, inout FSimulationContext Context)
{
	float4 SampleColorCurve_EmitterColorColorCurveOutput_Value;
	SampleColorCurve_EmitterColorColorCurve(Context.MapUpdate.ColorFromCurve.CurveIndex, SampleColorCurve_EmitterColorColorCurveOutput_Value);
	Out_Value = SampleColorCurve_EmitterColorColorCurveOutput_Value;
}

void MakeVector3_FromColor001_Emitter_Func_(out float3 Out_Vector, inout FSimulationContext Context)
{
	float3 VECTOR_VAR;
	VECTOR_VAR.x = Context.MapUpdate.MakeVector3_FromColor001.Color.r;
	VECTOR_VAR.y = Context.MapUpdate.MakeVector3_FromColor001.Color.g;
	VECTOR_VAR.z = Context.MapUpdate.MakeVector3_FromColor001.Color.b;
	Out_Vector = VECTOR_VAR;
}

void Color_Emitter_Func_(inout FSimulationContext Context)
{
	float3 Output0;
	float Output2;
	Output0.x = Context.MapUpdate.Color.Color.r;
	Output0.y = Context.MapUpdate.Color.Color.g;
	Output0.z = Context.MapUpdate.Color.Color.b;
	Output2 = Context.MapUpdate.Color.Color.a;
	float3 Result61 = Output0 * Context.MapUpdate.Color.ScaleColor;
	float Result62 = Output2 * Context.MapUpdate.Constants.Emitter.Color.ScaleAlpha;
	float Result63 = Result62 * Context.MapUpdate.Emitter.AlphaScale;
	float4 Output01;
	Output01.g = Result61.y;
	Output01.a = Result63;
	Output01.r = Result61.x;
	Output01.b = Result61.z;
	Context.MapUpdate.Particles.Color = Output01;
}

void CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_(float2 In_SpriteSize, out float Out_Radius, inout FSimulationContext Context)
{
	float Result64 = length(In_SpriteSize);
	float Constant197 = 0.5;
	float Result65 = Result64 * Constant197;
	Out_Radius = Result65;
}

void Collision_TransformPosition_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context)
{
	bool Constant201 = false;
	float4x4 Matrix_IfResult2;
	float4x4 Matrix001_IfResult1;
	if(In_ApplyScale)
	{
	Matrix_IfResult2 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult1 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult2 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult1 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal1;
	float4x4 TransformBase_Func_Output_OutTransform1;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult2, Matrix001_IfResult1, Constant201, TransformBase_Func_Output_bUseOriginal1, TransformBase_Func_Output_OutTransform1, Context);
	float3 Result67 = mul(float4(In_InPosition,1.0),TransformBase_Func_Output_OutTransform1).xyz;
	float3 Vector_IfResult4;
	if(TransformBase_Func_Output_bUseOriginal1)
	{
	Vector_IfResult4 = In_InPosition;
	}
	else
	{
	Vector_IfResult4 = Result67;
	}
	Out_OutPosition = Vector_IfResult4;
}

void Collision_TransformVector002_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context)
{
	bool Constant205 = false;
	float4x4 Matrix_IfResult3;
	float4x4 Matrix001_IfResult2;
	if(In_ApplyScale)
	{
	Matrix_IfResult3 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult2 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult3 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult2 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal2;
	float4x4 TransformBase_Func_Output_OutTransform2;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult3, Matrix001_IfResult2, Constant205, TransformBase_Func_Output_bUseOriginal2, TransformBase_Func_Output_OutTransform2, Context);
	float3 Result68 = mul(float4(In_InVector,0.0),TransformBase_Func_Output_OutTransform2).xyz;
	float3 Vector_IfResult5;
	if(TransformBase_Func_Output_bUseOriginal2)
	{
	Vector_IfResult5 = In_InVector;
	}
	else
	{
	Vector_IfResult5 = Result68;
	}
	Out_OutVector = Vector_IfResult5;
}

void Collision_TransformVector003_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context)
{
	bool Constant209 = false;
	float4x4 Matrix_IfResult4;
	float4x4 Matrix001_IfResult3;
	if(In_ApplyScale)
	{
	Matrix_IfResult4 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult3 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult4 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult3 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal3;
	float4x4 TransformBase_Func_Output_OutTransform3;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult4, Matrix001_IfResult3, Constant209, TransformBase_Func_Output_bUseOriginal3, TransformBase_Func_Output_OutTransform3, Context);
	float3 Result69 = mul(float4(In_InVector,0.0),TransformBase_Func_Output_OutTransform3).xyz;
	float3 Vector_IfResult6;
	if(TransformBase_Func_Output_bUseOriginal3)
	{
	Vector_IfResult6 = In_InVector;
	}
	else
	{
	Vector_IfResult6 = Result69;
	}
	Out_OutVector = Vector_IfResult6;
}

void DirectionAndLengthSafe_Func_(float3 In_V, float3 In_Fallback, float In_Threshold, float In_FallbackLength, out float3 Out_Direction, out float Out_Length, out bool Out_BelowThreshold, inout FSimulationContext Context)
{
	float Result74 = length(In_V);
	bool Result75 = NiagaraAll(Result74 < In_Threshold);
	float Result76 = length(In_Fallback);
	float3 Vector_IfResult7;
	float float_IfResult3;
	if(Result75)
	{
	Vector_IfResult7 = In_Fallback;
	float_IfResult3 = In_FallbackLength;
	}
	else
	{
	Vector_IfResult7 = In_V;
	float_IfResult3 = Result74;
	}
	float3 Result77 = Vector_IfResult7 / float_IfResult3;
	float3 Vector_IfResult8;
	float float_IfResult4;
	if(Result75)
	{
	Vector_IfResult8 = In_Fallback;
	float_IfResult4 = Result76;
	}
	else
	{
	Vector_IfResult8 = Result77;
	float_IfResult4 = float_IfResult3;
	}
	Out_Direction = Vector_IfResult8;
	Out_Length = float_IfResult4;
	Out_BelowThreshold = Result75;
}

void Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_(float In_CollisionBackfaceThickness, float3 In_ParticlePosition, float In_ParticleRadius, float3 In_StartTrace, float3 In_EndTrace, bool In_KillOccludedParticles, out float3 Out_ImpactPosition, out float3 Out_ImpactNormal, out bool Out_Occluded, out bool Out_Collides, out bool Out_Onscreentest, out bool Out_KillBecauseofOcclusion, inout FSimulationContext Context)
{
	float QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SceneDepth;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_CameraPosWorld;
	bool QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_IsInsideView;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SamplePosWorld;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal;
	QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQuery(In_ParticlePosition, QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SceneDepth, QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_CameraPosWorld, QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_IsInsideView, QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SamplePosWorld, QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal);
	float3 Result83 = In_ParticlePosition - QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_CameraPosWorld;
	float Result84 = length(Result83);
	float Result85 = Result84 - In_ParticleRadius;
	float3 Result86 = QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SamplePosWorld - QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_CameraPosWorld;
	float Result87 = length(Result86);
	float Result88 = Result85 - Result87;
	float Constant246 = 0;
	bool Result89 = NiagaraAll(Result88 >= Constant246);
	float Result90 = dot(In_ParticlePosition,QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal);
	float Result91 = Result90 + In_ParticleRadius;
	float Result92 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SamplePosWorld,QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal);
	float Result93 = Result91 - Result92;
	float Constant247 = 0;
	bool Result94 = NiagaraAll(Result93 >= Constant247);
	float Result95 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal,In_EndTrace);
	float Result96 = Result95 - Result92 - In_ParticleRadius;
	float Constant248 = 0;
	bool Result97 = NiagaraAll(Result96 <= Constant248);
	float3 Result98 = In_EndTrace - In_StartTrace;
	float Result99 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal,Result98);
	float Constant249 = 0;
	bool Result100 = NiagaraAll(Result99 < Constant249);
	bool Result101 = Result94 && Result97 && Result100;
	float Constant250 = 0;
	bool Result102 = NiagaraAll(Result88 > Constant250);
	bool Result103 = In_KillOccludedParticles && Result102;
	Out_ImpactPosition = QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SamplePosWorld;
	Out_ImpactNormal = QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_SampleWorldNormal;
	Out_Occluded = Result89;
	Out_Collides = Result101;
	Out_Onscreentest = QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQueryOutput_IsInsideView;
	Out_KillBecauseofOcclusion = Result103;
}

void PlaneSphereCollisionDetection_Func_(float3 In_PlaneNormal, float3 In_PlanePivotPoint, float3 In_InitialSphereLocation, float3 In_SpherePositionDelta, float In_CollisionRadius, float In_PhysicsDeltaTime, float In_MaxCorrectiondistance, out bool Out_Collides, out float3 Out_IntersectionLocation, out float3 Out_PreASC45IntersectionSphereCenterLocation, out float3 Out_InitialPositionRelativeCollisionLocation, out float Out_TimeElapsedToCollision, out float Out_RemainingTimePostCollision, out float Out_PercentageofTimeUsedToPerformCollision, out float Out_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision, out float Out_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane, inout FSimulationContext Context)
{
	float3 Result111 = -(In_PlaneNormal);
	float3 Result112 = In_PlanePivotPoint - In_InitialSphereLocation;
	float Result113 = dot(Result111,Result112);
	float Result114 = Result113 - In_CollisionRadius;
	float Constant254 = 0;
	bool Result115 = NiagaraAll(Result114 < Constant254);
	bool Constant255 = true;
	float3 Result116 = Result111 * Result113;
	float3 Result117 = Result116 + In_InitialSphereLocation;
	float Result118 = max(In_MaxCorrectiondistance, Result114);
	float3 Result119 = Result118 * Result111;
	float3 Result120 = Result119 + In_InitialSphereLocation;
	float Constant256 = 0;
	float Constant257 = 0;
	float3 Result121 = In_InitialSphereLocation + In_SpherePositionDelta;
	float3 Result122 = In_PlanePivotPoint - Result121;
	float Result123 = dot(Result111,Result122);
	float Result124 = Result123 - In_CollisionRadius;
	float Constant258 = 0;
	bool Result125 = NiagaraAll(Result124 <= Constant258);
	float Result126 = abs(Result124);
	float Result127 = Result114 - Result124;
	float Result128 = abs(Result127);
	float Constant259 = 1e-06;
	float Result129 = max(Result128, Constant259);
	float Result130 = Result126 / Result129;
	float Constant260 = 0;
	bool Result131 = NiagaraAll(Result130 == Constant260);
	bool Result132 = Result115 || Result131;
	float Constant261 = 1;
	float float_IfResult5;
	if(Result132)
	{
	float_IfResult5 = Constant261;
	}
	else
	{
	float_IfResult5 = Result130;
	}
	float Result133 = 1 - float_IfResult5;
	float3 Result134 = Result133 * In_SpherePositionDelta;
	float3 Result135 = In_InitialSphereLocation + Result134;
	float3 Result136 = Result111 * In_CollisionRadius;
	float3 Result137 = Result135 + Result136;
	float3 Result138 = Result137 - Result135;
	float Result139 = In_PhysicsDeltaTime * Result133;
	float Result140 = In_PhysicsDeltaTime * float_IfResult5;
	bool Collides_IfResult;
	float3 IntersectionLocation_IfResult;
	float3 PreASC45IntersectionSphereCenterLocation_IfResult;
	float3 InitialPositionRelativeCollisionLocation_IfResult;
	float TimeElapsedToCollision_IfResult;
	float RemainingTimePostCollision_IfResult;
	float PercentageofTimeUsedToPerformCollision_IfResult;
	float InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision_IfResult;
	float UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane_IfResult;
	if(Result115)
	{
	Collides_IfResult = Constant255;
	IntersectionLocation_IfResult = Result117;
	PreASC45IntersectionSphereCenterLocation_IfResult = Result120;
	InitialPositionRelativeCollisionLocation_IfResult = Result116;
	TimeElapsedToCollision_IfResult = Constant256;
	RemainingTimePostCollision_IfResult = In_PhysicsDeltaTime;
	PercentageofTimeUsedToPerformCollision_IfResult = Constant257;
	InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision_IfResult = Result114;
	UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane_IfResult = Result124;
	}
	else
	{
	Collides_IfResult = Result125;
	IntersectionLocation_IfResult = Result137;
	PreASC45IntersectionSphereCenterLocation_IfResult = Result135;
	InitialPositionRelativeCollisionLocation_IfResult = Result138;
	TimeElapsedToCollision_IfResult = Result139;
	RemainingTimePostCollision_IfResult = Result140;
	PercentageofTimeUsedToPerformCollision_IfResult = Result133;
	InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision_IfResult = Result114;
	UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane_IfResult = Result124;
	}
	Out_Collides = Collides_IfResult;
	Out_IntersectionLocation = IntersectionLocation_IfResult;
	Out_PreASC45IntersectionSphereCenterLocation = PreASC45IntersectionSphereCenterLocation_IfResult;
	Out_InitialPositionRelativeCollisionLocation = InitialPositionRelativeCollisionLocation_IfResult;
	Out_TimeElapsedToCollision = TimeElapsedToCollision_IfResult;
	Out_RemainingTimePostCollision = RemainingTimePostCollision_IfResult;
	Out_PercentageofTimeUsedToPerformCollision = PercentageofTimeUsedToPerformCollision_IfResult;
	Out_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision = InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision_IfResult;
	Out_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane = UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane_IfResult;
}

void RandomRangeFloat_Func_(float2 In_Min, float2 In_Max, int In_Seed, int In_RandomnessMode, bool In_OverrideSeed, out float2 Out_Result, inout FSimulationContext Context)
{
	int Constant272 = (0);
	bool Constant273 = false;
	int Constant274 = 0;
	int Constant275 = (0);
	bool Constant276 = false;
	NiagaraRandInfo GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo4;
	bool GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms4;
	GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_(In_Seed, Constant272, In_OverrideSeed, Constant274, Constant275, Constant276, In_RandomnessMode, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo4, GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms4, Context);
	float2 Result156 = In_Max - In_Min;
	int Seed12;
	int Seed22;
	int Seed32;
	Seed12 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo4.Seed1;
	Seed22 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo4.Seed2;
	Seed32 = GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_RandomInfo4.Seed3;
	float2 Result157 = rand_float(Result156, Seed12, Seed22, Seed32);
	float2 Result158 = rand_float(Result156);
	float2 Random_IfResult2;
	if(GetRandomInfo_Emitter_Determinism_false_Particle_Particle_Particle_Func_Output_UseDeterministicRandoms4)
	{
	Random_IfResult2 = Result157;
	}
	else
	{
	Random_IfResult2 = Result158;
	}
	float2 Result159 = In_Min + Random_IfResult2;
	Out_Result = Result159;
}

void CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_(bool In_InputsAreNormalized, float3 In_From, float3 In_To, out float4 Out_Result)
{



		float NormAB = 1.0f;
	    float NormFactor = sqrt((In_From.x*In_From.x + In_From.y*In_From.y + In_From.z*In_From.z) * (In_To.x*In_To.x + In_To.y*In_To.y + In_To.z*In_To.z));

	    if (In_InputsAreNormalized)
	    {
	         NormAB = 1.0f;
	    }
	    else
	    {
	         NormAB = NormFactor;
	   }

		float w = NormAB + dot(In_From, In_To);
	    float4 Result1 = float4(In_From.y * In_To.z - In_From.z * In_To.y,
						   In_From.z * In_To.x - In_From.x * In_To.z,
						   In_From.x * In_To.y - In_From.y * In_To.x,
						   w);
		float4 Result2 = float4(-In_From.z, 0.0f, In_From.x, 0.0f);
	    float4 Result3 = float4(0.0f, -In_From.z, In_From.y, 0.0f);


	    if (abs(In_From.x) > abs(In_From.y))
	    {
	        Out_Result = Result2;
	    }
	    else
	    {
	        Out_Result = Result3;
	    }


		if (w >= 3.4e-4f * NormAB)
		{

			Out_Result = Result1;
		}

		Out_Result = normalize(Out_Result);

}

void FindQuatBetween_Func_(float3 In_From, float3 In_To, bool In_InputsAreNormalized, out float4 Out_NewOutput, inout FSimulationContext Context)
{
	float4 CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_Output_Result;
	CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_(In_InputsAreNormalized, In_From, In_To, CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_Output_Result);
	Out_NewOutput = CustomHlsl5A25A2A4455E3C692D3322A954DF887F_Func_Output_Result;
}

void MultiplyVectorWithQuaternion_Func_(float3 In_VECTOR_VAR, float4 In_Quaternion, out float3 Out_Vector, inout FSimulationContext Context)
{
	float3 Output02;
	float Output111;
	Output02.x = In_Quaternion.x;
	Output02.y = In_Quaternion.y;
	Output02.z = In_Quaternion.z;
	Output111 = In_Quaternion.w;
	float Result171 = dot(Output02,In_VECTOR_VAR);
	float Constant285 = 2;
	float Result172 = Result171 * Constant285;
	float3 Result173 = Output02 * Result172;
	float Result174 = Output111 * Output111;
	float Result175 = dot(Output02,Output02);
	float Result176 = Result174 - Result175;
	float3 Result177 = Result176 * In_VECTOR_VAR;
	float3 Result178 = Result173 + Result177;
	float3 Result179 = cross(Output02,In_VECTOR_VAR);
	float Constant286 = 2;
	float Result180 = Output111 * Constant286;
	float3 Result181 = Result179 * Result180;
	float3 Result182 = Result178 + Result181;
	Out_Vector = Result182;
}

void RandomizeCollisionNormals_Func_(float3 In_ConeAxis, float In_Scale, float In_Spread, out float3 Out_Ouput, inout FSimulationContext Context)
{
	float Constant266 = 0;
	float Constant267 = 1;
	float Result154 = clamp(In_Spread,Constant266,Constant267);
	float Constant268 = -1;
	float Result155 = Result154 * Constant268;
	float2 Output19;
	Output19.x = Result155;
	Output19.y = Result155;
	float2 Output110;
	Output110.x = Result154;
	Output110.y = Result154;
	int Constant269 = -1;
	int Constant270 = 0;
	bool Constant271 = false;
	float2 RandomRangeFloat_Func_Output_Result4;
	RandomRangeFloat_Func_(Output19, Output110, Constant269, Constant270, Constant271, RandomRangeFloat_Func_Output_Result4, Context);
	float X1;
	float Y1;
	X1 = RandomRangeFloat_Func_Output_Result4.x;
	Y1 = RandomRangeFloat_Func_Output_Result4.y;
	float3 Constant277 = float3(1,0,0);
	float3 Result160 = X1 * Constant277;
	float3 Constant278 = float3(0,1,0);
	float3 Result161 = Y1 * Constant278;
	float3 Result162 = Result160 + Result161;
	float Result163 = abs(X1);
	float Result164 = abs(Y1);
	float Result165 = max(Result163, Result164);
	float Result166 = 1 - Result165;
	float3 Constant279 = float3(0,0,1);
	float3 Result167 = Result166 * Constant279;
	float3 Result168 = Result162 + Result167;
	float3 Result169 = normalize(Result168);
	float3 Result170 = Result169 * In_Scale;
	float3 Constant280 = float3(0,0,1);
	float3 Constant281 = float3(0,0,1);
	float Constant282 = 1e-05;
	float Constant283 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction2;
	float DirectionAndLengthSafe_Func_Output_Length2;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold2;
	DirectionAndLengthSafe_Func_(In_ConeAxis, Constant281, Constant282, Constant283, DirectionAndLengthSafe_Func_Output_Direction2, DirectionAndLengthSafe_Func_Output_Length2, DirectionAndLengthSafe_Func_Output_BelowThreshold2, Context);
	bool Constant284 = false;
	float4 FindQuatBetween_Func_Output_NewOutput;
	FindQuatBetween_Func_(Constant280, DirectionAndLengthSafe_Func_Output_Direction2, Constant284, FindQuatBetween_Func_Output_NewOutput, Context);
	float3 MultiplyVectorWithQuaternion_Func_Output_Vector;
	MultiplyVectorWithQuaternion_Func_(Result170, FindQuatBetween_Func_Output_NewOutput, MultiplyVectorWithQuaternion_Func_Output_Vector, Context);
	Out_Ouput = MultiplyVectorWithQuaternion_Func_Output_Vector;
}

void ReflectVector_Func_(float3 In_InVector, float3 In_Normal, out float3 Out_Reflected, inout FSimulationContext Context)
{
	float Result183 = dot(In_InVector,In_Normal);
	float Result184 = Result183 + Result183;
	float3 Result185 = Result184 * In_Normal;
	float3 Result186 = In_InVector - Result185;
	Out_Reflected = Result186;
}

void CentimeterMeterConversion_Func_(float3 In_INPUT_VAR, out float3 Out_CentimeterstoMeters, out float3 Out_MeterstoCentimeters, inout FSimulationContext Context)
{
	float Constant287 = 0.01;
	float3 Result187 = In_INPUT_VAR * Constant287;
	float Constant288 = 100;
	float3 Result188 = In_INPUT_VAR * Constant288;
	Out_CentimeterstoMeters = Result187;
	Out_MeterstoCentimeters = Result188;
}

void ProjectVectorOnPlane_Func_(float3 In_VECTOR_VAR, float3 In_Normal, out float3 Out_Ouput, inout FSimulationContext Context)
{
	float Result192 = dot(In_VECTOR_VAR,In_Normal);
	float3 Result193 = Result192 * In_Normal;
	float3 Result194 = In_VECTOR_VAR - Result193;
	Out_Ouput = Result194;
}

void Collision_CollisionQueryAndResponse_Emitter_Func_(inout FSimulationContext Context)
{
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleInitialDataInstanceAlive = Context.MapUpdate.DataInstance.Alive;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime = Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	float3 Result70 = Context.MapUpdate.Transient.PhysicsForce / Context.MapUpdate.Particles.Mass;
	float3 Result71 = Result70 * Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	float3 Result72 = Result71 + Context.MapUpdate.Particles.Velocity;
	float3 Result73 = Result72 * Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceOrigin = Context.MapUpdate.Particles.Position;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleForceContribution = Result71;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleAttemptedMovementThisUpdate = Result73;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleInitialForceDividedByMass = Result70;
	float3 Constant239 = float3(0,0,-1);
	float Constant240 = 1e-05;
	float Constant241 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction;
	float DirectionAndLengthSafe_Func_Output_Length;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold;
	DirectionAndLengthSafe_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleForceContribution, Constant239, Constant240, Constant241, DirectionAndLengthSafe_Func_Output_Direction, DirectionAndLengthSafe_Func_Output_Length, DirectionAndLengthSafe_Func_Output_BelowThreshold, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceVector = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleForceContribution;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceDirection = DirectionAndLengthSafe_Func_Output_Direction;
	float3 Result78 = DirectionAndLengthSafe_Func_Output_Direction * Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius;
	float3 Result79 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceOrigin - Result78;
	float3 Result80 = Result78 + Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleForceContribution;
	float3 Constant242 = float3(0,0,-1);
	float Constant243 = 1e-05;
	float Constant244 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction1;
	float DirectionAndLengthSafe_Func_Output_Length1;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold1;
	DirectionAndLengthSafe_Func_(Result80, Constant242, Constant243, Constant244, DirectionAndLengthSafe_Func_Output_Direction1, DirectionAndLengthSafe_Func_Output_Length1, DirectionAndLengthSafe_Func_Output_BelowThreshold1, Context);
	float3 Result81 = DirectionAndLengthSafe_Func_Output_Direction1 * DirectionAndLengthSafe_Func_Output_Length1;
	float3 Result82 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceOrigin + Result81;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldStart = Result79;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldEnd = Result82;
	int Constant245 = 0;
	float3 Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactPosition;
	float3 Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactNormal;
	bool Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Occluded;
	bool Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Collides;
	bool Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	bool Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion;
	Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_(Context.MapUpdate.Collision.CollisionQueryAndResponse.DepthBufferBackfaceThickness, Context.MapUpdate.Particles.Position, Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldStart, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldEnd, Context.MapUpdate.Collision.CollisionQueryAndResponse.KillOccludedParticles, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactPosition, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactNormal, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Occluded, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Collides, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Onscreentest, Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion, Context);
	float Constant251 = 0;
	bool Result104 = !Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	bool Result105 = Result104 && Context.MapUpdate.Particles.HasCollided;
	bool Result106 = !Result105;
	bool Result107 = Context.MapUpdate.Collision.CollisionQueryAndResponse.AllowOffscreenDepthBufferParticlesToLive || Result106;
	bool Result108 = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Onscreentest && Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion;
	bool Result109 = !Result108;
	bool Result110 = Context.MapUpdate.DataInstance.Alive && Result107 && Result109;
	Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse.CollisionID = Constant245;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionValidBool = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Collides;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionWorldPosition = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactPosition;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionNormal = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_ImpactNormal;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedFriction = Constant251;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedRestitution = Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRestitutionCoeffiecient;
	Context.MapUpdate.DataInstance.Alive = Result110;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.DepthBasedCollisionParticleOccluded = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Occluded;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.ParticleOnScreen = Collision_CollisionQueryAndResponse_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	float3 Constant252 = float3(0,0,1);
	float3 Constant253 = float3(0,0,-1e+16);
	float3 PlaneNormal_IfResult;
	float3 PlanePivotPoint_IfResult;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionValidBool)
	{
	PlaneNormal_IfResult = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionNormal;
	PlanePivotPoint_IfResult = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionWorldPosition;
	}
	else
	{
	PlaneNormal_IfResult = Constant252;
	PlanePivotPoint_IfResult = Constant253;
	}
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlaneNormal = PlaneNormal_IfResult;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlanePivotPoint = PlanePivotPoint_IfResult;
	bool PlaneSphereCollisionDetection_Func_Output_Collides;
	float3 PlaneSphereCollisionDetection_Func_Output_IntersectionLocation;
	float3 PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation;
	float3 PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation;
	float PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision;
	float PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision;
	float PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision;
	float PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision;
	float PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane;
	PlaneSphereCollisionDetection_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlaneNormal, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlanePivotPoint, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceOrigin, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleAttemptedMovementThisUpdate, Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius, Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime, Context.MapUpdate.Collision.CollisionQueryAndResponse.MaxIntersectionCorrectionDistance, PlaneSphereCollisionDetection_Func_Output_Collides, PlaneSphereCollisionDetection_Func_Output_IntersectionLocation, PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation, PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation, PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision, PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision, PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision, PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision, PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane, Context);
	Context.MapUpdate.Transient.CollisionWorldPosition = PlaneSphereCollisionDetection_Func_Output_IntersectionLocation;
	Context.MapUpdate.Transient.CollisionParticleWorldPosition = PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation;
	Context.MapUpdate.Transient.CollisionParticleRelativeCollisionLocation = PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTickDeltaForThisCollisionUpdate = PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePhysicsDeltaTime = PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePercentageOfTickDedicatedToUpdatingPosition = PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.CollisionPenetrationDistance = PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision;
	Context.MapUpdate.Transient.CollisionDistanceToCollision = PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane;
	float Constant262 = 0;
	bool Result141 = NiagaraAll(Context.MapUpdate.Transient.CollisionDistanceToCollision <= Constant262);
	bool Result142 = Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionEnabled && Result141;
	bool Result143 = Result142 || Context.MapUpdate.Particles.HasCollided;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.PhysicsCollidesThisFrame = Result142;
	Context.MapUpdate.Particles.HasCollided = Result143;
	float3 Result144 = -(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlaneNormal);
	float Result145 = dot(Result144,Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleAttemptedMovementThisUpdate);
	float Result146 = Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime * Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	float3 Result147 = Result146 * Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleInitialForceDividedByMass;
	float Result148 = dot(Result144,Result147);
	float Result149 = Result145 - Result148;
	float Constant263 = 0.1;
	bool Result150 = NiagaraAll(Result149 < Constant263);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleRemoveRestitution = Result150;
	float3 Result151 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleAttemptedMovementThisUpdate / Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	float float_IfResult6;
	if(Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.PhysicsCollidesThisFrame)
	{
	float_IfResult6 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePhysicsDeltaTime;
	}
	else
	{
	float_IfResult6 = Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime;
	}
	float Constant264 = 0;
	float float_IfResult7;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleRemoveRestitution)
	{
	float_IfResult7 = Constant264;
	}
	else
	{
	float_IfResult7 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedRestitution;
	}
	Context.MapUpdate.Transient.CollisionValid = Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.PhysicsCollidesThisFrame;
	Context.MapUpdate.Transient.CollisionSize = Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius;
	Context.MapUpdate.Transient.CollisionNormal = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlaneNormal;
	Context.MapUpdate.Transient.CollisionVelocity = Result151;
	Context.MapUpdate.Transient.CollisionFriction = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedFriction;
	Context.MapUpdate.Transient.PhysicsDeltaTime = float_IfResult6;
	Context.MapUpdate.Transient.CollisionRestitution = float_IfResult7;
	bool Result152 = !Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleRemoveRestitution;
	bool Result153 = Result152 && Context.MapUpdate.Collision.CollisionQueryAndResponse.RandomizeCollisionNormal;
	float Constant265 = 1;
	float3 RandomizeCollisionNormals_Func_Output_Ouput;
	RandomizeCollisionNormals_Func_(Context.MapUpdate.Transient.CollisionNormal, Constant265, Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionNormalRandomizationPercentage, RandomizeCollisionNormals_Func_Output_Ouput, Context);
	float3 Vector_IfResult9;
	if(Result153)
	{
	Vector_IfResult9 = RandomizeCollisionNormals_Func_Output_Ouput;
	}
	else
	{
	Vector_IfResult9 = Context.MapUpdate.Transient.CollisionNormal;
	}
	float3 ReflectVector_Func_Output_Reflected;
	ReflectVector_Func_(Context.MapUpdate.Transient.CollisionVelocity, Vector_IfResult9, ReflectVector_Func_Output_Reflected, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocity = ReflectVector_Func_Output_Reflected;
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters;
	CentimeterMeterConversion_Func_(Context.MapUpdate.Transient.CollisionVelocity, CentimeterMeterConversion_Func_Output_CentimeterstoMeters, CentimeterMeterConversion_Func_Output_MeterstoCentimeters, Context);
	float3 Result189 = Context.MapUpdate.Particles.Mass * CentimeterMeterConversion_Func_Output_CentimeterstoMeters;
	float Constant289 = -1;
	float3 Result190 = Result189 * Constant289;
	float Result191 = dot(Result190,Context.MapUpdate.Transient.CollisionNormal);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleNormalForceInNewtons = Result191;
	float3 ProjectVectorOnPlane_Func_Output_Ouput;
	ProjectVectorOnPlane_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocity, Context.MapUpdate.Transient.CollisionNormal, ProjectVectorOnPlane_Func_Output_Ouput, Context);
	float3 Constant290 = float3(0,0,0);
	float Constant291 = 1e-05;
	float Constant292 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction3;
	float DirectionAndLengthSafe_Func_Output_Length3;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold3;
	DirectionAndLengthSafe_Func_(ProjectVectorOnPlane_Func_Output_Ouput, Constant290, Constant291, Constant292, DirectionAndLengthSafe_Func_Output_Direction3, DirectionAndLengthSafe_Func_Output_Length3, DirectionAndLengthSafe_Func_Output_BelowThreshold3, Context);
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters1;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters1;
	CentimeterMeterConversion_Func_(ProjectVectorOnPlane_Func_Output_Ouput, CentimeterMeterConversion_Func_Output_CentimeterstoMeters1, CentimeterMeterConversion_Func_Output_MeterstoCentimeters1, Context);
	float3 Result195 = CentimeterMeterConversion_Func_Output_CentimeterstoMeters1 * Context.MapUpdate.Particles.Mass;
	float float_IfResult8;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleRemoveRestitution)
	{
	float_IfResult8 = Context.MapUpdate.Collision.CollisionQueryAndResponse.DynamicFrictionCoefficient;
	}
	else
	{
	float_IfResult8 = Context.MapUpdate.Collision.CollisionQueryAndResponse.BounceCollisionFriction;
	}
	float3 Result196 = DirectionAndLengthSafe_Func_Output_Direction3 * float_IfResult8 * Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleNormalForceInNewtons;
	float3 Result197 = Result195 - Result196;
	float3 Constant293 = float3(0,0,0);
	float Constant294 = 1e-05;
	float Constant295 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction4;
	float DirectionAndLengthSafe_Func_Output_Length4;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold4;
	DirectionAndLengthSafe_Func_(Result197, Constant293, Constant294, Constant295, DirectionAndLengthSafe_Func_Output_Direction4, DirectionAndLengthSafe_Func_Output_Length4, DirectionAndLengthSafe_Func_Output_BelowThreshold4, Context);
	float Result198 = dot(DirectionAndLengthSafe_Func_Output_Direction3,DirectionAndLengthSafe_Func_Output_Direction4);
	float Constant296 = 0;
	bool Result199 = NiagaraAll(Result198 <= Constant296);
	float3 Vector_IfResult10;
	if(Result199)
	{
	Vector_IfResult10 = Result195;
	}
	else
	{
	Vector_IfResult10 = Result196;
	}
	float Constant297 = -1;
	float3 Result200 = Vector_IfResult10 * Constant297;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVectorInNewtons = Result200;
	float3 Result201 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVectorInNewtons / Context.MapUpdate.Particles.Mass;
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters2;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters2;
	CentimeterMeterConversion_Func_(Result201, CentimeterMeterConversion_Func_Output_CentimeterstoMeters2, CentimeterMeterConversion_Func_Output_MeterstoCentimeters2, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVelocityVector = CentimeterMeterConversion_Func_Output_MeterstoCentimeters2;
	float3 Result202 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocity + Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVelocityVector;
	float Result203 = dot(Context.MapUpdate.Transient.CollisionNormal,Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocity);
	float3 Result204 = Context.MapUpdate.Transient.CollisionNormal * Result203;
	float Result205 = 1 - Context.MapUpdate.Transient.CollisionRestitution;
	float3 Result206 = Result204 * Result205;
	float3 Result207 = Result202 - Result206;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocityWithFrictionApplied = Result207;
	float3 Particleposition_IfResult;
	if(Context.MapUpdate.Transient.CollisionValid)
	{
	Particleposition_IfResult = Context.MapUpdate.Transient.CollisionParticleWorldPosition;
	}
	else
	{
	Particleposition_IfResult = Context.MapUpdate.Particles.Position;
	}
	Context.MapUpdate.Particles.Position = Particleposition_IfResult;
	float3 Constant298 = float3(0,0,1);
	float Constant299 = 1e-05;
	float Constant300 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction5;
	float DirectionAndLengthSafe_Func_Output_Length5;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold5;
	DirectionAndLengthSafe_Func_(Context.MapUpdate.Transient.CollisionVelocity, Constant298, Constant299, Constant300, DirectionAndLengthSafe_Func_Output_Direction5, DirectionAndLengthSafe_Func_Output_Length5, DirectionAndLengthSafe_Func_Output_BelowThreshold5, Context);
	float Result208 = dot(DirectionAndLengthSafe_Func_Output_Direction5,Context.MapUpdate.Transient.CollisionNormal);
	float Constant301 = 0;
	bool Result209 = NiagaraAll(Result208 < Constant301);
	bool Result210 = Result209 && Context.MapUpdate.Transient.CollisionValid;
	float3 Constant302 = float3(0,0,0);
	float3 physicsforce_IfResult;
	float3 Velocity_IfResult;
	if(Result210)
	{
	physicsforce_IfResult = Constant302;
	Velocity_IfResult = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocityWithFrictionApplied;
	}
	else
	{
	physicsforce_IfResult = Context.MapUpdate.Transient.PhysicsForce;
	Velocity_IfResult = Context.MapUpdate.Particles.Velocity;
	}
	Context.MapUpdate.Transient.PhysicsForce = physicsforce_IfResult;
	Context.MapUpdate.Particles.Velocity = Velocity_IfResult;
}

void Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_(float In_CollisionBackfaceThickness, float3 In_ParticlePosition, float In_ParticleRadius, float3 In_StartTrace, float3 In_EndTrace, bool In_KillOccludedParticles, out float3 Out_ImpactPosition, out float3 Out_ImpactNormal, out bool Out_Occluded, out bool Out_Collides, out bool Out_Onscreentest, out bool Out_KillBecauseofOcclusion, inout FSimulationContext Context)
{
	float QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SceneDepth;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_CameraPosWorld;
	bool QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_IsInsideView;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SamplePosWorld;
	float3 QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal;
	QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001Query(In_ParticlePosition, QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SceneDepth, QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_CameraPosWorld, QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_IsInsideView, QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SamplePosWorld, QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal);
	float3 Result220 = In_ParticlePosition - QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_CameraPosWorld;
	float Result221 = length(Result220);
	float Result222 = Result221 - In_ParticleRadius;
	float3 Result223 = QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SamplePosWorld - QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_CameraPosWorld;
	float Result224 = length(Result223);
	float Result225 = Result222 - Result224;
	float Constant337 = 0;
	bool Result226 = NiagaraAll(Result225 >= Constant337);
	float Result227 = dot(In_ParticlePosition,QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal);
	float Result228 = Result227 + In_ParticleRadius;
	float Result229 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SamplePosWorld,QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal);
	float Result230 = Result228 - Result229;
	float Constant338 = 0;
	bool Result231 = NiagaraAll(Result230 >= Constant338);
	float Result232 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal,In_EndTrace);
	float Result233 = Result232 - Result229 - In_ParticleRadius;
	float Constant339 = 0;
	bool Result234 = NiagaraAll(Result233 <= Constant339);
	float3 Result235 = In_EndTrace - In_StartTrace;
	float Result236 = dot(QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal,Result235);
	float Constant340 = 0;
	bool Result237 = NiagaraAll(Result236 < Constant340);
	bool Result238 = Result231 && Result234 && Result237;
	float Constant341 = 0;
	bool Result239 = NiagaraAll(Result225 > Constant341);
	bool Result240 = In_KillOccludedParticles && Result239;
	Out_ImpactPosition = QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SamplePosWorld;
	Out_ImpactNormal = QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_SampleWorldNormal;
	Out_Occluded = Result226;
	Out_Collides = Result238;
	Out_Onscreentest = QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001QueryOutput_IsInsideView;
	Out_KillBecauseofOcclusion = Result240;
}

void Collision_CollisionQueryAndResponse001_Emitter_Func_(inout FSimulationContext Context)
{
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleInitialDataInstanceAlive = Context.MapUpdate.DataInstance.Alive;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime = Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	float3 Result211 = Context.MapUpdate.Transient.PhysicsForce / Context.MapUpdate.Particles.Mass;
	float3 Result212 = Result211 * Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	float3 Result213 = Result212 + Context.MapUpdate.Particles.Velocity;
	float3 Result214 = Result213 * Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceOrigin = Context.MapUpdate.Particles.Position;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleForceContribution = Result212;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate = Result214;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleInitialForceDividedByMass = Result211;
	float3 Constant330 = float3(0,0,-1);
	float Constant331 = 1e-05;
	float Constant332 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction6;
	float DirectionAndLengthSafe_Func_Output_Length6;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold6;
	DirectionAndLengthSafe_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate, Constant330, Constant331, Constant332, DirectionAndLengthSafe_Func_Output_Direction6, DirectionAndLengthSafe_Func_Output_Length6, DirectionAndLengthSafe_Func_Output_BelowThreshold6, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceVector = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceDirection = DirectionAndLengthSafe_Func_Output_Direction6;
	float3 Result215 = DirectionAndLengthSafe_Func_Output_Direction6 * Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius;
	float3 Result216 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceOrigin - Result215;
	float3 Result217 = Result215 + Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate;
	float3 Constant333 = float3(0,0,-1);
	float Constant334 = 1e-05;
	float Constant335 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction7;
	float DirectionAndLengthSafe_Func_Output_Length7;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold7;
	DirectionAndLengthSafe_Func_(Result217, Constant333, Constant334, Constant335, DirectionAndLengthSafe_Func_Output_Direction7, DirectionAndLengthSafe_Func_Output_Length7, DirectionAndLengthSafe_Func_Output_BelowThreshold7, Context);
	float3 Result218 = DirectionAndLengthSafe_Func_Output_Direction7 * DirectionAndLengthSafe_Func_Output_Length7;
	float3 Result219 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceOrigin + Result218;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldStart = Result216;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldEnd = Result219;
	int Constant336 = 0;
	float3 Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactPosition;
	float3 Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactNormal;
	bool Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Occluded;
	bool Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Collides;
	bool Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	bool Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion;
	Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_(Context.MapUpdate.Collision.CollisionQueryAndResponse001.DepthBufferBackfaceThickness, Context.MapUpdate.Particles.Position, Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldStart, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldEnd, Context.MapUpdate.Collision.CollisionQueryAndResponse001.KillOccludedParticles, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactPosition, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactNormal, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Occluded, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Collides, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Onscreentest, Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion, Context);
	float Constant342 = 0;
	bool Result241 = !Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	bool Result242 = Result241 && Context.MapUpdate.Particles.HasCollided;
	bool Result243 = !Result242;
	bool Result244 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.AllowOffscreenDepthBufferParticlesToLive || Result243;
	bool Result245 = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Onscreentest && Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_KillBecauseofOcclusion;
	bool Result246 = !Result245;
	bool Result247 = Context.MapUpdate.DataInstance.Alive && Result244 && Result246;
	Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse001.CollisionID = Constant336;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionValidBool = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Collides;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionWorldPosition = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactPosition;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionNormal = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_ImpactNormal;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedFriction = Constant342;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedRestitution = Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRestitutionCoeffiecient;
	Context.MapUpdate.DataInstance.Alive = Result247;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.DepthBasedCollisionParticleOccluded = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Occluded;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.ParticleOnScreen = Collision_CollisionQueryAndResponse001_SceneDepthTest003_Emitter_Func_Output_Onscreentest;
	float3 Constant343 = float3(0,0,1);
	float3 Constant344 = float3(0,0,-1e+16);
	float3 PlaneNormal_IfResult1;
	float3 PlanePivotPoint_IfResult1;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionValidBool)
	{
	PlaneNormal_IfResult1 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionNormal;
	PlanePivotPoint_IfResult1 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionWorldPosition;
	}
	else
	{
	PlaneNormal_IfResult1 = Constant343;
	PlanePivotPoint_IfResult1 = Constant344;
	}
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlaneNormal = PlaneNormal_IfResult1;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlanePivotPoint = PlanePivotPoint_IfResult1;
	bool PlaneSphereCollisionDetection_Func_Output_Collides1;
	float3 PlaneSphereCollisionDetection_Func_Output_IntersectionLocation1;
	float3 PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation1;
	float3 PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation1;
	float PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision1;
	float PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision1;
	float PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision1;
	float PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision1;
	float PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane1;
	PlaneSphereCollisionDetection_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlaneNormal, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlanePivotPoint, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceOrigin, Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate, Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius, Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime, Context.MapUpdate.Collision.CollisionQueryAndResponse001.MaxIntersectionCorrectionDistance, PlaneSphereCollisionDetection_Func_Output_Collides1, PlaneSphereCollisionDetection_Func_Output_IntersectionLocation1, PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation1, PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation1, PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision1, PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision1, PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision1, PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision1, PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane1, Context);
	Context.MapUpdate.Transient.CollisionWorldPosition = PlaneSphereCollisionDetection_Func_Output_IntersectionLocation1;
	Context.MapUpdate.Transient.CollisionParticleWorldPosition = PlaneSphereCollisionDetection_Func_Output_PreASC45IntersectionSphereCenterLocation1;
	Context.MapUpdate.Transient.CollisionParticleRelativeCollisionLocation = PlaneSphereCollisionDetection_Func_Output_InitialPositionRelativeCollisionLocation1;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTickDeltaForThisCollisionUpdate = PlaneSphereCollisionDetection_Func_Output_TimeElapsedToCollision1;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePhysicsDeltaTime = PlaneSphereCollisionDetection_Func_Output_RemainingTimePostCollision1;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePercentageOfTickDedicatedToUpdatingPosition = PlaneSphereCollisionDetection_Func_Output_PercentageofTimeUsedToPerformCollision1;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.CollisionPenetrationDistance = PlaneSphereCollisionDetection_Func_Output_InitialDistanceBetweenTheSphereASC39sSurfaceandtheCollision1;
	Context.MapUpdate.Transient.CollisionDistanceToCollision = PlaneSphereCollisionDetection_Func_Output_UninterruptedAnimatedSphereASC39sDistancetoCollisionPlane1;
	float Constant345 = 0;
	bool Result248 = NiagaraAll(Context.MapUpdate.Transient.CollisionDistanceToCollision <= Constant345);
	bool Result249 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionEnabled && Result248;
	bool Result250 = Result249 || Context.MapUpdate.Particles.HasCollided;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.PhysicsCollidesThisFrame = Result249;
	Context.MapUpdate.Particles.HasCollided = Result250;
	float3 Result251 = -(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlaneNormal);
	float Result252 = dot(Result251,Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate);
	float Result253 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime * Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	float3 Result254 = Result253 * Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleInitialForceDividedByMass;
	float Result255 = dot(Result251,Result254);
	float Result256 = Result252 - Result255;
	float Constant346 = 0.1;
	bool Result257 = NiagaraAll(Result256 < Constant346);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleRemoveRestitution = Result257;
	float3 Result258 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate / Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	float float_IfResult9;
	if(Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.PhysicsCollidesThisFrame)
	{
	float_IfResult9 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePhysicsDeltaTime;
	}
	else
	{
	float_IfResult9 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime;
	}
	float Constant347 = 0;
	float float_IfResult10;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleRemoveRestitution)
	{
	float_IfResult10 = Constant347;
	}
	else
	{
	float_IfResult10 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedRestitution;
	}
	Context.MapUpdate.Transient.CollisionValid = Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.PhysicsCollidesThisFrame;
	Context.MapUpdate.Transient.CollisionSize = Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius;
	Context.MapUpdate.Transient.CollisionNormal = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlaneNormal;
	Context.MapUpdate.Transient.CollisionVelocity = Result258;
	Context.MapUpdate.Transient.CollisionFriction = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedFriction;
	Context.MapUpdate.Transient.PhysicsDeltaTime = float_IfResult9;
	Context.MapUpdate.Transient.CollisionRestitution = float_IfResult10;
	bool Result259 = !Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleRemoveRestitution;
	bool Result260 = Result259 && Context.MapUpdate.Collision.CollisionQueryAndResponse001.RandomizeCollisionNormal;
	float Constant348 = 1;
	float3 RandomizeCollisionNormals_Func_Output_Ouput1;
	RandomizeCollisionNormals_Func_(Context.MapUpdate.Transient.CollisionNormal, Constant348, Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionNormalRandomizationPercentage, RandomizeCollisionNormals_Func_Output_Ouput1, Context);
	float3 Vector_IfResult11;
	if(Result260)
	{
	Vector_IfResult11 = RandomizeCollisionNormals_Func_Output_Ouput1;
	}
	else
	{
	Vector_IfResult11 = Context.MapUpdate.Transient.CollisionNormal;
	}
	float3 ReflectVector_Func_Output_Reflected1;
	ReflectVector_Func_(Context.MapUpdate.Transient.CollisionVelocity, Vector_IfResult11, ReflectVector_Func_Output_Reflected1, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocity = ReflectVector_Func_Output_Reflected1;
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters3;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters3;
	CentimeterMeterConversion_Func_(Context.MapUpdate.Transient.CollisionVelocity, CentimeterMeterConversion_Func_Output_CentimeterstoMeters3, CentimeterMeterConversion_Func_Output_MeterstoCentimeters3, Context);
	float3 Result261 = Context.MapUpdate.Particles.Mass * CentimeterMeterConversion_Func_Output_CentimeterstoMeters3;
	float Constant349 = -1;
	float3 Result262 = Result261 * Constant349;
	float Result263 = dot(Result262,Context.MapUpdate.Transient.CollisionNormal);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleNormalForceInNewtons = Result263;
	float3 ProjectVectorOnPlane_Func_Output_Ouput1;
	ProjectVectorOnPlane_Func_(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocity, Context.MapUpdate.Transient.CollisionNormal, ProjectVectorOnPlane_Func_Output_Ouput1, Context);
	float3 Constant350 = float3(0,0,0);
	float Constant351 = 1e-05;
	float Constant352 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction8;
	float DirectionAndLengthSafe_Func_Output_Length8;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold8;
	DirectionAndLengthSafe_Func_(ProjectVectorOnPlane_Func_Output_Ouput1, Constant350, Constant351, Constant352, DirectionAndLengthSafe_Func_Output_Direction8, DirectionAndLengthSafe_Func_Output_Length8, DirectionAndLengthSafe_Func_Output_BelowThreshold8, Context);
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters4;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters4;
	CentimeterMeterConversion_Func_(ProjectVectorOnPlane_Func_Output_Ouput1, CentimeterMeterConversion_Func_Output_CentimeterstoMeters4, CentimeterMeterConversion_Func_Output_MeterstoCentimeters4, Context);
	float3 Result264 = CentimeterMeterConversion_Func_Output_CentimeterstoMeters4 * Context.MapUpdate.Particles.Mass;
	float float_IfResult11;
	if(Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleRemoveRestitution)
	{
	float_IfResult11 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.DynamicFrictionCoefficient;
	}
	else
	{
	float_IfResult11 = Context.MapUpdate.Collision.CollisionQueryAndResponse001.BounceCollisionFriction;
	}
	float3 Result265 = DirectionAndLengthSafe_Func_Output_Direction8 * float_IfResult11 * Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleNormalForceInNewtons;
	float3 Result266 = Result264 - Result265;
	float3 Constant353 = float3(0,0,0);
	float Constant354 = 1e-05;
	float Constant355 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction9;
	float DirectionAndLengthSafe_Func_Output_Length9;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold9;
	DirectionAndLengthSafe_Func_(Result266, Constant353, Constant354, Constant355, DirectionAndLengthSafe_Func_Output_Direction9, DirectionAndLengthSafe_Func_Output_Length9, DirectionAndLengthSafe_Func_Output_BelowThreshold9, Context);
	float Result267 = dot(DirectionAndLengthSafe_Func_Output_Direction8,DirectionAndLengthSafe_Func_Output_Direction9);
	float Constant356 = 0;
	bool Result268 = NiagaraAll(Result267 <= Constant356);
	float3 Vector_IfResult12;
	if(Result268)
	{
	Vector_IfResult12 = Result264;
	}
	else
	{
	Vector_IfResult12 = Result265;
	}
	float Constant357 = -1;
	float3 Result269 = Vector_IfResult12 * Constant357;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVectorInNewtons = Result269;
	float3 Result270 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVectorInNewtons / Context.MapUpdate.Particles.Mass;
	float3 CentimeterMeterConversion_Func_Output_CentimeterstoMeters5;
	float3 CentimeterMeterConversion_Func_Output_MeterstoCentimeters5;
	CentimeterMeterConversion_Func_(Result270, CentimeterMeterConversion_Func_Output_CentimeterstoMeters5, CentimeterMeterConversion_Func_Output_MeterstoCentimeters5, Context);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVelocityVector = CentimeterMeterConversion_Func_Output_MeterstoCentimeters5;
	float3 Result271 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocity + Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVelocityVector;
	float Result272 = dot(Context.MapUpdate.Transient.CollisionNormal,Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocity);
	float3 Result273 = Context.MapUpdate.Transient.CollisionNormal * Result272;
	float Result274 = 1 - Context.MapUpdate.Transient.CollisionRestitution;
	float3 Result275 = Result273 * Result274;
	float3 Result276 = Result271 - Result275;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocityWithFrictionApplied = Result276;
	float3 Particleposition_IfResult1;
	if(Context.MapUpdate.Transient.CollisionValid)
	{
	Particleposition_IfResult1 = Context.MapUpdate.Transient.CollisionParticleWorldPosition;
	}
	else
	{
	Particleposition_IfResult1 = Context.MapUpdate.Particles.Position;
	}
	Context.MapUpdate.Particles.Position = Particleposition_IfResult1;
	float3 Constant358 = float3(0,0,1);
	float Constant359 = 1e-05;
	float Constant360 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction10;
	float DirectionAndLengthSafe_Func_Output_Length10;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold10;
	DirectionAndLengthSafe_Func_(Context.MapUpdate.Transient.CollisionVelocity, Constant358, Constant359, Constant360, DirectionAndLengthSafe_Func_Output_Direction10, DirectionAndLengthSafe_Func_Output_Length10, DirectionAndLengthSafe_Func_Output_BelowThreshold10, Context);
	float Result277 = dot(DirectionAndLengthSafe_Func_Output_Direction10,Context.MapUpdate.Transient.CollisionNormal);
	float Constant361 = 0;
	bool Result278 = NiagaraAll(Result277 < Constant361);
	bool Result279 = Result278 && Context.MapUpdate.Transient.CollisionValid;
	float3 Constant362 = float3(0,0,0);
	float3 physicsforce_IfResult1;
	float3 Velocity_IfResult1;
	if(Result279)
	{
	physicsforce_IfResult1 = Constant362;
	Velocity_IfResult1 = Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocityWithFrictionApplied;
	}
	else
	{
	physicsforce_IfResult1 = Context.MapUpdate.Transient.PhysicsForce;
	Velocity_IfResult1 = Context.MapUpdate.Particles.Velocity;
	}
	Context.MapUpdate.Transient.PhysicsForce = physicsforce_IfResult1;
	Context.MapUpdate.Particles.Velocity = Velocity_IfResult1;
}

void Collision_TransformPosition001_Emitter_Func_(float3 In_InPosition, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutPosition, inout FSimulationContext Context)
{
	bool Constant383 = false;
	float4x4 Matrix_IfResult5;
	float4x4 Matrix001_IfResult4;
	if(In_ApplyScale)
	{
	Matrix_IfResult5 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult4 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult5 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult4 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal4;
	float4x4 TransformBase_Func_Output_OutTransform4;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult5, Matrix001_IfResult4, Constant383, TransformBase_Func_Output_bUseOriginal4, TransformBase_Func_Output_OutTransform4, Context);
	float3 Result308 = mul(float4(In_InPosition,1.0),TransformBase_Func_Output_OutTransform4).xyz;
	float3 Vector_IfResult15;
	if(TransformBase_Func_Output_bUseOriginal4)
	{
	Vector_IfResult15 = In_InPosition;
	}
	else
	{
	Vector_IfResult15 = Result308;
	}
	Out_OutPosition = Vector_IfResult15;
}

void Collision_TransformVector001_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context)
{
	bool Constant387 = false;
	float4x4 Matrix_IfResult6;
	float4x4 Matrix001_IfResult5;
	if(In_ApplyScale)
	{
	Matrix_IfResult6 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult5 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult6 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult5 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal5;
	float4x4 TransformBase_Func_Output_OutTransform5;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult6, Matrix001_IfResult5, Constant387, TransformBase_Func_Output_bUseOriginal5, TransformBase_Func_Output_OutTransform5, Context);
	float3 Result309 = mul(float4(In_InVector,0.0),TransformBase_Func_Output_OutTransform5).xyz;
	float3 Vector_IfResult16;
	if(TransformBase_Func_Output_bUseOriginal5)
	{
	Vector_IfResult16 = In_InVector;
	}
	else
	{
	Vector_IfResult16 = Result309;
	}
	Out_OutVector = Vector_IfResult16;
}

void Collision_TransformVector_Emitter_Func_(float3 In_InVector, int In_SourceSpace, int In_DestinationSpace, bool In_ApplyScale, out float3 Out_OutVector, inout FSimulationContext Context)
{
	bool Constant391 = false;
	float4x4 Matrix_IfResult7;
	float4x4 Matrix001_IfResult6;
	if(In_ApplyScale)
	{
	Matrix_IfResult7 = Context.MapUpdate.Engine.Owner.SystemLocalToWorld;
	Matrix001_IfResult6 = Context.MapUpdate.Engine.Owner.SystemWorldToLocal;
	}
	else
	{
	Matrix_IfResult7 = Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale;
	Matrix001_IfResult6 = Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale;
	}
	bool TransformBase_Func_Output_bUseOriginal6;
	float4x4 TransformBase_Func_Output_OutTransform6;
	TransformBase_Func_(In_SourceSpace, In_DestinationSpace, Matrix_IfResult7, Matrix001_IfResult6, Constant391, TransformBase_Func_Output_bUseOriginal6, TransformBase_Func_Output_OutTransform6, Context);
	float3 Result310 = mul(float4(In_InVector,0.0),TransformBase_Func_Output_OutTransform6).xyz;
	float3 Vector_IfResult17;
	if(TransformBase_Func_Output_bUseOriginal6)
	{
	Vector_IfResult17 = In_InVector;
	}
	else
	{
	Vector_IfResult17 = Result310;
	}
	Out_OutVector = Vector_IfResult17;
}

void Collision_Emitter_Func_(inout FSimulationContext Context)
{
	float CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_Output_Radius;
	CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_(Context.MapUpdate.Particles.SpriteSize, CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_Output_Radius, Context);
	float Result66 = Context.MapUpdate.Constants.Emitter.Collision.ParticleRadiusScale * CalculateRadiusFromSpriteSize_Particle_Method_NewEnumerator0_Func_Output_Radius;
	Context.MapUpdate.Local.Collision.ModuleParticleRadius = Result66;
	int Constant198 = 0;
	int Constant199 = 1;
	bool Constant200 = false;
	float3 Collision_TransformPosition_Emitter_Func_Output_OutPosition;
	Collision_TransformPosition_Emitter_Func_(Context.MapUpdate.Particles.Position, Constant198, Constant199, Constant200, Collision_TransformPosition_Emitter_Func_Output_OutPosition, Context);
	int Constant202 = 0;
	int Constant203 = 1;
	bool Constant204 = false;
	float3 Collision_TransformVector002_Emitter_Func_Output_OutVector;
	Collision_TransformVector002_Emitter_Func_(Context.MapUpdate.Transient.PhysicsForce, Constant202, Constant203, Constant204, Collision_TransformVector002_Emitter_Func_Output_OutVector, Context);
	int Constant206 = 0;
	int Constant207 = 1;
	bool Constant208 = false;
	float3 Collision_TransformVector003_Emitter_Func_Output_OutVector;
	Collision_TransformVector003_Emitter_Func_(Context.MapUpdate.Particles.Velocity, Constant206, Constant207, Constant208, Collision_TransformVector003_Emitter_Func_Output_OutVector, Context);
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousPosition = Collision_TransformPosition_Emitter_Func_Output_OutPosition;
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousForce = Collision_TransformVector002_Emitter_Func_Output_OutVector;
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousVelocity = Collision_TransformVector003_Emitter_Func_Output_OutVector;
	Context.MapUpdate.Particles.Position = Collision_TransformPosition_Emitter_Func_Output_OutPosition;
	Context.MapUpdate.Transient.PhysicsForce = Collision_TransformVector002_Emitter_Func_Output_OutVector;
	Context.MapUpdate.Particles.Velocity = Collision_TransformVector003_Emitter_Func_Output_OutVector;
	float Constant210 = -1e+07;
	float Constant211 = 0;
	float float_IfResult2;
	if(Context.MapUpdate.Collision.CorrectInterpenetration)
	{
	float_IfResult2 = Constant210;
	}
	else
	{
	float_IfResult2 = Constant211;
	}
	Context.MapUpdate.Collision.CollisionQueryAndResponse.DynamicFrictionCoefficient = Context.MapUpdate.Constants.Emitter.Collision.Friction;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.DynamicFrictionCoefficient = Context.MapUpdate.Constants.Emitter.Collision.Friction;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.StaticFrictionCoefficient = Context.MapUpdate.Constants.Emitter.Collision.StaticFriction;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.StaticFrictionCoefficient = Context.MapUpdate.Constants.Emitter.Collision.StaticFriction;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.StaticFrictionEngagementSpeed = Context.MapUpdate.Constants.Emitter.Collision.StaticFrictionEngagementSpeed;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.StaticFrictionEngagementSpeed = Context.MapUpdate.Constants.Emitter.Collision.StaticFrictionEngagementSpeed;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius = Context.MapUpdate.Local.Collision.ModuleParticleRadius;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius = Context.MapUpdate.Local.Collision.ModuleParticleRadius;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRestitutionCoeffiecient = Context.MapUpdate.Constants.Emitter.Collision.Restitution;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRestitutionCoeffiecient = Context.MapUpdate.Constants.Emitter.Collision.Restitution;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionNormalRandomizationPercentage = Context.MapUpdate.Constants.Emitter.Collision.RandomizeCollisionNormal;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionNormalRandomizationPercentage = Context.MapUpdate.Constants.Emitter.Collision.RandomizeCollisionNormal;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionEnabled = Context.MapUpdate.Collision.CollisionEnabled;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionEnabled = Context.MapUpdate.Collision.CollisionEnabled;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.RandomizeCollisionNormal = Context.MapUpdate.Collision.RandomizeCollisionNormalVector;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.RandomizeCollisionNormal = Context.MapUpdate.Collision.RandomizeCollisionNormalVector;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.UpdateRotationalVelocity = Context.MapUpdate.Local.Collision.UpdateMeshRotation;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.UpdateRotationalVelocity = Context.MapUpdate.Local.Collision.UpdateMeshRotation;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.BounceCollisionFriction = Context.MapUpdate.Constants.Emitter.Collision.FrictionDuringaBounce;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.BounceCollisionFriction = Context.MapUpdate.Constants.Emitter.Collision.FrictionDuringaBounce;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.MaxIntersectionCorrectionDistance = float_IfResult2;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.MaxIntersectionCorrectionDistance = float_IfResult2;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.AllowOffscreenDepthBufferParticlesToLive = Context.MapUpdate.Collision.AllowOffscreenDepthBufferCollisionParticlesToLiveAfteraBounce;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.AllowOffscreenDepthBufferParticlesToLive = Context.MapUpdate.Collision.AllowOffscreenDepthBufferCollisionParticlesToLiveAfteraBounce;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.KillOccludedParticles = Context.MapUpdate.Collision.KillOccludedParticles;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.KillOccludedParticles = Context.MapUpdate.Collision.KillOccludedParticles;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.DeltaTime = Context.MapUpdate.Transient.PhysicsDeltaTime;
	float3 Constant212 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceOrigin = Constant212;
	float3 Constant213 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleForceContribution = Constant213;
	float3 Constant214 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleAttemptedMovementThisUpdate = Constant214;
	float3 Constant215 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleInitialForceDividedByMass = Constant215;
	float Constant216 = 1;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.TraceVectorLengthMultiplier = Constant216;
	float Constant217 = 1e+10;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.MaxTraceLength = Constant217;
	float3 Constant218 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldStart = Constant218;
	float3 Constant219 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleTraceWorldEnd = Constant219;
	float Constant220 = 50;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.DepthBufferBackfaceThickness = Constant220;
	bool Constant221 = (false);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionValidBool = Constant221;
	float3 Constant222 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionWorldPosition = Constant222;
	float3 Constant223 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedCollisionNormal = Constant223;
	float Constant224 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedFriction = Constant224;
	float Constant225 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReturnedRestitution = Constant225;
	bool Constant226 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.ParticleOnScreen = Constant226;
	float3 Constant227 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlaneNormal = Constant227;
	float3 Constant228 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePlanePivotPoint = Constant228;
	float Constant229 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModulePhysicsDeltaTime = Constant229;
	float Constant230 = (0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.CollisionPenetrationDistance = Constant230;
	bool Constant231 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.PhysicsCollidesThisFrame = Constant231;
	bool Constant232 = false;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleRemoveRestitution = Constant232;
	float3 Constant233 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocity = Constant233;
	float Constant234 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleNormalForceInNewtons = Constant234;
	int Constant235 = 0;
	Context.MapUpdate.Collision.CollisionQueryAndResponse.CPUFrictionMergeType = Constant235;
	float3 Constant236 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVectorInNewtons = Constant236;
	float3 Constant237 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleFrictionForceVelocityVector = Constant237;
	float3 Constant238 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse.ModuleReflectedVelocityWithFrictionApplied = Constant238;
	Collision_CollisionQueryAndResponse_Emitter_Func_(Context);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Valid = Context.MapUpdate.Transient.CollisionValid;
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Normal = Context.MapUpdate.Transient.CollisionNormal;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.DeltaTime = Context.MapUpdate.Transient.PhysicsDeltaTime;
	float3 Constant303 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceOrigin = Constant303;
	float3 Constant304 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleForceContribution = Constant304;
	float3 Constant305 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleAttemptedMovementThisUpdate = Constant305;
	float3 Constant306 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleInitialForceDividedByMass = Constant306;
	float Constant307 = 1;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.TraceVectorLengthMultiplier = Constant307;
	float Constant308 = 1e+10;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.MaxTraceLength = Constant308;
	float3 Constant309 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldStart = Constant309;
	float3 Constant310 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleTraceWorldEnd = Constant310;
	float Constant311 = 50;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.DepthBufferBackfaceThickness = Constant311;
	bool Constant312 = (false);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionValidBool = Constant312;
	float3 Constant313 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionWorldPosition = Constant313;
	float3 Constant314 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedCollisionNormal = Constant314;
	float Constant315 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedFriction = Constant315;
	float Constant316 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReturnedRestitution = Constant316;
	bool Constant317 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.ParticleOnScreen = Constant317;
	float3 Constant318 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlaneNormal = Constant318;
	float3 Constant319 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePlanePivotPoint = Constant319;
	float Constant320 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModulePhysicsDeltaTime = Constant320;
	float Constant321 = (0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.CollisionPenetrationDistance = Constant321;
	bool Constant322 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.PhysicsCollidesThisFrame = Constant322;
	bool Constant323 = false;
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleRemoveRestitution = Constant323;
	float3 Constant324 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocity = Constant324;
	float Constant325 = (0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleNormalForceInNewtons = Constant325;
	int Constant326 = 0;
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.CPUFrictionMergeType = Constant326;
	float3 Constant327 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVectorInNewtons = Constant327;
	float3 Constant328 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleFrictionForceVelocityVector = Constant328;
	float3 Constant329 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.Collision.CollisionQueryAndResponse001.ModuleReflectedVelocityWithFrictionApplied = Constant329;
	Collision_CollisionQueryAndResponse001_Emitter_Func_(Context);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Valid = Context.MapUpdate.Transient.CollisionValid;
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Normal = Context.MapUpdate.Transient.CollisionNormal;
	bool Result280 = Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.ParticleOnScreen && Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.ParticleOnScreen;
	bool Result281 = !Result280;
	float Result282 = Context.MapUpdate.Particles.Collision.OffscreenCounter + Context.MapUpdate.Engine.DeltaTime;
	float Constant363 = 0;
	float float_IfResult12;
	if(Result281)
	{
	float_IfResult12 = Result282;
	}
	else
	{
	float_IfResult12 = Constant363;
	}
	Context.MapUpdate.Particles.Collision.OffscreenCounter = float_IfResult12;
	Context.MapUpdate.Particles.CheckOnScreen = Result280;
	Context.MapUpdate.Particles.CheckScreenCounter = Context.MapUpdate.Particles.Collision.OffscreenCounter;
	bool Result283 = NiagaraAll(Context.MapUpdate.Particles.Collision.OffscreenCounter < Context.MapUpdate.Constants.Emitter.Collision.Maximumtimeoffscreen);
	bool Result284 = Context.MapUpdate.DataInstance.Alive && Result283;
	Context.MapUpdate.DataInstance.Alive = Result284;
	bool Result285 = Context.MapUpdate.Transient.CollisionValid || Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Valid;
	int Constant364 = 1;
	int Result286 = Context.MapUpdate.Particles.NumberOfCollisions + Constant364;
	int int32_IfResult;
	if(Result285)
	{
	int32_IfResult = Result286;
	}
	else
	{
	int32_IfResult = Context.MapUpdate.Particles.NumberOfCollisions;
	}
	Context.MapUpdate.Transient.CollisionValid = Result285;
	Context.MapUpdate.OUTPUT_VAR.Collision.CollisionValid = Result285;
	Context.MapUpdate.Particles.NumberOfCollisions = int32_IfResult;
	float Constant365 = 0;
	bool Result287 = NiagaraAll(Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.CollisionPenetrationDistance < Constant365);
	float Constant366 = 0;
	bool Result288 = NiagaraAll(Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.CollisionPenetrationDistance < Constant366);
	bool Result289 = Result287 && Result288;
	float PenetrationFixed1;
	float PenetrationFixed2;
	PenetrationFixed1 = Result287;
	PenetrationFixed2 = Result288;
	float Result290 = PenetrationFixed1 + PenetrationFixed2;
	float Constant367 = 0.5;
	float Result291 = Result290 * Constant367;
	float Result292 = Context.MapUpdate.Engine.DeltaTime * Context.MapUpdate.Constants.Emitter.Collision.RestStateTimeRange;
	float Result293 = lerp(Context.MapUpdate.Particles.RestCounter,Result291,Result292);
	bool Result294 = NiagaraAll(Result293 > Context.MapUpdate.Constants.Emitter.Collision.PercentageofPenetrationBeforeRest);
	float Constant368 = -1;
	float Result295 = Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse.CollisionPenetrationDistance * Constant368;
	bool Result296 = NiagaraAll(Result295 > Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.CollisionPenetrationDistance);
	float Constant369 = -1;
	float Result297 = Context.MapUpdate.Constants.Emitter.Collision.MaximumPenetrationCorrectionDistance * Constant369;
	bool Result298 = NiagaraAll(Result297 > Context.MapUpdate.OUTPUT_VAR.Collision.CollisionQueryAndResponse001.CollisionPenetrationDistance);
	bool Result299 = Result296 || Result298;
	bool Result300 = Result289 || Result294 || Result299;
	float3 Constant370 = float3(0,0,0);
	float3 Vector_IfResult13;
	if(Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Valid)
	{
	Vector_IfResult13 = Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Normal;
	}
	else
	{
	Vector_IfResult13 = Constant370;
	}
	float3 Constant371 = float3(0,0,0);
	float3 Vector_IfResult14;
	if(Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Valid)
	{
	Vector_IfResult14 = Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Normal;
	}
	else
	{
	Vector_IfResult14 = Constant371;
	}
	float3 Result301 = Vector_IfResult13 + Vector_IfResult14;
	float3 Constant372 = float3(0,0,1);
	float Constant373 = 1e-05;
	float Constant374 = 1;
	float3 DirectionAndLengthSafe_Func_Output_Direction11;
	float DirectionAndLengthSafe_Func_Output_Length11;
	bool DirectionAndLengthSafe_Func_Output_BelowThreshold11;
	DirectionAndLengthSafe_Func_(Result301, Constant372, Constant373, Constant374, DirectionAndLengthSafe_Func_Output_Direction11, DirectionAndLengthSafe_Func_Output_Length11, DirectionAndLengthSafe_Func_Output_BelowThreshold11, Context);
	float Result302 = dot(DirectionAndLengthSafe_Func_Output_Direction11,Context.MapUpdate.Constants.Emitter.Collision.ValidCollisionPlaneNormalForRest);
	float Constant375 = 0.5;
	float Result303 = Context.MapUpdate.Constants.Emitter.Collision.MinimumCollisionNormalASC47RestNormalAlignmentPercentage - Constant375;
	float Constant376 = 2;
	float Result304 = Result303 * Constant376;
	bool Result305 = NiagaraAll(Result302 > Result304);
	bool Result306 = Result300 && Result305;
	bool bool_IfResult2;
	if(Context.MapUpdate.Collision.ControlRestStateViaSurfaceNormal)
	{
	bool_IfResult2 = Result306;
	}
	else
	{
	bool_IfResult2 = Result300;
	}
	bool Result307 = Context.MapUpdate.Collision.EnableRestState && bool_IfResult2 && Context.MapUpdate.Collision.CollisionEnabled;
	float3 Constant377 = float3(0,0,0);
	float3 Constant378 = float3(0,0,0);
	float3 Constant379 = float3(0,0,0);
	float3 Position_IfResult1;
	float3 Velocity_IfResult2;
	float3 Force_IfResult;
	float deltatime_IfResult;
	if(Context.MapUpdate.Transient.CollisionValid)
	{
	Position_IfResult1 = Context.MapUpdate.Particles.Position;
	Velocity_IfResult2 = Context.MapUpdate.Particles.Velocity;
	Force_IfResult = Constant379;
	deltatime_IfResult = Context.MapUpdate.Transient.PhysicsDeltaTime;
	}
	else
	{
	Position_IfResult1 = Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousPosition;
	Velocity_IfResult2 = Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousVelocity;
	Force_IfResult = Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousForce;
	deltatime_IfResult = Context.MapUpdate.Engine.DeltaTime;
	}
	float3 Position_IfResult2;
	float3 Velocity_IfResult3;
	float3 Force_IfResult1;
	float deltatime_IfResult1;
	if(Result307)
	{
	Position_IfResult2 = Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousPosition;
	Velocity_IfResult3 = Constant377;
	Force_IfResult1 = Constant378;
	deltatime_IfResult1 = deltatime_IfResult;
	}
	else
	{
	Position_IfResult2 = Position_IfResult1;
	Velocity_IfResult3 = Velocity_IfResult2;
	Force_IfResult1 = Force_IfResult;
	deltatime_IfResult1 = deltatime_IfResult;
	}
	int Constant380 = 1;
	int Constant381 = 0;
	bool Constant382 = false;
	float3 Collision_TransformPosition001_Emitter_Func_Output_OutPosition;
	Collision_TransformPosition001_Emitter_Func_(Position_IfResult2, Constant380, Constant381, Constant382, Collision_TransformPosition001_Emitter_Func_Output_OutPosition, Context);
	int Constant384 = 1;
	int Constant385 = 0;
	bool Constant386 = false;
	float3 Collision_TransformVector001_Emitter_Func_Output_OutVector;
	Collision_TransformVector001_Emitter_Func_(Velocity_IfResult3, Constant384, Constant385, Constant386, Collision_TransformVector001_Emitter_Func_Output_OutVector, Context);
	int Constant388 = 1;
	int Constant389 = 0;
	bool Constant390 = false;
	float3 Collision_TransformVector_Emitter_Func_Output_OutVector;
	Collision_TransformVector_Emitter_Func_(Force_IfResult1, Constant388, Constant389, Constant390, Collision_TransformVector_Emitter_Func_Output_OutVector, Context);
	bool Result311 = Result294 && Context.MapUpdate.Collision.CollisionEnabled;
	Context.MapUpdate.Particles.Position = Collision_TransformPosition001_Emitter_Func_Output_OutPosition;
	Context.MapUpdate.Particles.Velocity = Collision_TransformVector001_Emitter_Func_Output_OutVector;
	Context.MapUpdate.Transient.PhysicsForce = Collision_TransformVector_Emitter_Func_Output_OutVector;
	Context.MapUpdate.Transient.PhysicsDeltaTime = deltatime_IfResult1;
	Context.MapUpdate.Transient.CollisionIsResting = Result311;
	Context.MapUpdate.Particles.RestCounter = Result293;
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCombinedCollisionNormal = DirectionAndLengthSafe_Func_Output_Direction11;
	Context.MapUpdate.Collision.AdvancedAgingRate = Context.MapUpdate.Constants.Emitter.Collision.AdvancedAgingRate;
}

void SolveForcesAndVelocity_Emitter_Func_(inout FSimulationContext Context)
{
	Context.MapUpdate.Local.SolveForcesAndVelocity.DeltaTime = Context.MapUpdate.SolveForcesAndVelocity.DeltaTime;
	Context.MapUpdate.Local.SolveForcesAndVelocity.PhysicsForce = Context.MapUpdate.SolveForcesAndVelocity.Force;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.IncomingPhysicsForce = Context.MapUpdate.SolveForcesAndVelocity.Force;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity = Context.MapUpdate.SolveForcesAndVelocity.Velocity;
	Context.MapUpdate.Local.SolveForcesAndVelocity.Mass = Context.MapUpdate.SolveForcesAndVelocity.Mass;
	float Constant399 = 0.0001;
	float Result312 = max(Context.MapUpdate.Local.SolveForcesAndVelocity.Mass, Constant399);
	float Result313 = Reciprocal(Result312);
	float3 Result314 = Result313 * Context.MapUpdate.Local.SolveForcesAndVelocity.PhysicsForce;
	Context.MapUpdate.Local.SolveForcesAndVelocity.PhysicsForce = Result314;
	float3 Result315 = Context.MapUpdate.Local.SolveForcesAndVelocity.PhysicsForce * Context.MapUpdate.Local.SolveForcesAndVelocity.DeltaTime + Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity;
	float Constant400 = 0;
	float Result316 = max(Context.MapUpdate.Transient.PhysicsDrag, Constant400);
	float Result317 = Context.MapUpdate.Local.SolveForcesAndVelocity.DeltaTime * Result316;
	float Constant401 = 1;
	float Result318 = Result317 + Constant401;
	float3 Result319 = Result315 / Result318;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity = Result319;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.IncomingPhysicsDrag = Context.MapUpdate.Transient.PhysicsDrag;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity;
	float3 Result320 = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity * Context.MapUpdate.Local.SolveForcesAndVelocity.DeltaTime + Context.MapUpdate.SolveForcesAndVelocity.Position;
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Position = Result320;
	float3 Position_IfResult3;
	float3 Velocity_IfResult4;
	float3 PreviousVelocity_IfResult;
	if(Context.MapUpdate.SolveForcesAndVelocity.WritetoIntrinsicProperties)
	{
	Position_IfResult3 = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Position;
	Velocity_IfResult4 = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity;
	PreviousVelocity_IfResult = Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity;
	}
	else
	{
	Position_IfResult3 = Context.MapUpdate.SolveForcesAndVelocity.Position;
	Velocity_IfResult4 = Context.MapUpdate.SolveForcesAndVelocity.Velocity;
	PreviousVelocity_IfResult = Context.MapUpdate.SolveForcesAndVelocity.PreviousVelocity;
	}
	Context.MapUpdate.Particles.Position = Position_IfResult3;
	Context.MapUpdate.Particles.Velocity = Velocity_IfResult4;
	Context.MapUpdate.Particles.PreviousVelocity = PreviousVelocity_IfResult;
	float3 Constant402 = float3(0,0,0);
	float Constant403 = 0;
	float3 ForceVector_IfResult;
	float Drag_IfResult;
	if(Context.MapUpdate.SolveForcesAndVelocity.WritetoIntrinsicProperties)
	{
	ForceVector_IfResult = Constant402;
	Drag_IfResult = Constant403;
	}
	else
	{
	ForceVector_IfResult = Context.MapUpdate.Transient.PhysicsForce;
	Drag_IfResult = Context.MapUpdate.Transient.PhysicsDrag;
	}
	Context.MapUpdate.Transient.PhysicsForce = ForceVector_IfResult;
	Context.MapUpdate.Transient.PhysicsDrag = Drag_IfResult;
}

float GetSpawnInterpolation()
{
	return HackSpawnInterp;
}


void InterpolateParameters(inout FSimulationContext Context)
{
	int InterpSpawn_Index = ExecIndex();
	float InterpSpawn_SpawnTime = Emitter_InterpSpawnStartDt + (Emitter_SpawnInterval * InterpSpawn_Index);
	float InterpSpawn_UpdateTime = Engine_DeltaTime - InterpSpawn_SpawnTime;
	float InterpSpawn_InvSpawnTime = 1.0 / InterpSpawn_SpawnTime;
	float InterpSpawn_InvUpdateTime = 1.0 / InterpSpawn_UpdateTime;
	float SpawnInterp = InterpSpawn_SpawnTime * Engine_InverseDeltaTime ;
	HackSpawnInterp = SpawnInterp;
	Context.MapSpawn.Interpolation.InterpSpawn_Index = InterpSpawn_Index;
	Context.MapSpawn.Interpolation.InterpSpawn_SpawnTime = InterpSpawn_SpawnTime;
	Context.MapSpawn.Interpolation.InterpSpawn_UpdateTime = InterpSpawn_UpdateTime;
	Context.MapSpawn.Interpolation.InterpSpawn_InvSpawnTime = InterpSpawn_InvSpawnTime;
	Context.MapSpawn.Interpolation.InterpSpawn_InvUpdateTime = InterpSpawn_InvUpdateTime;
	Context.MapSpawn.Interpolation.SpawnInterp = SpawnInterp;
	Context.MapSpawn.Interpolation.Emitter_SpawnInterval = Emitter_SpawnInterval;
	Context.MapSpawn.Interpolation.Emitter_InterpSpawnStartDt = Emitter_InterpSpawnStartDt;
	Context.MapSpawn.Interpolation.Emitter_SpawnGroup = Emitter_SpawnGroup;
	Context.MapSpawn.Engine.Time = lerp(PREV_Engine_Time, Engine_Time, SpawnInterp);
	Context.MapSpawn.Engine.RealTime = lerp(PREV_Engine_RealTime, Engine_RealTime, SpawnInterp);
	Context.MapSpawn.Engine.Owner.TimeSinceRendered = lerp(PREV_Engine_Owner_TimeSinceRendered, Engine_Owner_TimeSinceRendered, SpawnInterp);
	Context.MapSpawn.Engine.Owner.LODDistance = lerp(PREV_Engine_Owner_LODDistance, Engine_Owner_LODDistance, SpawnInterp);
	Context.MapSpawn.Engine.Owner.LODDistanceFraction = lerp(PREV_Engine_Owner_LODDistanceFraction, Engine_Owner_LODDistanceFraction, SpawnInterp);
	Context.MapSpawn.Engine.System.Age = lerp(PREV_Engine_System_Age, Engine_System_Age, SpawnInterp);
	Context.MapSpawn.Engine.Owner.Rotation = lerp(PREV_Engine_Owner_Rotation, Engine_Owner_Rotation, SpawnInterp);
	Context.MapSpawn.Engine.Owner.Position = lerp(PREV_Engine_Owner_Position.xyz, Engine_Owner_Position.xyz, SpawnInterp);
	Context.MapSpawn.Engine.Owner.Velocity = lerp(PREV_Engine_Owner_Velocity.xyz, Engine_Owner_Velocity.xyz, SpawnInterp);
	Context.MapSpawn.Engine.Owner.SystemXAxis = lerp(PREV_Engine_Owner_SystemXAxis.xyz, Engine_Owner_SystemXAxis.xyz, SpawnInterp);
	Context.MapSpawn.Engine.Owner.SystemYAxis = lerp(PREV_Engine_Owner_SystemYAxis.xyz, Engine_Owner_SystemYAxis.xyz, SpawnInterp);
	Context.MapSpawn.Engine.Owner.SystemZAxis = lerp(PREV_Engine_Owner_SystemZAxis.xyz, Engine_Owner_SystemZAxis.xyz, SpawnInterp);
	Context.MapSpawn.Engine.Owner.Scale = lerp(PREV_Engine_Owner_Scale.xyz, Engine_Owner_Scale.xyz, SpawnInterp);
	Context.MapSpawn.Emitter.Age = lerp(PREV_Emitter_Age, Emitter_Age, SpawnInterp);
	Context.MapSpawn.Emitter.AlphaScale = lerp(PREV_Emitter_AlphaScale, Emitter_AlphaScale, SpawnInterp);
	Context.MapSpawn.Engine.DeltaTime = 0.0f;
	Context.MapSpawn.Engine.InverseDeltaTime = 0.0f;
	Context.MapUpdate.Engine.DeltaTime = InterpSpawn_UpdateTime;
	Context.MapUpdate.Engine.InverseDeltaTime = InterpSpawn_InvUpdateTime;
}

void ReadDataSets(inout FSimulationContext Context)
{
}

void WriteDataSets(inout FSimulationContext Context)
{
}

void SimulateMapSpawn(inout FSimulationContext Context)
{


	float Constant = 1;
	Context.MapSpawn.Particles.Lifetime = Constant;
	float4 Constant1 = float4(1,1,1,1);
	Context.MapSpawn.Particles.Color = Constant1;
	float Constant2 = 1;
	Context.MapSpawn.Particles.Mass = Constant2;
	float2 Constant3 = float2(10,10);
	Context.MapSpawn.Particles.SpriteSize = Constant3;
	float Constant4 = 0;
	Context.MapSpawn.Particles.SpriteRotation = Constant4;
	float3 Constant5 = float3(1,1,1);
	Context.MapSpawn.Particles.Scale = Constant5;
	float Constant6 = 0;
	Context.MapSpawn.Particles.MaterialRandom = Constant6;
	float Constant7 = 0;
	Context.MapSpawn.Particles.Age = Constant7;
	float Constant8 = (0.0);
	Context.MapSpawn.Particles.NormalizedAge = Constant8;
	bool Constant9 = false;
	Context.MapSpawn.Particles.SkeletalMeshLocation.FirstFrameBool = Constant9;
	NiagaraRandInfo Constant10 = (NiagaraRandInfo)0;
	Context.MapSpawn.Particles.InitRandom = Constant10;
	NiagaraID Constant11 = (NiagaraID)0;
	Context.MapSpawn.Particles.RibbonID = Constant11;
	float3 Constant12 = float3(0.0, 0.0, 0.0);
	Context.MapSpawn.Particles.NewPosition_Skeletal = Constant12;
	float3 Constant13 = float3(0,0,0);
	Context.MapSpawn.Particles.Velocity = Constant13;
	int Constant14 = (0);
	Context.MapSpawn.Particles.Collision.CollisionQueryAndResponse.CollisionID = Constant14;
	bool Constant15 = false;
	Context.MapSpawn.Particles.HasCollided = Constant15;
	int Constant16 = (0);
	Context.MapSpawn.Particles.Collision.CollisionQueryAndResponse001.CollisionID = Constant16;
	float Constant17 = 0;
	Context.MapSpawn.Particles.Collision.OffscreenCounter = Constant17;
	bool Constant18 = (false);
	Context.MapSpawn.Particles.CheckOnScreen = Constant18;
	float Constant19 = (0.0);
	Context.MapSpawn.Particles.CheckScreenCounter = Constant19;
	int Constant20 = 0;
	Context.MapSpawn.Particles.NumberOfCollisions = Constant20;
	float Constant21 = 0;
	Context.MapSpawn.Particles.RestCounter = Constant21;

	bool Constant22 = false;
	Context.MapSpawn.UniformRangedFloat005.OverrideRandomness = Constant22;
	int Constant23 = 0;
	Context.MapSpawn.UniformRangedFloat005.RandomnessMode = Constant23;
	bool Constant24 = false;
	Context.MapSpawn.UniformRangedFloat005.OverrideSeed = Constant24;
	bool Constant25 = false;
	Context.MapSpawn.UniformRangedFloat005.FixedRandomSeed = Constant25;
	float UniformRangedFloat005_Emitter_Func_Output_UniformRangedFloat;
	UniformRangedFloat005_Emitter_Func_(UniformRangedFloat005_Emitter_Func_Output_UniformRangedFloat, Context);
	Context.MapSpawn.NormalizedAngleToDegrees001.NormalizedAngle = UniformRangedFloat005_Emitter_Func_Output_UniformRangedFloat;
	bool Constant40 = false;
	Context.MapSpawn.UniformRangedFloat004.OverrideRandomness = Constant40;
	int Constant41 = 0;
	Context.MapSpawn.UniformRangedFloat004.RandomnessMode = Constant41;
	bool Constant42 = false;
	Context.MapSpawn.UniformRangedFloat004.OverrideSeed = Constant42;
	bool Constant43 = false;
	Context.MapSpawn.UniformRangedFloat004.FixedRandomSeed = Constant43;
	float UniformRangedFloat004_Emitter_Func_Output_UniformRangedFloat;
	UniformRangedFloat004_Emitter_Func_(UniformRangedFloat004_Emitter_Func_Output_UniformRangedFloat, Context);
	bool Constant46 = true;
	bool Constant47 = true;
	float NormalizedAngleToDegrees001_Emitter_Func_Output_NewOutput;
	NormalizedAngleToDegrees001_Emitter_Func_(NormalizedAngleToDegrees001_Emitter_Func_Output_NewOutput, Context);
	bool Constant49 = false;
	bool Constant50 = false;
	float3 ParticleOwnerPosition_Emitter_Func_Output_OutPosition;
	ParticleOwnerPosition_Emitter_Func_(ParticleOwnerPosition_Emitter_Func_Output_OutPosition, Context);
	bool Constant53 = false;
	bool Constant54 = true;
	bool Constant55 = false;
	Context.MapSpawn.UniformRangedFloat003.OverrideRandomness = Constant55;
	int Constant56 = 0;
	Context.MapSpawn.UniformRangedFloat003.RandomnessMode = Constant56;
	bool Constant57 = false;
	Context.MapSpawn.UniformRangedFloat003.OverrideSeed = Constant57;
	bool Constant58 = false;
	Context.MapSpawn.UniformRangedFloat003.FixedRandomSeed = Constant58;
	float UniformRangedFloat003_Emitter_Func_Output_UniformRangedFloat;
	UniformRangedFloat003_Emitter_Func_(UniformRangedFloat003_Emitter_Func_Output_UniformRangedFloat, Context);
	Context.MapSpawn.InitializeParticle.Mass = UniformRangedFloat004_Emitter_Func_Output_UniformRangedFloat;
	Context.MapSpawn.InitializeParticle.WriteColor = Constant46;
	Context.MapSpawn.InitializeParticle.WriteSpriteRotation = Constant47;
	Context.MapSpawn.InitializeParticle.SpriteRotation = NormalizedAngleToDegrees001_Emitter_Func_Output_NewOutput;
	Context.MapSpawn.InitializeParticle.WritePosition = Constant49;
	Context.MapSpawn.InitializeParticle.Position = ParticleOwnerPosition_Emitter_Func_Output_OutPosition;
	Context.MapSpawn.InitializeParticle.WriteMass = Constant53;
	Context.MapSpawn.InitializeParticle.WriteSpriteSize = Constant54;
	Context.MapSpawn.InitializeParticle.Lifetime = UniformRangedFloat003_Emitter_Func_Output_UniformRangedFloat;
	bool Constant61 = true;
	Context.MapSpawn.InitializeParticle.WriteLifetime = Constant61;
	bool Constant62 = false;
	Context.MapSpawn.InitializeParticle.WriteScale = Constant62;
	float3 InitializeParticle_SimulationPosition_Emitter_Func_Output_OutPosition;
	InitializeParticle_SimulationPosition_Emitter_Func_(InitializeParticle_SimulationPosition_Emitter_Func_Output_OutPosition, Context);
	Context.MapSpawn.Particles.Position = InitializeParticle_SimulationPosition_Emitter_Func_Output_OutPosition;
	bool Constant65 = true;
	Context.MapSpawn.InitializeParticle.WriteMaterialRandom = Constant65;
	float Constant66 = 0;
	float Constant67 = 1;
	int Constant68 = -1;
	int Constant69 = 0;
	bool Constant70 = false;
	float RandomRangeFloat_Func_Output_Result3;
	RandomRangeFloat_Func_(Constant66, Constant67, Constant68, Constant69, Constant70, RandomRangeFloat_Func_Output_Result3, Context);
	Context.MapSpawn.InitializeParticle.MaterialRandom = RandomRangeFloat_Func_Output_Result3;
	EnterStatScope(1 );
	InitializeParticle_Emitter_Func_(Context);
	ExitStatScope( );




	Context.MapSpawn.Particles.PreviousVelocity = Context.MapSpawn.Particles.Velocity;



}
void SimulateMapUpdate(inout FSimulationContext Context)
{

	bool Constant76 = true;
	Context.MapUpdate.DataInstance.Alive = Constant76;
	Context.MapUpdate.UpdateAge.DeltaTime = Context.MapUpdate.Engine.DeltaTime;
	Context.MapUpdate.UpdateAge.Lifetime = Context.MapUpdate.Particles.Lifetime;
	EnterStatScope(2 );
	UpdateAge_Emitter_Func_(Context);
	ExitStatScope( );
	bool Constant80 = false;
	Context.MapUpdate.SkeletalMeshLocation.OverrideRandomness = Constant80;
	bool Constant81 = false;
	Context.MapUpdate.SkeletalMeshLocation.OverrideSeed = Constant81;
	bool Constant82 = false;
	Context.MapUpdate.SkeletalMeshLocation.FixedRandomSeed = Constant82;
	int Constant83 = 0;
	Context.MapUpdate.SkeletalMeshLocation.RandomnessMode = Constant83;
	NiagaraRandInfo Constant84 = (NiagaraRandInfo)0;
	Context.MapUpdate.Local.SkeletalMeshLocation.RandomInfo = Constant84;
	MeshTriCoordinate Constant85 = (MeshTriCoordinate)0;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshTriCoord = Constant85;
	float3 Constant86 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledPosition = Constant86;
	float3 Constant87 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledVelocity = Constant87;
	float3 Constant88 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledNormal = Constant88;
	float3 Constant89 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledBitangent = Constant89;
	float3 Constant90 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledTangent = Constant90;
	float2 Constant91 = float2(0.0, 0.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshUV = Constant91;
	float4 Constant92 = float4(1.0, 1.0, 1.0, 1.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledVertexColor = Constant92;
	float4 Constant93 = float4(0.0, 0.0, 0.0, 1.0);
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledRotation = Constant93;
	bool Constant94 = true;
	Context.MapUpdate.SkeletalMeshLocation.ApplyToParticlePosition = Constant94;
	bool Constant95 = true;
	Context.MapUpdate.SkeletalMeshLocation.UseSampledMeshAttributeasRibbonID = Constant95;
	int Constant96 = 0;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledBoneIndex = Constant96;
	int Constant97 = 0;
	Context.MapUpdate.Local.SkeletalMeshLocation.SampledMeshVertexID = Constant97;
	EnterStatScope(3 );
	SkeletalMeshLocation_Emitter_Func_(Context);
	ExitStatScope( );
	bool Constant113 = false;
	EnterStatScope(4 );
	SampleMeshScript_Skeletal_Emitter_Func_(Context);
	ExitStatScope( );
	float4 Constant148 = float4(1,1,1,1);
	Context.MapUpdate.OUTPUT_VAR.SampleTexture.SampledColor = Constant148;
	Context.MapUpdate.MakeVector3_FromColor001.Color = Context.MapUpdate.OUTPUT_VAR.SampleTexture.SampledColor;
	Context.MapUpdate.ColorFromCurve.CurveIndex = Context.MapUpdate.Particles.NormalizedAge;
	float4 ColorFromCurve_Emitter_Func_Output_Value;
	ColorFromCurve_Emitter_Func_(ColorFromCurve_Emitter_Func_Output_Value, Context);
	float3 MakeVector3_FromColor001_Emitter_Func_Output_Vector;
	MakeVector3_FromColor001_Emitter_Func_(MakeVector3_FromColor001_Emitter_Func_Output_Vector, Context);
	Context.MapUpdate.Color.Color = ColorFromCurve_Emitter_Func_Output_Value;
	Context.MapUpdate.Color.ScaleColor = MakeVector3_FromColor001_Emitter_Func_Output_Vector;
	EnterStatScope(5 );
	Color_Emitter_Func_(Context);
	ExitStatScope( );
	bool Constant149 = false;
	Context.MapUpdate.Collision.EnableRestState = Constant149;
	float Constant150 = (0.0);
	Context.MapUpdate.Local.Collision.ModuleParticleRadius = Constant150;
	float3 Constant151 = float3(0,0,0);
	Context.MapUpdate.Transient.PhysicsForce = Constant151;
	float3 Constant152 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousPosition = Constant152;
	float3 Constant153 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousForce = Constant153;
	float3 Constant154 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.TempPreviousVelocity = Constant154;
	bool Constant155 = true;
	Context.MapUpdate.Collision.CollisionEnabled = Constant155;
	bool Constant156 = false;
	Context.MapUpdate.Collision.RandomizeCollisionNormalVector = Constant156;
	bool Constant157 = false;
	Context.MapUpdate.Local.Collision.UpdateMeshRotation = Constant157;
	float Constant158 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.DynamicFrictionCoefficient = Constant158;
	float Constant159 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.DynamicFrictionCoefficient = Constant159;
	float Constant160 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.StaticFrictionCoefficient = Constant160;
	float Constant161 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.StaticFrictionCoefficient = Constant161;
	float Constant162 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.StaticFrictionEngagementSpeed = Constant162;
	float Constant163 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.StaticFrictionEngagementSpeed = Constant163;
	float Constant164 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRadius = Constant164;
	float Constant165 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRadius = Constant165;
	float Constant166 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.ParticleRestitutionCoeffiecient = Constant166;
	float Constant167 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.ParticleRestitutionCoeffiecient = Constant167;
	float Constant168 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionNormalRandomizationPercentage = Constant168;
	float Constant169 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionNormalRandomizationPercentage = Constant169;
	bool Constant170 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.CollisionEnabled = Constant170;
	bool Constant171 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.CollisionEnabled = Constant171;
	bool Constant172 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.RandomizeCollisionNormal = Constant172;
	bool Constant173 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.RandomizeCollisionNormal = Constant173;
	float Constant174 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.BounceCollisionFriction = Constant174;
	float Constant175 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.BounceCollisionFriction = Constant175;
	bool Constant176 = false;
	Context.MapUpdate.OUTPUT_VAR.ParticleState.FirstFrame = Constant176;
	Context.MapUpdate.Collision.CorrectInterpenetration = Context.MapUpdate.OUTPUT_VAR.ParticleState.FirstFrame;
	float Constant177 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.MaxIntersectionCorrectionDistance = Constant177;
	float Constant178 = (0.0);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.MaxIntersectionCorrectionDistance = Constant178;
	bool Constant179 = false;
	Context.MapUpdate.Collision.AllowOffscreenDepthBufferCollisionParticlesToLiveAfteraBounce = Constant179;
	bool Constant180 = true;
	Context.MapUpdate.Collision.KillOccludedParticles = Constant180;
	bool Constant181 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.AllowOffscreenDepthBufferParticlesToLive = Constant181;
	bool Constant182 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.AllowOffscreenDepthBufferParticlesToLive = Constant182;
	bool Constant183 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse.KillOccludedParticles = Constant183;
	bool Constant184 = (false);
	Context.MapUpdate.Collision.CollisionQueryAndResponse001.KillOccludedParticles = Constant184;
	Context.MapUpdate.Transient.PhysicsDeltaTime = Context.MapUpdate.Engine.DeltaTime;
	float3 Constant185 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Transient.CollisionParticleWorldPosition = Constant185;
	float Constant186 = (0.0);
	Context.MapUpdate.Transient.CollisionDistanceToCollision = Constant186;
	bool Constant187 = (false);
	Context.MapUpdate.Transient.CollisionValid = Constant187;
	float3 Constant188 = float3(0,0,0);
	Context.MapUpdate.Transient.CollisionNormal = Constant188;
	float3 Constant189 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Transient.CollisionVelocity = Constant189;
	float Constant190 = (0.0);
	Context.MapUpdate.Transient.CollisionFriction = Constant190;
	float Constant191 = (0.0);
	Context.MapUpdate.Transient.CollisionRestitution = Constant191;
	bool Constant192 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Valid = Constant192;
	float3 Constant193 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision1Normal = Constant193;
	bool Constant194 = (false);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Valid = Constant194;
	float3 Constant195 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.Collision.ModuleCollision2Normal = Constant195;
	bool Constant196 = false;
	Context.MapUpdate.Collision.ControlRestStateViaSurfaceNormal = Constant196;
	EnterStatScope(6 );
	Collision_Emitter_Func_(Context);
	ExitStatScope( );
	Context.MapUpdate.SolveForcesAndVelocity.DeltaTime = Context.MapUpdate.Transient.PhysicsDeltaTime;
	float Constant392 = (0.0);
	Context.MapUpdate.Local.SolveForcesAndVelocity.DeltaTime = Constant392;
	Context.MapUpdate.SolveForcesAndVelocity.Force = Context.MapUpdate.Transient.PhysicsForce;
	Context.MapUpdate.SolveForcesAndVelocity.Velocity = Context.MapUpdate.Particles.Velocity;
	Context.MapUpdate.SolveForcesAndVelocity.Mass = Context.MapUpdate.Particles.Mass;
	float3 Constant393 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.Local.SolveForcesAndVelocity.PhysicsForce = Constant393;
	float3 Constant394 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Velocity = Constant394;
	float Constant395 = (0.0);
	Context.MapUpdate.Local.SolveForcesAndVelocity.Mass = Constant395;
	float Constant396 = 0;
	Context.MapUpdate.Transient.PhysicsDrag = Constant396;
	Context.MapUpdate.SolveForcesAndVelocity.PreviousVelocity = Context.MapUpdate.Particles.PreviousVelocity;
	Context.MapUpdate.SolveForcesAndVelocity.Position = Context.MapUpdate.Particles.Position;
	float3 Constant397 = float3(0.0, 0.0, 0.0);
	Context.MapUpdate.OUTPUT_VAR.SolveForcesAndVelocity.Position = Constant397;
	bool Constant398 = true;
	Context.MapUpdate.SolveForcesAndVelocity.WritetoIntrinsicProperties = Constant398;
	EnterStatScope(7 );
	SolveForcesAndVelocity_Emitter_Func_(Context);
	ExitStatScope( );



}
#line 3526 "/Engine/Generated/NiagaraEmitterInstance.ush"
#line 1 "/Plugin/FX/Niagara/Private/NiagaraDataInterfaceSkeletalMesh.ush"
#line 13 "/Plugin/FX/Niagara/Private/NiagaraDataInterfaceSkeletalMesh.ush"
struct FDISkelMeshContext
{
	Buffer<uint> MeshIndexBuffer;
	Buffer<float> MeshVertexBuffer;
	Buffer<uint> MeshSkinWeightBuffer;
	Buffer<uint> MeshSkinWeightLookupBuffer;
	Buffer<float4> MeshCurrBonesBuffer;
	Buffer<float4> MeshPrevBonesBuffer;
	Buffer<float4> MeshCurrSamplingBonesBuffer;
    Buffer<float4> MeshPrevSamplingBonesBuffer;
	Buffer<float4> MeshTangentBuffer;
	Buffer<float2> MeshTexCoordBuffer;
    Buffer<float4> MeshColorBuffer;
	Buffer<float> MeshTriangleSamplerProbaBuffer;
	Buffer<uint> MeshTriangleSamplerAliasBuffer;
	uint MeshNumSamplingRegionTriangles;
	uint MeshNumSamplingRegionVertices;
	Buffer<float> MeshSamplingRegionsProbaBuffer;
	Buffer<uint> MeshSamplingRegionsAliasBuffer;
	Buffer<uint> MeshSampleRegionsTriangleIndices;
	Buffer<uint> MeshSampleRegionsVertices;
	Buffer<uint> MeshTriangleMatricesOffsetBuffer;
	uint MeshTriangleCount;
	uint MeshVertexCount;
    uint MeshWeightStride;
	uint MeshSkinWeightIndexSize;
	uint MeshNumTexCoord;
	uint MeshNumWeights;
	int NumBones;
	int NumFilteredBones;
	int NumUnfilteredBones;
	int RandomMaxBone;
	int ExcludeBoneIndex;
	Buffer<uint> FilteredAndUnfilteredBones;
	int NumFilteredSockets;
	int FilteredSocketBoneOffset;
	float4x4 InstanceTransform;
	float4x4 InstancePrevTransform;
	float4 InstanceRotation;
	float4 InstancePrevRotation;
	float InstanceInvDeltaTime;
	bool UniformTriangleSamplingEnable;
	bool UniformSamplingRegionEnabled;
	bool UnlimitedBoneInfluences;
};





float DISKelMesh_Random(uint S1, uint S2, uint S3)
{
	return S3 == 0xffffffff ? NiagaraInternalNoise(S1, S2, S3) : rand(1.0f, S1, S2, S3);
}

struct FDISkelMeshSkinnedVertex
{
	float3 Position;
	float3 PrevPosition;
	float3 TangentX;
	float3 TangentY;
	float3 TangentZ;
};

float3 DISKelMesh_RandomBarycentricCoord(uint Seed1, uint Seed2, uint Seed3)
{
	float r0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	float r1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	float sqrt0 = sqrt(r0);
	float sqrt1 = sqrt(r1);
	return float3(1.0f - sqrt0, sqrt0 * (1.0 - r1), r1 * sqrt0);
}

float3x4 DISkelMesh_GetPrevBoneSkinningMatrix(in FDISkelMeshContext DIContext, uint Bone)
{
    return float3x4(DIContext.MeshPrevBonesBuffer[Bone * 3], DIContext.MeshPrevBonesBuffer[Bone * 3 + 1], DIContext.MeshPrevBonesBuffer[Bone * 3 + 2]);
}

float3x4 DISkelMesh_GetPrevSkinningMatrix(in FDISkelMeshContext DIContext, uint VertexIndex, int4 BlendIndices, float4 BlendWeights)
{

    uint MatrixOffset = DIContext.MeshTriangleMatricesOffsetBuffer[VertexIndex];

	float3x4 Result;
    Result = DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.x) * BlendWeights.x;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.y) * BlendWeights.y;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.z) * BlendWeights.z;
    Result += DISkelMesh_GetPrevBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.w) * BlendWeights.w;
	return Result;
}

float3x4 DISkelMesh_GetCurrBoneSkinningMatrix(in FDISkelMeshContext DIContext, uint Bone)
{
	return float3x4(DIContext.MeshCurrBonesBuffer[Bone * 3], DIContext.MeshCurrBonesBuffer[Bone * 3 + 1], DIContext.MeshCurrBonesBuffer[Bone * 3 + 2]);
}

float3x4 DISkelMesh_GetCurrSkinningMatrix(in FDISkelMeshContext DIContext, uint VertexIndex, int4 BlendIndices, float4 BlendWeights)
{

	uint MatrixOffset = DIContext.MeshTriangleMatricesOffsetBuffer[VertexIndex];

	float3x4 Result;
    Result = DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.x) * BlendWeights.x;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.y) * BlendWeights.y;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.z) * BlendWeights.z;
    Result += DISkelMesh_GetCurrBoneSkinningMatrix(DIContext, MatrixOffset + BlendIndices.w) * BlendWeights.w;
	return Result;
}

int4 DISkelMesh_UnpackIndices4(uint Packed)
{
	return int4(Packed & 0xff, Packed >> 8 & 0xff, Packed >> 16 & 0xff, Packed >> 24 & 0xff);
}

float4 DISkelMesh_UnpackWeights4(uint Packed)
{
	return float4(Packed & 0xff, Packed >> 8 & 0xff, Packed >> 16 & 0xff, Packed >> 24 & 0xff) / 255.0f;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedVertex(in FDISkelMeshContext DIContext, uint VertexIndex)
{

	float3 CurrPosition = float3(DIContext.MeshVertexBuffer[VertexIndex * 3], DIContext.MeshVertexBuffer[VertexIndex * 3 + 1], DIContext.MeshVertexBuffer[VertexIndex * 3 + 2]);
	float3 PrevPosition = CurrPosition;

	float3 TangentX =  (DIContext.MeshTangentBuffer[VertexIndex * 2 ].xyz) ;
	float4 TangentZ =  (DIContext.MeshTangentBuffer[VertexIndex * 2 + 1].xyzw) ;

	if ( DIContext.MeshNumWeights > 0 )
	{
		float3x4 PrevBoneMatrix;
		float3x4 CurrBoneMatrix;
#line 180 "/Plugin/FX/Niagara/Private/NiagaraDataInterfaceSkeletalMesh.ush"
		{
			uint WeightOffset = DIContext.MeshNumWeights == 8 ? 2 : 1;
#line 195 "/Plugin/FX/Niagara/Private/NiagaraDataInterfaceSkeletalMesh.ush"
			int4 BlendIndices = DISkelMesh_UnpackIndices4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride]);
        float4 BlendWeights = DISkelMesh_UnpackWeights4(DIContext.MeshSkinWeightBuffer[VertexIndex * DIContext.MeshWeightStride + WeightOffset]);
			CurrBoneMatrix = DISkelMesh_GetCurrSkinningMatrix(DIContext, VertexIndex, BlendIndices, BlendWeights);
			PrevBoneMatrix = DISkelMesh_GetPrevSkinningMatrix(DIContext, VertexIndex, BlendIndices, BlendWeights);

		}

		CurrPosition = mul(CurrBoneMatrix, float4(CurrPosition, 1.0f)).xyz;
		PrevPosition = mul(PrevBoneMatrix, float4(PrevPosition, 1.0f)).xyz;


		TangentX.xyz = mul(CurrBoneMatrix, float4(TangentX.xyz, 0.0f)).xyz;
		TangentZ.xyz = mul(CurrBoneMatrix, float4(TangentZ.xyz, 0.0f)).xyz;
	}

	FDISkelMeshSkinnedVertex SkinnedVertex;
	SkinnedVertex.Position = CurrPosition;
	SkinnedVertex.PrevPosition = PrevPosition;
	SkinnedVertex.TangentX = TangentX;
	SkinnedVertex.TangentY = cross(TangentZ.xyz, TangentX.xyz);
	SkinnedVertex.TangentZ = TangentZ.xyz;
	return SkinnedVertex;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedPointOnTriangle(in FDISkelMeshContext DIContext, uint TriangleIndex, float3 BaryCoord)
{
	uint IndexBufferOffset = TriangleIndex * 3;
	uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
	uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
	uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];

	FDISkelMeshSkinnedVertex SkinnedVertex0 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex0);
	FDISkelMeshSkinnedVertex SkinnedVertex1 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex1);
	FDISkelMeshSkinnedVertex SkinnedVertex2 = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex2);

	FDISkelMeshSkinnedVertex FinalVertex;
	FinalVertex.Position = (SkinnedVertex0.Position * BaryCoord.x) + (SkinnedVertex1.Position * BaryCoord.y) + (SkinnedVertex2.Position * BaryCoord.z);
	FinalVertex.PrevPosition = (SkinnedVertex0.PrevPosition * BaryCoord.x) + (SkinnedVertex1.PrevPosition * BaryCoord.y) + (SkinnedVertex2.PrevPosition * BaryCoord.z);
	FinalVertex.TangentX = (SkinnedVertex0.TangentX * BaryCoord.x) + (SkinnedVertex1.TangentX * BaryCoord.y) + (SkinnedVertex2.TangentX * BaryCoord.z);
	FinalVertex.TangentY = (SkinnedVertex0.TangentY * BaryCoord.x) + (SkinnedVertex1.TangentY * BaryCoord.y) + (SkinnedVertex2.TangentY * BaryCoord.z);
	FinalVertex.TangentZ = (SkinnedVertex0.TangentZ * BaryCoord.x) + (SkinnedVertex1.TangentZ * BaryCoord.y) + (SkinnedVertex2.TangentZ * BaryCoord.z);

	return FinalVertex;
}

FDISkelMeshSkinnedVertex DISkelMesh_GetSkinnedPointOnTriangleWS(in FDISkelMeshContext DIContext, uint TriangleIndex, float3 BaryCoord)
{
	FDISkelMeshSkinnedVertex FinalVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	FinalVertex.Position = mul(float4(FinalVertex.Position, 1.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.PrevPosition = mul(float4(FinalVertex.PrevPosition, 1.0f), DIContext.InstancePrevTransform).xyz;
	FinalVertex.TangentX = mul(float4(FinalVertex.TangentX, 0.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.TangentY = mul(float4(FinalVertex.TangentY, 0.0f), DIContext.InstanceTransform).xyz;
	FinalVertex.TangentZ = mul(float4(FinalVertex.TangentZ, 0.0f), DIContext.InstanceTransform).xyz;

	return FinalVertex;
}

void DISKelMesh_RandomTriCoord(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);

	[branch]
	if ( !DIContext.UniformTriangleSamplingEnable )
	{

		OutTriangle = min(uint(RandT0 * float(DIContext.MeshTriangleCount)), DIContext.MeshTriangleCount - 1);
	}
	else
	{

		uint TriangleIndex = min(uint(RandT0*float(DIContext.MeshTriangleCount)), DIContext.MeshTriangleCount - 1);
		float TriangleProbability = DIContext.MeshTriangleSamplerProbaBuffer[TriangleIndex];


		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if( RandT1 > TriangleProbability )
		{
			TriangleIndex = DIContext.MeshTriangleSamplerAliasBuffer[TriangleIndex];
		}
		OutTriangle = TriangleIndex;
	}

	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetSkinnedTriangleDataWS(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangleWS(DIContext, TriangleIndex, BaryCoord);
	OutPosition = SkinnedVertex.Position;
	OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = normalize(SkinnedVertex.TangentZ);
	OutBinormal = normalize(SkinnedVertex.TangentY);
	OutTangent = normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleData(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	OutPosition = SkinnedVertex.Position;
	OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = normalize(SkinnedVertex.TangentZ);
	OutBinormal = normalize(SkinnedVertex.TangentY);
	OutTangent = normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleDataInterpolatedWS(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in float Interp, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangleWS(DIContext, TriangleIndex, BaryCoord);
	OutPosition = lerp(SkinnedVertex.PrevPosition, SkinnedVertex.Position, Interp);
	OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = normalize(SkinnedVertex.TangentZ);
	OutBinormal = normalize(SkinnedVertex.TangentY);
	OutTangent = normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetSkinnedTriangleDataInterpolated(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in float Interp, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedPointOnTriangle(DIContext, TriangleIndex, BaryCoord);
	OutPosition = lerp(SkinnedVertex.PrevPosition, SkinnedVertex.Position, Interp);
	OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = normalize(SkinnedVertex.TangentZ);
	OutBinormal = normalize(SkinnedVertex.TangentY);
	OutTangent = normalize(SkinnedVertex.TangentX);
}

void DISKelMesh_GetTriUV(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, in int UVSet, out float2 OutUV)
{
    if (DIContext.MeshNumTexCoord > 0)
	{
        uint IndexBufferOffset = TriangleIndex * 3;
		uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset ];
		uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset+1];
		uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset+2];

        uint Stride = DIContext.MeshNumTexCoord;
        uint SelectedUVSet = clamp((uint) UVSet, 0, DIContext.MeshNumTexCoord - 1);
		float2 UV0 = DIContext.MeshTexCoordBuffer[VertexIndex0 * Stride + SelectedUVSet];
		float2 UV1 = DIContext.MeshTexCoordBuffer[VertexIndex1 * Stride + SelectedUVSet];
		float2 UV2 = DIContext.MeshTexCoordBuffer[VertexIndex2 * Stride + SelectedUVSet];

		OutUV = UV0 * BaryCoord.x + UV1 * BaryCoord.y + UV2 * BaryCoord.z;
	}
	else
	{
		OutUV = 0.0f;
	}
}

void DISKelMesh_RandomTriangle(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int TriangleIndex = min(int(RandT0 * float(DIContext.MeshTriangleCount)), (int)DIContext.MeshTriangleCount - 1);

	[branch]
	if ( DIContext.UniformTriangleSamplingEnable )
	{

		float TriangleProbability = DIContext.MeshTriangleSamplerProbaBuffer[TriangleIndex];


		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if( RandT1 > TriangleProbability )
		{
			TriangleIndex = (int)DIContext.MeshTriangleSamplerAliasBuffer[TriangleIndex];
		}
	}

	OutTriangle = TriangleIndex;
	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetTriangleCount(in FDISkelMeshContext DIContext, out int OutCount)
{
	OutCount = DIContext.MeshTriangleCount;
}

void DISKelMesh_RandomFilteredTriangle(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutTriangle, out float3 OutBaryCoord)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	uint RegionTriangle = min(uint(RandT0 * float(DIContext.MeshNumSamplingRegionTriangles)), DIContext.MeshNumSamplingRegionTriangles - 1);

	[branch]
	if ( DIContext.UniformSamplingRegionEnabled )
	{
		float TriangleProbability = DIContext.MeshSamplingRegionsProbaBuffer[RegionTriangle];
		float RandT1 = DISKelMesh_Random(Seed1, Seed2, Seed3);
		if ( RandT1 > TriangleProbability )
		{
			RegionTriangle = (int)DIContext.MeshSamplingRegionsAliasBuffer[RegionTriangle];
		}
	}
	OutTriangle = (int)DIContext.MeshSampleRegionsTriangleIndices[RegionTriangle];
	OutBaryCoord = DISKelMesh_RandomBarycentricCoord(Seed1, Seed2, Seed3);
}

void DISKelMesh_GetFilteredTriangleCount(in FDISkelMeshContext DIContext, out int OutCount)
{
	OutCount = DIContext.MeshNumSamplingRegionTriangles;
}

void DISKelMesh_GetFilteredTriangleAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int OutTriangle, out float3 OutBaryCoord)
{
	if ( DIContext.MeshNumSamplingRegionTriangles > 0 )
	{
		FilteredIndex = clamp(FilteredIndex, 0, (int)DIContext.MeshNumSamplingRegionTriangles - 1);
		OutTriangle = (int)DIContext.MeshSampleRegionsTriangleIndices[FilteredIndex];
	}
	else
	{
		OutTriangle = 0;
	}
	OutBaryCoord = 1.0f / 3.0f;
}




float4 DISKelMesh_QuatSlerp(float4 Quat1, float4 Quat2, float Slerp)
{
    const float RawCosom = dot(Quat1, Quat2);
    const float Cosom = abs(RawCosom);

    float Scale0, Scale1;
    if (Cosom < 0.9999f)
    {
        const float Omega = acos(Cosom);
        const float InvSin = 1.f / sin(Omega);
        Scale0 = sin((1.f - Slerp) * Omega) * InvSin;
        Scale1 = sin(Slerp * Omega) * InvSin;
    }
    else
    {
        Scale0 = 1.0f - Slerp;
        Scale1 = Slerp;
    }


    Scale1 = RawCosom >= 0.0f ? Scale1 : -Scale1;

    return (Scale0 * Quat1) + (Scale1 * Quat2);
}

float4 DISKelMesh_QuatMul(float4 Q1, float4 Q2)
{
	float4 QOut;
	QOut.x = Q1.w*Q2.x + Q1.x*Q2.w + Q1.y*Q2.z - Q1.z*Q2.y;
	QOut.y = Q1.w*Q2.y - Q1.x*Q2.z + Q1.y*Q2.w + Q1.z*Q2.x;
	QOut.z = Q1.w*Q2.z + Q1.x*Q2.y - Q1.y*Q2.x + Q1.z*Q2.w;
	QOut.w = Q1.w*Q2.w - Q1.x*Q2.x - Q1.y*Q2.y - Q1.z*Q2.z;
	return QOut;
}

void DISkelMesh_GetSkinnedBoneCommon(in FDISkelMeshContext DIContext, in int Bone, in float Interp, in bool bWorldSpace, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    float3 PrevPosition = DIContext.MeshPrevSamplingBonesBuffer[Bone * 2].xyz;
    float4 PrevRotation = DIContext.MeshPrevSamplingBonesBuffer[Bone * 2 + 1];
    float3 CurrPosition = DIContext.MeshCurrSamplingBonesBuffer[Bone * 2].xyz;
    float4 CurrRotation = DIContext.MeshCurrSamplingBonesBuffer[Bone * 2 + 1];

    if (bWorldSpace)
    {
        PrevPosition = mul(float4(PrevPosition, 1), DIContext.InstancePrevTransform).xyz;
        CurrPosition = mul(float4(CurrPosition, 1), DIContext.InstanceTransform).xyz;
		PrevRotation = DISKelMesh_QuatMul(DIContext.InstancePrevRotation, PrevRotation);
		CurrRotation = DISKelMesh_QuatMul(DIContext.InstanceRotation, CurrRotation);
    }
    CurrPosition = lerp(PrevPosition, CurrPosition, Interp);

    OutPosition = CurrPosition;
    OutRotation = DISKelMesh_QuatSlerp(PrevRotation, CurrRotation, Interp);
    OutVelocity = (CurrPosition - PrevPosition) * DIContext.InstanceInvDeltaTime;
}

void DISkelMesh_GetSkinnedBone(in FDISkelMeshContext DIContext, in int Bone, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, 1.0f, false, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneInterpolated(in FDISkelMeshContext DIContext, in int Bone, in float Interp, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, Interp, false, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneWS(in FDISkelMeshContext DIContext, in int Bone, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, 1.0f, true, OutPosition, OutRotation, OutVelocity);
}

void DISkelMesh_GetSkinnedBoneInterpolatedWS(in FDISkelMeshContext DIContext, in int Bone, in float Interp, out float3 OutPosition, out float4 OutRotation, out float3 OutVelocity)
{
    DISkelMesh_GetSkinnedBoneCommon(DIContext, Bone, Interp, true, OutPosition, OutRotation, OutVelocity);
}




void DISkelMesh_GetTriVertices(in FDISkelMeshContext DIContext, in uint TriangleIndex, out int VertexIndex0, out int VertexIndex1, out int VertexIndex2)
{
    uint IndexBufferOffset = TriangleIndex * 3;
    VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
    VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
    VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];
}

void DISkelMesh_GetTriColor(in FDISkelMeshContext DIContext, in uint TriangleIndex, in float3 BaryCoord, out float4 OutColor)
{
    uint IndexBufferOffset = TriangleIndex * 3;
    uint VertexIndex0 = DIContext.MeshIndexBuffer[IndexBufferOffset];
    uint VertexIndex1 = DIContext.MeshIndexBuffer[IndexBufferOffset + 1];
    uint VertexIndex2 = DIContext.MeshIndexBuffer[IndexBufferOffset + 2];
    OutColor = (DIContext.MeshColorBuffer[VertexIndex0] * BaryCoord.x) + (DIContext.MeshColorBuffer[VertexIndex1] * BaryCoord.y) + (DIContext.MeshColorBuffer[VertexIndex2] * BaryCoord.z);
}

void DISkelMesh_GetSkinnedVertex(in FDISkelMeshContext DIContext, in int VertexIndex, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex);
    OutPosition = SkinnedVertex.Position;
    OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = SkinnedVertex.TangentZ;
	OutBinormal = SkinnedVertex.TangentY;
	OutTangent = SkinnedVertex.TangentX;
}

void DISkelMesh_GetSkinnedVertexWS(in FDISkelMeshContext DIContext, in int VertexIndex, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent)
{
    FDISkelMeshSkinnedVertex SkinnedVertex = DISkelMesh_GetSkinnedVertex(DIContext, VertexIndex);
    OutPosition = mul(float4(SkinnedVertex.Position, 1.0f), DIContext.InstanceTransform).xyz;
    float3 PrevPosition = mul(float4(SkinnedVertex.PrevPosition, 1.0f), DIContext.InstancePrevTransform).xyz;
    OutVelocity = (SkinnedVertex.Position - SkinnedVertex.PrevPosition) * DIContext.InstanceInvDeltaTime;
	OutNormal = SkinnedVertex.TangentZ;
	OutBinormal = SkinnedVertex.TangentY;
	OutTangent = SkinnedVertex.TangentX;
}

void DISkelMesh_GetVertexColor(in FDISkelMeshContext DIContext, in int VertexIndex, out float4 OutColor)
{
    OutColor = DIContext.MeshColorBuffer[VertexIndex];
}

void DISkelMesh_GetVertexUV(in FDISkelMeshContext DIContext, in int VertexIndex, in int UVSet, out float2 OutUV)
{
    if (DIContext.MeshNumTexCoord > 0)
    {
        uint Stride = DIContext.MeshNumTexCoord;
        uint SelectedUVSet = clamp((uint) UVSet, 0, DIContext.MeshNumTexCoord - 1);
        OutUV = DIContext.MeshTexCoordBuffer[VertexIndex * Stride + SelectedUVSet];
    }
    else
    {
        OutUV = 0.0f;
    }
}

void DISkelMesh_IsValidVertex(in FDISkelMeshContext DIContext, int Vertex, out bool IsValid)
{
    IsValid = Vertex < (int)DIContext.MeshVertexCount;
}

void DISkelMesh_GetRandomVertex(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutVertex)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	OutVertex = (int)min(uint(RandT0 * float(DIContext.MeshVertexCount)), DIContext.MeshVertexCount - 1);
}

void DISkelMesh_GetVertexCount(in FDISkelMeshContext DIContext, out int VertexCount)
{
	VertexCount = (int)DIContext.MeshVertexCount;
}

void DISkelMesh_IsValidFilteredVertex(in FDISkelMeshContext DIContext, int FilteredIndex, out bool IsValid)
{
	IsValid = FilteredIndex < (int)DIContext.MeshNumSamplingRegionVertices;
}

void DISkelMesh_GetRandomFilteredVertex(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int OutVertex)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int FilteredIndex = (int)min(uint(RandT0 * float(DIContext.MeshNumSamplingRegionVertices)), DIContext.MeshNumSamplingRegionVertices - 1);
	OutVertex = (int)DIContext.MeshSampleRegionsVertices[FilteredIndex];
}

void DISkelMesh_GetFilteredVertexCount(in FDISkelMeshContext DIContext, out int VertexCount)
{
	VertexCount = (int)DIContext.MeshNumSamplingRegionVertices;
}

void DISkelMesh_GetFilteredVertexAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int VertexIndex)
{
	FilteredIndex = clamp(FilteredIndex, 0, (int)DIContext.MeshNumSamplingRegionVertices - 1);
	VertexIndex = (int)DIContext.MeshSampleRegionsVertices[FilteredIndex];
}



void DISkelMesh_IsValidBone(in FDISkelMeshContext DIContext, in int BoneIndex, out bool IsValid)
{
	IsValid = BoneIndex >= 0 && BoneIndex < DIContext.NumBones;
}

void DISkelMesh_RandomBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	Bone = min(int(RandT0 * float(DIContext.RandomMaxBone)), DIContext.RandomMaxBone);
	Bone = Bone != DIContext.ExcludeBoneIndex ? Bone : Bone + 1;
}

void DISkelMesh_GetBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
	Count = DIContext.NumBones;
}

void DISkelMesh_GetFilteredBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumFilteredBones;
}

void DISkelMesh_GetFilteredBoneAt(in FDISkelMeshContext DIContext, in int InBoneIndex, out int Bone)
{
    int BoneIndex = min(InBoneIndex, DIContext.NumFilteredBones - 1);
    Bone = (int)DIContext.FilteredAndUnfilteredBones[BoneIndex];
}

void DISkelMesh_RandomFilteredBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
    int FilteredBone = min(int(RandT0 * float(DIContext.NumFilteredBones)), DIContext.NumFilteredBones - 1);
    Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredBone];
}

void DISkelMesh_GetUnfilteredBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumUnfilteredBones;
}

void DISkelMesh_GetUnfilteredBoneAt(in FDISkelMeshContext DIContext, in int InBoneIndex, out int Bone)
{
    int BoneIndex = min(InBoneIndex, DIContext.NumUnfilteredBones - 1);
    Bone = DIContext.NumFilteredBones > 0 ? (int)DIContext.FilteredAndUnfilteredBones[BoneIndex + DIContext.NumFilteredBones] : BoneIndex;
}

void DISkelMesh_RandomUnfilteredBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	if ( DIContext.NumFilteredBones == 0 )
	{
		Bone = min(int(RandT0 * float(DIContext.RandomMaxBone)), DIContext.RandomMaxBone);
		Bone = Bone != DIContext.ExcludeBoneIndex ? Bone : Bone + 1;
	}
	else
	{
		int UnfilteredBone = min(int(RandT0 * float(DIContext.NumUnfilteredBones)), DIContext.NumUnfilteredBones - 1);
		Bone = DIContext.NumFilteredBones > 0 ? (int)DIContext.FilteredAndUnfilteredBones[UnfilteredBone + DIContext.NumFilteredBones] : UnfilteredBone;
	}
}

void DISkelMesh_GetFilteredSocketCount(in FDISkelMeshContext DIContext, out int Count)
{
    Count = DIContext.NumFilteredSockets;
}

void DISkelMesh_GetFilteredSocketBoneAt(in FDISkelMeshContext DIContext, in int InSocketIndex, out int Bone)
{
    Bone = DIContext.FilteredSocketBoneOffset + clamp(InSocketIndex, 0, DIContext.NumFilteredSockets - 1);
}

void DISkelMesh_RandomFilteredSocket(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int SocketBone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
    SocketBone = DIContext.FilteredSocketBoneOffset + min(int(RandT0 * float(DIContext.NumFilteredSockets)), DIContext.NumFilteredSockets - 1);
}

void DISkelMesh_RandomFilteredSocketOrBone(in FDISkelMeshContext DIContext, uint Seed1, uint Seed2, uint Seed3, out int Bone)
{
	float RandT0 = DISKelMesh_Random(Seed1, Seed2, Seed3);
	int NumFilteredSocketsAndBones = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
    int FilteredIndex = min(int(RandT0 * float(NumFilteredSocketsAndBones)), NumFilteredSocketsAndBones - 1);
	if ( FilteredIndex < DIContext.NumFilteredBones )
	{
		Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredIndex];
	}
	else
	{
		Bone = DIContext.FilteredSocketBoneOffset + FilteredIndex - DIContext.NumFilteredBones;
	}
}

void DISkelMesh_GetFilteredSocketOrBoneCount(in FDISkelMeshContext DIContext, out int Count)
{
	Count = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
}

void DISkelMesh_GetFilteredSocketOrBoneAt(in FDISkelMeshContext DIContext, int FilteredIndex, out int Bone)
{
	int NumFilteredSocketsAndBones = DIContext.NumFilteredBones + DIContext.NumFilteredSockets;
	FilteredIndex = clamp(FilteredIndex, 0, NumFilteredSocketsAndBones - 1);
	if ( FilteredIndex < DIContext.NumFilteredBones )
	{
		Bone = (int)DIContext.FilteredAndUnfilteredBones[FilteredIndex];
	}
	else
	{
		Bone = DIContext.FilteredSocketBoneOffset + FilteredIndex - DIContext.NumFilteredBones;
	}
}
#line 3527 "/Engine/Generated/NiagaraEmitterInstance.ush"
Buffer<uint> MeshIndexBuffer_Emitter_SkeletalMesh ; Buffer<float> MeshVertexBuffer_Emitter_SkeletalMesh ; Buffer<uint> MeshSkinWeightBuffer_Emitter_SkeletalMesh ; Buffer<uint> MeshSkinWeightLookupBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshCurrBonesBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshPrevBonesBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshCurrSamplingBonesBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshPrevSamplingBonesBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshTangentBuffer_Emitter_SkeletalMesh ; Buffer<float2> MeshTexCoordBuffer_Emitter_SkeletalMesh ; Buffer<float4> MeshColorBuffer_Emitter_SkeletalMesh ; Buffer<float> MeshTriangleSamplerProbaBuffer_Emitter_SkeletalMesh ; Buffer<uint> MeshTriangleSamplerAliasBuffer_Emitter_SkeletalMesh ; uint MeshNumSamplingRegionTriangles_Emitter_SkeletalMesh ; uint MeshNumSamplingRegionVertices_Emitter_SkeletalMesh ; Buffer<float> MeshSamplingRegionsProbaBuffer_Emitter_SkeletalMesh ; Buffer<uint> MeshSamplingRegionsAliasBuffer_Emitter_SkeletalMesh ; Buffer<uint> MeshSampleRegionsTriangleIndices_Emitter_SkeletalMesh ; Buffer<uint> MeshSampleRegionsVertices_Emitter_SkeletalMesh ; Buffer<uint> MeshTriangleMatricesOffsetBuffer_Emitter_SkeletalMesh ; uint MeshTriangleCount_Emitter_SkeletalMesh ; uint MeshVertexCount_Emitter_SkeletalMesh ; uint MeshWeightStride_Emitter_SkeletalMesh ; uint MeshSkinWeightIndexSize_Emitter_SkeletalMesh ; uint MeshNumTexCoord_Emitter_SkeletalMesh ; uint MeshNumWeights_Emitter_SkeletalMesh ; int NumBones_Emitter_SkeletalMesh ; int NumFilteredBones_Emitter_SkeletalMesh ; int NumUnfilteredBones_Emitter_SkeletalMesh ; int RandomMaxBone_Emitter_SkeletalMesh ; int ExcludeBoneIndex_Emitter_SkeletalMesh ; Buffer<uint> FilteredAndUnfilteredBones_Emitter_SkeletalMesh ; int NumFilteredSockets_Emitter_SkeletalMesh ; int FilteredSocketBoneOffset_Emitter_SkeletalMesh ; float4x4 InstanceTransform_Emitter_SkeletalMesh ; float4x4 InstancePrevTransform_Emitter_SkeletalMesh ; float4 InstanceRotation_Emitter_SkeletalMesh ; float4 InstancePrevRotation_Emitter_SkeletalMesh ; float InstanceInvDeltaTime_Emitter_SkeletalMesh ; uint EnabledFeatures_Emitter_SkeletalMesh ;
Buffer<uint> MeshIndexBuffer_Particles_SkeletalMesh ; Buffer<float> MeshVertexBuffer_Particles_SkeletalMesh ; Buffer<uint> MeshSkinWeightBuffer_Particles_SkeletalMesh ; Buffer<uint> MeshSkinWeightLookupBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshCurrBonesBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshPrevBonesBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshCurrSamplingBonesBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshPrevSamplingBonesBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshTangentBuffer_Particles_SkeletalMesh ; Buffer<float2> MeshTexCoordBuffer_Particles_SkeletalMesh ; Buffer<float4> MeshColorBuffer_Particles_SkeletalMesh ; Buffer<float> MeshTriangleSamplerProbaBuffer_Particles_SkeletalMesh ; Buffer<uint> MeshTriangleSamplerAliasBuffer_Particles_SkeletalMesh ; uint MeshNumSamplingRegionTriangles_Particles_SkeletalMesh ; uint MeshNumSamplingRegionVertices_Particles_SkeletalMesh ; Buffer<float> MeshSamplingRegionsProbaBuffer_Particles_SkeletalMesh ; Buffer<uint> MeshSamplingRegionsAliasBuffer_Particles_SkeletalMesh ; Buffer<uint> MeshSampleRegionsTriangleIndices_Particles_SkeletalMesh ; Buffer<uint> MeshSampleRegionsVertices_Particles_SkeletalMesh ; Buffer<uint> MeshTriangleMatricesOffsetBuffer_Particles_SkeletalMesh ; uint MeshTriangleCount_Particles_SkeletalMesh ; uint MeshVertexCount_Particles_SkeletalMesh ; uint MeshWeightStride_Particles_SkeletalMesh ; uint MeshSkinWeightIndexSize_Particles_SkeletalMesh ; uint MeshNumTexCoord_Particles_SkeletalMesh ; uint MeshNumWeights_Particles_SkeletalMesh ; int NumBones_Particles_SkeletalMesh ; int NumFilteredBones_Particles_SkeletalMesh ; int NumUnfilteredBones_Particles_SkeletalMesh ; int RandomMaxBone_Particles_SkeletalMesh ; int ExcludeBoneIndex_Particles_SkeletalMesh ; Buffer<uint> FilteredAndUnfilteredBones_Particles_SkeletalMesh ; int NumFilteredSockets_Particles_SkeletalMesh ; int FilteredSocketBoneOffset_Particles_SkeletalMesh ; float4x4 InstanceTransform_Particles_SkeletalMesh ; float4x4 InstancePrevTransform_Particles_SkeletalMesh ; float4 InstanceRotation_Particles_SkeletalMesh ; float4 InstancePrevRotation_Particles_SkeletalMesh ; float InstanceInvDeltaTime_Particles_SkeletalMesh ; uint EnabledFeatures_Particles_SkeletalMesh ;
Buffer<uint> MeshIndexBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float> MeshVertexBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshSkinWeightBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshSkinWeightLookupBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshCurrBonesBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshPrevBonesBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshCurrSamplingBonesBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshPrevSamplingBonesBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshTangentBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float2> MeshTexCoordBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float4> MeshColorBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<float> MeshTriangleSamplerProbaBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshTriangleSamplerAliasBuffer_SampleMeshScript_Skeletal_BotMesh ; uint MeshNumSamplingRegionTriangles_SampleMeshScript_Skeletal_BotMesh ; uint MeshNumSamplingRegionVertices_SampleMeshScript_Skeletal_BotMesh ; Buffer<float> MeshSamplingRegionsProbaBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshSamplingRegionsAliasBuffer_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshSampleRegionsTriangleIndices_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshSampleRegionsVertices_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> MeshTriangleMatricesOffsetBuffer_SampleMeshScript_Skeletal_BotMesh ; uint MeshTriangleCount_SampleMeshScript_Skeletal_BotMesh ; uint MeshVertexCount_SampleMeshScript_Skeletal_BotMesh ; uint MeshWeightStride_SampleMeshScript_Skeletal_BotMesh ; uint MeshSkinWeightIndexSize_SampleMeshScript_Skeletal_BotMesh ; uint MeshNumTexCoord_SampleMeshScript_Skeletal_BotMesh ; uint MeshNumWeights_SampleMeshScript_Skeletal_BotMesh ; int NumBones_SampleMeshScript_Skeletal_BotMesh ; int NumFilteredBones_SampleMeshScript_Skeletal_BotMesh ; int NumUnfilteredBones_SampleMeshScript_Skeletal_BotMesh ; int RandomMaxBone_SampleMeshScript_Skeletal_BotMesh ; int ExcludeBoneIndex_SampleMeshScript_Skeletal_BotMesh ; Buffer<uint> FilteredAndUnfilteredBones_SampleMeshScript_Skeletal_BotMesh ; int NumFilteredSockets_SampleMeshScript_Skeletal_BotMesh ; int FilteredSocketBoneOffset_SampleMeshScript_Skeletal_BotMesh ; float4x4 InstanceTransform_SampleMeshScript_Skeletal_BotMesh ; float4x4 InstancePrevTransform_SampleMeshScript_Skeletal_BotMesh ; float4 InstanceRotation_SampleMeshScript_Skeletal_BotMesh ; float4 InstancePrevRotation_SampleMeshScript_Skeletal_BotMesh ; float InstanceInvDeltaTime_SampleMeshScript_Skeletal_BotMesh ; uint EnabledFeatures_SampleMeshScript_Skeletal_BotMesh ;

Buffer<float> CurveLUT_Emitter_Color_ColorCurve;
float MinTime_Emitter_Color_ColorCurve;
float MaxTime_Emitter_Color_ColorCurve;
float InvTimeRange_Emitter_Color_ColorCurve;
float CurveLUTNumMinusOne_Emitter_Color_ColorCurve;

float TimeToLUTFraction_Emitter_Color_ColorCurve(float T)
{
	return saturate((T - MinTime_Emitter_Color_ColorCurve) * InvTimeRange_Emitter_Color_ColorCurve);
}
float SampleCurve_Emitter_Color_ColorCurve(float T)
{
	return CurveLUT_Emitter_Color_ColorCurve[(uint)T];
}

void RandomTriangle_EmitterSkeletalMesh (NiagaraRandInfo InRandomInfo, out MeshTriCoordinate OutCoord) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Emitter_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Emitter_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Emitter_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Emitter_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Emitter_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Emitter_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Emitter_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Emitter_SkeletalMesh ; DIContext.NumBones = NumBones_Emitter_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Emitter_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Emitter_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Emitter_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Emitter_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Emitter_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Emitter_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Emitter_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Emitter_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Emitter_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Emitter_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Emitter_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Emitter_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Emitter_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Emitter_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Emitter_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Emitter_SkeletalMesh & 0x4;  DISKelMesh_RandomTriangle(DIContext, InRandomInfo.Seed1, InRandomInfo.Seed2, InRandomInfo.Seed3, OutCoord.Tri, OutCoord.BaryCoord); }
void GetSkinnedTriangleDataWSInterpolated_EmitterSkeletalMesh (in MeshTriCoordinate InCoord, in float InInterp, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Emitter_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Emitter_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Emitter_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Emitter_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Emitter_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Emitter_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Emitter_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Emitter_SkeletalMesh ; DIContext.NumBones = NumBones_Emitter_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Emitter_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Emitter_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Emitter_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Emitter_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Emitter_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Emitter_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Emitter_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Emitter_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Emitter_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Emitter_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Emitter_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Emitter_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Emitter_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Emitter_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Emitter_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Emitter_SkeletalMesh & 0x4;  DISKelMesh_GetSkinnedTriangleDataInterpolatedWS(DIContext, InCoord.Tri, InCoord.BaryCoord, InInterp, OutPosition, OutVelocity, OutNormal, OutBinormal, OutTangent); }
void GetTriUV_EmitterSkeletalMesh (in MeshTriCoordinate InCoord, in int InUVSet, out float2 OutUV) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Emitter_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Emitter_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Emitter_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Emitter_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Emitter_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Emitter_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Emitter_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Emitter_SkeletalMesh ; DIContext.NumBones = NumBones_Emitter_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Emitter_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Emitter_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Emitter_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Emitter_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Emitter_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Emitter_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Emitter_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Emitter_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Emitter_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Emitter_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Emitter_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Emitter_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Emitter_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Emitter_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Emitter_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Emitter_SkeletalMesh & 0x4;  DISKelMesh_GetTriUV(DIContext, InCoord.Tri, InCoord.BaryCoord, InUVSet, OutUV); }
void GetTriColor_EmitterSkeletalMesh (in MeshTriCoordinate InCoord, out float4 OutColor) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Emitter_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Emitter_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Emitter_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Emitter_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Emitter_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Emitter_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Emitter_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Emitter_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Emitter_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Emitter_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Emitter_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Emitter_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Emitter_SkeletalMesh ; DIContext.NumBones = NumBones_Emitter_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Emitter_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Emitter_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Emitter_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Emitter_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Emitter_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Emitter_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Emitter_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Emitter_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Emitter_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Emitter_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Emitter_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Emitter_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Emitter_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Emitter_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Emitter_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Emitter_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Emitter_SkeletalMesh & 0x4;  DISkelMesh_GetTriColor(DIContext, InCoord.Tri, InCoord.BaryCoord, OutColor); }
void RandomTriCoord_ParticlesSkeletalMesh (NiagaraRandInfo InRandomInfo, out MeshTriCoordinate OutCoord) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Particles_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Particles_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Particles_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Particles_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Particles_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Particles_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Particles_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Particles_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Particles_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Particles_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Particles_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Particles_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Particles_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Particles_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Particles_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Particles_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Particles_SkeletalMesh ; DIContext.NumBones = NumBones_Particles_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Particles_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Particles_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Particles_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Particles_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Particles_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Particles_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Particles_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Particles_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Particles_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Particles_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Particles_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Particles_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Particles_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Particles_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Particles_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Particles_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Particles_SkeletalMesh & 0x4;  DISKelMesh_RandomTriCoord(DIContext, InRandomInfo.Seed1, InRandomInfo.Seed2, InRandomInfo.Seed3, OutCoord.Tri, OutCoord.BaryCoord); }
void GetSkinnedTriangleDataWS_ParticlesSkeletalMesh (in MeshTriCoordinate InCoord, out float3 OutPosition, out float3 OutVelocity, out float3 OutNormal, out float3 OutBinormal, out float3 OutTangent) {  FDISkelMeshContext DIContext; DIContext.MeshIndexBuffer = MeshIndexBuffer_Particles_SkeletalMesh ; DIContext.MeshVertexBuffer = MeshVertexBuffer_Particles_SkeletalMesh ; DIContext.MeshSkinWeightBuffer = MeshSkinWeightBuffer_Particles_SkeletalMesh ; DIContext.MeshSkinWeightLookupBuffer = MeshSkinWeightLookupBuffer_Particles_SkeletalMesh ; DIContext.MeshCurrBonesBuffer = MeshCurrBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshPrevBonesBuffer = MeshPrevBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshCurrSamplingBonesBuffer = MeshCurrSamplingBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshPrevSamplingBonesBuffer = MeshPrevSamplingBonesBuffer_Particles_SkeletalMesh ; DIContext.MeshTangentBuffer = MeshTangentBuffer_Particles_SkeletalMesh ; DIContext.MeshTexCoordBuffer = MeshTexCoordBuffer_Particles_SkeletalMesh ; DIContext.MeshColorBuffer = MeshColorBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleSamplerProbaBuffer = MeshTriangleSamplerProbaBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleSamplerAliasBuffer = MeshTriangleSamplerAliasBuffer_Particles_SkeletalMesh ; DIContext.MeshNumSamplingRegionTriangles = MeshNumSamplingRegionTriangles_Particles_SkeletalMesh ; DIContext.MeshNumSamplingRegionVertices = MeshNumSamplingRegionVertices_Particles_SkeletalMesh ; DIContext.MeshSamplingRegionsProbaBuffer = MeshSamplingRegionsProbaBuffer_Particles_SkeletalMesh ; DIContext.MeshSamplingRegionsAliasBuffer = MeshSamplingRegionsAliasBuffer_Particles_SkeletalMesh ; DIContext.MeshSampleRegionsTriangleIndices = MeshSampleRegionsTriangleIndices_Particles_SkeletalMesh ; DIContext.MeshSampleRegionsVertices = MeshSampleRegionsVertices_Particles_SkeletalMesh ; DIContext.MeshTriangleMatricesOffsetBuffer = MeshTriangleMatricesOffsetBuffer_Particles_SkeletalMesh ; DIContext.MeshTriangleCount = MeshTriangleCount_Particles_SkeletalMesh ; DIContext.MeshVertexCount = MeshVertexCount_Particles_SkeletalMesh ; DIContext.MeshNumTexCoord = MeshNumTexCoord_Particles_SkeletalMesh ; DIContext.MeshNumWeights = MeshNumWeights_Particles_SkeletalMesh ; DIContext.NumBones = NumBones_Particles_SkeletalMesh ; DIContext.NumFilteredBones = NumFilteredBones_Particles_SkeletalMesh ; DIContext.NumUnfilteredBones = NumUnfilteredBones_Particles_SkeletalMesh ; DIContext.RandomMaxBone = RandomMaxBone_Particles_SkeletalMesh ; DIContext.ExcludeBoneIndex = ExcludeBoneIndex_Particles_SkeletalMesh ; DIContext.FilteredAndUnfilteredBones = FilteredAndUnfilteredBones_Particles_SkeletalMesh ; DIContext.NumFilteredSockets = NumFilteredSockets_Particles_SkeletalMesh ; DIContext.FilteredSocketBoneOffset = FilteredSocketBoneOffset_Particles_SkeletalMesh ; DIContext.MeshWeightStride = MeshWeightStride_Particles_SkeletalMesh ; DIContext.MeshSkinWeightIndexSize = MeshSkinWeightIndexSize_Particles_SkeletalMesh ; DIContext.InstanceTransform = InstanceTransform_Particles_SkeletalMesh ; DIContext.InstancePrevTransform = InstancePrevTransform_Particles_SkeletalMesh ; DIContext.InstanceRotation = InstanceRotation_Particles_SkeletalMesh ; DIContext.InstancePrevRotation = InstancePrevRotation_Particles_SkeletalMesh ; DIContext.InstanceInvDeltaTime = InstanceInvDeltaTime_Particles_SkeletalMesh ; DIContext.UniformTriangleSamplingEnable = EnabledFeatures_Particles_SkeletalMesh & 0x1; DIContext.UniformSamplingRegionEnabled = EnabledFeatures_Particles_SkeletalMesh & 0x2; DIContext.UnlimitedBoneInfluences = EnabledFeatures_Particles_SkeletalMesh & 0x4;  DISKelMesh_GetSkinnedTriangleDataWS(DIContext, InCoord.Tri, InCoord.BaryCoord, OutPosition, OutVelocity, OutNormal, OutBinormal, OutTangent); }
void SampleColorCurve_EmitterColorColorCurve(in float In_X, out float4 Out_Value)
{
	float RemappedX = TimeToLUTFraction_Emitter_Color_ColorCurve(In_X) * CurveLUTNumMinusOne_Emitter_Color_ColorCurve;
	float Prev = floor(RemappedX);
	float Next = Prev < CurveLUTNumMinusOne_Emitter_Color_ColorCurve ? Prev + 1.0 : Prev;
	float Interp = RemappedX - Prev;
	Prev *= 4;
	Next *= 4;
	float4 A = float4(SampleCurve_Emitter_Color_ColorCurve(Prev), SampleCurve_Emitter_Color_ColorCurve(Prev + 1), SampleCurve_Emitter_Color_ColorCurve(Prev + 2), SampleCurve_Emitter_Color_ColorCurve(Prev + 3));
	float4 B = float4(SampleCurve_Emitter_Color_ColorCurve(Next), SampleCurve_Emitter_Color_ColorCurve(Next + 1), SampleCurve_Emitter_Color_ColorCurve(Next + 2), SampleCurve_Emitter_Color_ColorCurve(Next + 3));
	Out_Value = lerp(A, B, Interp);
}
void QuerySceneDepthGPU_CollisionCollisionQueryAndResponseQuery(in float3 In_SamplePos, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
			Out_SceneDepth = -1;
			Out_WorldPos = float3(0.0, 0.0, 0.0);
			Out_WorldNormal = float3(0.0, 0.0, 1.0);
			Out_IsInsideView = true;
			Out_CameraPosWorld.xyz = View_WorldCameraOrigin.xyz;
			float4 SamplePosition = float4(In_SamplePos + View_PreViewTranslation, 1);
			float4 ClipPosition = mul(SamplePosition, View_TranslatedWorldToClip);
			float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

			if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
			{

				float2 ScreenUV = ScreenPosition * View_ScreenPositionScaleBias.xy + View_ScreenPositionScaleBias.wz;
				float SceneDepth = CalcSceneDepth(ScreenUV);
				Out_SceneDepth = SceneDepth;

				Out_WorldPos = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

				Out_WorldNormal = Texture2DSampleLevel(SceneTexturesStruct_GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
			}
			else
			{
				Out_IsInsideView = false;
			}
}

void QuerySceneDepthGPU_CollisionCollisionQueryAndResponse001Query(in float3 In_SamplePos, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
			Out_SceneDepth = -1;
			Out_WorldPos = float3(0.0, 0.0, 0.0);
			Out_WorldNormal = float3(0.0, 0.0, 1.0);
			Out_IsInsideView = true;
			Out_CameraPosWorld.xyz = View_WorldCameraOrigin.xyz;
			float4 SamplePosition = float4(In_SamplePos + View_PreViewTranslation, 1);
			float4 ClipPosition = mul(SamplePosition, View_TranslatedWorldToClip);
			float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

			if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
			{

				float2 ScreenUV = ScreenPosition * View_ScreenPositionScaleBias.xy + View_ScreenPositionScaleBias.wz;
				float SceneDepth = CalcSceneDepth(ScreenUV);
				Out_SceneDepth = SceneDepth;

				Out_WorldPos = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

				Out_WorldNormal = Texture2DSampleLevel(SceneTexturesStruct_GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
			}
			else
			{
				Out_IsInsideView = false;
			}
}


	void FastMatrixToQuaternion_FastPathLibrary(float4x4 Mat, out float4 Quat)
	{
		float tr = Mat[0][0] + Mat[1][1] + Mat[2][2];
		if (tr > 0.0f)
		{
			float InvS = rsqrt(tr + 1.f);
			float s = 0.5f * InvS;

			Quat.x = (Mat[1][2] - Mat[2][1]) * s;
			Quat.y = (Mat[2][0] - Mat[0][2]) * s;
			Quat.z = (Mat[0][1] - Mat[1][0]) * s;
			Quat.w = 0.5f * rcp(InvS);
		}
		else if ( (Mat[0][0] > Mat[1][1]) && (Mat[0][0] > Mat[2][2]) )
		{
			float s = Mat[0][0] - Mat[1][1] - Mat[2][2] + 1.0f;
			float InvS = rsqrt(s);
			s = 0.5f * InvS;

			Quat.x = 0.5f * rcp(InvS);
			Quat.y = (Mat[0][1] + Mat[1][0]) * s;
			Quat.z = (Mat[0][2] + Mat[2][0]) * s;
			Quat.w = (Mat[1][2] - Mat[2][1]) * s;
		}
		else if ( Mat[1][1] > Mat[2][2] )
		{
			float s = Mat[1][1] - Mat[2][2] - Mat[0][0] + 1.0f;
			float InvS = rsqrt(s);
			s = 0.5f * InvS;

			Quat.x = (Mat[1][0] + Mat[0][1]) * s;
			Quat.y = 0.5f * rcp(InvS);
			Quat.z = (Mat[1][2] + Mat[2][1]) * s;
			Quat.w = (Mat[2][0] - Mat[0][2]) * s;

		}
		else
		{
			float s = Mat[2][2] - Mat[0][0] - Mat[1][1] + 1.0f;
			float InvS = rsqrt(s);
			s = 0.5f * InvS;

			Quat.x = (Mat[2][0] + Mat[0][2]) * s;
			Quat.y = (Mat[2][1] + Mat[1][2]) * s;
			Quat.z = 0.5f * rcp(InvS);
			Quat.w = (Mat[0][1] - Mat[1][0]) * s;
		}
	}
void InitConstants(inout FSimulationContext Context)
{
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.Minimum = Constants_Emitter_UniformRangedFloat005_Minimum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.Maximum = Constants_Emitter_UniformRangedFloat005_Maximum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat005.RandomSeed = Constants_Emitter_UniformRangedFloat005_RandomSeed;
	Context.MapSpawn.Emitter.RandomSeed = Emitter_RandomSeed;
	Context.MapSpawn.Engine.System.TickCount = Engine_System_TickCount;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.Minimum = Constants_Emitter_UniformRangedFloat004_Minimum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.Maximum = Constants_Emitter_UniformRangedFloat004_Maximum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat004.RandomSeed = Constants_Emitter_UniformRangedFloat004_RandomSeed;
	Context.MapSpawn.Engine.Owner.Position = Engine_Owner_Position.xyz;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.Minimum = Constants_Emitter_UniformRangedFloat003_Minimum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.Maximum = Constants_Emitter_UniformRangedFloat003_Maximum;
	Context.MapSpawn.Constants.Emitter.UniformRangedFloat003.RandomSeed = Constants_Emitter_UniformRangedFloat003_RandomSeed;
	Context.MapSpawn.Constants.Emitter.InitializeParticle.Color = Constants_Emitter_InitializeParticle_Color;
	Context.MapSpawn.Constants.Emitter.InitializeParticle.SpriteSize = Constants_Emitter_InitializeParticle_SpriteSize.xy;
	Context.MapSpawn.Constants.Emitter.InitializeParticle.MeshScale = Constants_Emitter_InitializeParticle_MeshScale.xyz;
	Context.MapUpdate.Engine.DeltaTime = Engine_DeltaTime;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.RandomSeed = Constants_Emitter_SkeletalMeshLocation_RandomSeed;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SampledUVIndex = Constants_Emitter_SkeletalMeshLocation_SampledUVIndex;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SpawnGroupMask = Constants_Emitter_SkeletalMeshLocation_SpawnGroupMask;
	Context.MapUpdate.Emitter.SpawnGroup = Emitter_SpawnGroup;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.SampledPositionOffset = Constants_Emitter_SkeletalMeshLocation_SampledPositionOffset.xyz;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.OffsetPositionAlongSampledNormal = Constants_Emitter_SkeletalMeshLocation_OffsetPositionAlongSampledNormal;
	Context.MapUpdate.Constants.Emitter.SkeletalMeshLocation.InheritVelocityASC40ScaleASC41 = Constants_Emitter_SkeletalMeshLocation_InheritVelocityASC40ScaleASC41;
	Context.MapUpdate.Emitter.Age = Emitter_Age;
	Context.MapUpdate.Engine.Owner.Position = Engine_Owner_Position.xyz;
	Context.MapUpdate.Engine.Owner.SystemLocalToWorld = Engine_Owner_SystemLocalToWorld;
	Context.MapUpdate.Engine.Owner.SystemWorldToLocal = Engine_Owner_SystemWorldToLocal;
	Context.MapUpdate.Engine.Owner.SystemLocalToWorldNoScale = Engine_Owner_SystemLocalToWorldNoScale;
	Context.MapUpdate.Engine.Owner.SystemWorldToLocalNoScale = Engine_Owner_SystemWorldToLocalNoScale;
	Context.MapUpdate.Emitter.RandomSeed = Emitter_RandomSeed;
	Context.MapUpdate.Engine.System.TickCount = Engine_System_TickCount;
	Context.MapUpdate.Constants.Emitter.Color.ScaleAlpha = Constants_Emitter_Color_ScaleAlpha;
	Context.MapUpdate.Emitter.AlphaScale = Emitter_AlphaScale;
	Context.MapUpdate.Constants.Emitter.Collision.ParticleRadiusScale = Constants_Emitter_Collision_ParticleRadiusScale;
	Context.MapUpdate.Constants.Emitter.Collision.Friction = Constants_Emitter_Collision_Friction;
	Context.MapUpdate.Constants.Emitter.Collision.StaticFriction = Constants_Emitter_Collision_StaticFriction;
	Context.MapUpdate.Constants.Emitter.Collision.StaticFrictionEngagementSpeed = Constants_Emitter_Collision_StaticFrictionEngagementSpeed;
	Context.MapUpdate.Constants.Emitter.Collision.Restitution = Constants_Emitter_Collision_Restitution;
	Context.MapUpdate.Constants.Emitter.Collision.RandomizeCollisionNormal = Constants_Emitter_Collision_RandomizeCollisionNormal;
	Context.MapUpdate.Constants.Emitter.Collision.FrictionDuringaBounce = Constants_Emitter_Collision_FrictionDuringaBounce;
	Context.MapUpdate.Constants.Emitter.Collision.Maximumtimeoffscreen = Constants_Emitter_Collision_Maximumtimeoffscreen;
	Context.MapUpdate.Constants.Emitter.Collision.PercentageofPenetrationBeforeRest = Constants_Emitter_Collision_PercentageofPenetrationBeforeRest;
	Context.MapUpdate.Constants.Emitter.Collision.RestStateTimeRange = Constants_Emitter_Collision_RestStateTimeRange;
	Context.MapUpdate.Constants.Emitter.Collision.MaximumPenetrationCorrectionDistance = Constants_Emitter_Collision_MaximumPenetrationCorrectionDistance;
	Context.MapUpdate.Constants.Emitter.Collision.ValidCollisionPlaneNormalForRest = Constants_Emitter_Collision_ValidCollisionPlaneNormalForRest.xyz;
	Context.MapUpdate.Constants.Emitter.Collision.MinimumCollisionNormalASC47RestNormalAlignmentPercentage = Constants_Emitter_Collision_MinimumCollisionNormalASC47RestNormalAlignmentPercentage;
	Context.MapUpdate.Constants.Emitter.Collision.AdvancedAgingRate = Constants_Emitter_Collision_AdvancedAgingRate;
	Context.MapUpdate.Constants.Emitter.SolveForcesAndVelocity.SpeedLimit = Constants_Emitter_SolveForcesAndVelocity_SpeedLimit;
	Context.MapUpdate.Constants.Emitter.SolveForcesAndVelocity.AccelerationLimit = Constants_Emitter_SolveForcesAndVelocity_AccelerationLimit;
	Context.MapUpdate.Engine.Time = Engine_Time;
	Context.MapUpdate.Engine.InverseDeltaTime = Engine_InverseDeltaTime;
	Context.MapUpdate.Engine.ExecutionCount = Engine_ExecutionCount;
	Context.MapUpdate.Emitter.SpawnRate = Emitter_SpawnRate;
	Context.MapUpdate.Engine.Emitter.TotalSpawnedParticles = Engine_Emitter_TotalSpawnedParticles;
}

void InitSpawnVariables(inout FSimulationContext Context)
{
	Context.MapUpdate.Emitter.SpawnGroup = Emitter_SpawnGroup;

	Context.MapSpawn.Particles.Age = 0.0f;
	Context.MapSpawn.Particles.CheckOnScreen = false;
	Context.MapSpawn.Particles.CheckScreenCounter = 0.0f;
	Context.MapSpawn.Particles.Collision.CollisionQueryAndResponse.CollisionID = 0;
	Context.MapSpawn.Particles.Collision.CollisionQueryAndResponse001.CollisionID = 0;
	Context.MapSpawn.Particles.Collision.OffscreenCounter = 0.0f;
	Context.MapSpawn.Particles.Color.r = 0.0f;
	Context.MapSpawn.Particles.Color.g = 0.0f;
	Context.MapSpawn.Particles.Color.b = 0.0f;
	Context.MapSpawn.Particles.Color.a = 0.0f;
	Context.MapSpawn.Particles.HasCollided = false;
	Context.MapSpawn.Particles.InitRandom.Seed1 = 0;
	Context.MapSpawn.Particles.InitRandom.Seed2 = 0;
	Context.MapSpawn.Particles.InitRandom.Seed3 = 0;
	Context.MapSpawn.Particles.Lifetime = 0.0f;
	Context.MapSpawn.Particles.Mass = 0.0f;
	Context.MapSpawn.Particles.MaterialRandom = 0.0f;
	Context.MapSpawn.Particles.NewPosition_Skeletal.x = 0.0f;
	Context.MapSpawn.Particles.NewPosition_Skeletal.y = 0.0f;
	Context.MapSpawn.Particles.NewPosition_Skeletal.z = 0.0f;
	Context.MapSpawn.Particles.NormalizedAge = 0.0f;
	Context.MapSpawn.Particles.NumberOfCollisions = 0;
	Context.MapSpawn.Particles.Position.x = 0.0f;
	Context.MapSpawn.Particles.Position.y = 0.0f;
	Context.MapSpawn.Particles.Position.z = 0.0f;
	Context.MapSpawn.Particles.PreviousVelocity.x = 0.0f;
	Context.MapSpawn.Particles.PreviousVelocity.y = 0.0f;
	Context.MapSpawn.Particles.PreviousVelocity.z = 0.0f;
	Context.MapSpawn.Particles.RestCounter = 0.0f;
	Context.MapSpawn.Particles.RibbonID.Index = 0;
	Context.MapSpawn.Particles.RibbonID.AcquireTag = 0;
	Context.MapSpawn.Particles.Scale.x = 0.0f;
	Context.MapSpawn.Particles.Scale.y = 0.0f;
	Context.MapSpawn.Particles.Scale.z = 0.0f;
	Context.MapSpawn.Particles.SkeletalMeshLocation.FirstFrameBool = false;
	Context.MapSpawn.Particles.SpriteRotation = 0.0f;
	Context.MapSpawn.Particles.SpriteSize.x = 0.0f;
	Context.MapSpawn.Particles.SpriteSize.y = 0.0f;
	Context.MapSpawn.Particles.UniqueID = 0;
	Context.MapSpawn.Particles.Velocity.x = 0.0f;
	Context.MapSpawn.Particles.Velocity.y = 0.0f;
	Context.MapSpawn.Particles.Velocity.z = 0.0f;

	Context.MapSpawn.DataInstance.Alive=true;
}

void LoadUpdateVariables(inout FSimulationContext Context, int InstanceIdx)
{
		Context.MapUpdate.Particles.Age = InputDataFloat(0, 0, InstanceIdx);
		Context.MapUpdate.Particles.CheckOnScreen = InputDataBool(0, 0, InstanceIdx);
		Context.MapUpdate.Particles.CheckScreenCounter = InputDataFloat(0, 1, InstanceIdx);
		Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse.CollisionID = InputDataInt(0, 1, InstanceIdx);
		Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse001.CollisionID = InputDataInt(0, 2, InstanceIdx);
		Context.MapUpdate.Particles.Collision.OffscreenCounter = InputDataFloat(0, 2, InstanceIdx);
		Context.MapUpdate.Particles.Color.r = InputDataFloat(0, 3, InstanceIdx);
		Context.MapUpdate.Particles.Color.g = InputDataFloat(0, 4, InstanceIdx);
		Context.MapUpdate.Particles.Color.b = InputDataFloat(0, 5, InstanceIdx);
		Context.MapUpdate.Particles.Color.a = InputDataFloat(0, 6, InstanceIdx);
		Context.MapUpdate.Particles.HasCollided = InputDataBool(0, 3, InstanceIdx);
		Context.MapUpdate.Particles.InitRandom.Seed1 = InputDataInt(0, 4, InstanceIdx);
		Context.MapUpdate.Particles.InitRandom.Seed2 = InputDataInt(0, 5, InstanceIdx);
		Context.MapUpdate.Particles.InitRandom.Seed3 = InputDataInt(0, 6, InstanceIdx);
		Context.MapUpdate.Particles.Lifetime = InputDataFloat(0, 7, InstanceIdx);
		Context.MapUpdate.Particles.Mass = InputDataFloat(0, 8, InstanceIdx);
		Context.MapUpdate.Particles.MaterialRandom = InputDataFloat(0, 9, InstanceIdx);
		Context.MapUpdate.Particles.NewPosition_Skeletal.x = InputDataFloat(0, 10, InstanceIdx);
		Context.MapUpdate.Particles.NewPosition_Skeletal.y = InputDataFloat(0, 11, InstanceIdx);
		Context.MapUpdate.Particles.NewPosition_Skeletal.z = InputDataFloat(0, 12, InstanceIdx);
		Context.MapUpdate.Particles.NormalizedAge = InputDataFloat(0, 13, InstanceIdx);
		Context.MapUpdate.Particles.NumberOfCollisions = InputDataInt(0, 7, InstanceIdx);
		Context.MapUpdate.Particles.Position.x = InputDataFloat(0, 14, InstanceIdx);
		Context.MapUpdate.Particles.Position.y = InputDataFloat(0, 15, InstanceIdx);
		Context.MapUpdate.Particles.Position.z = InputDataFloat(0, 16, InstanceIdx);
		Context.MapUpdate.Particles.PreviousVelocity.x = InputDataFloat(0, 17, InstanceIdx);
		Context.MapUpdate.Particles.PreviousVelocity.y = InputDataFloat(0, 18, InstanceIdx);
		Context.MapUpdate.Particles.PreviousVelocity.z = InputDataFloat(0, 19, InstanceIdx);
		Context.MapUpdate.Particles.RestCounter = InputDataFloat(0, 20, InstanceIdx);
		Context.MapUpdate.Particles.RibbonID.Index = InputDataInt(0, 8, InstanceIdx);
		Context.MapUpdate.Particles.RibbonID.AcquireTag = InputDataInt(0, 9, InstanceIdx);
		Context.MapUpdate.Particles.Scale.x = InputDataFloat(0, 21, InstanceIdx);
		Context.MapUpdate.Particles.Scale.y = InputDataFloat(0, 22, InstanceIdx);
		Context.MapUpdate.Particles.Scale.z = InputDataFloat(0, 23, InstanceIdx);
		Context.MapUpdate.Particles.SkeletalMeshLocation.FirstFrameBool = InputDataBool(0, 10, InstanceIdx);
		Context.MapUpdate.Particles.SpriteRotation = InputDataFloat(0, 24, InstanceIdx);
		Context.MapUpdate.Particles.SpriteSize.x = InputDataFloat(0, 25, InstanceIdx);
		Context.MapUpdate.Particles.SpriteSize.y = InputDataFloat(0, 26, InstanceIdx);
		Context.MapUpdate.Particles.UniqueID = InputDataInt(0, 11, InstanceIdx);
		Context.MapUpdate.Particles.Velocity.x = InputDataFloat(0, 27, InstanceIdx);
		Context.MapUpdate.Particles.Velocity.y = InputDataFloat(0, 28, InstanceIdx);
		Context.MapUpdate.Particles.Velocity.z = InputDataFloat(0, 29, InstanceIdx);
		Context.MapUpdate.DataInstance.Alive=true;
}

void ConditionalInterpolateParameters(inout FSimulationContext Context)
{
	InterpolateParameters(Context);
}

void TransferAttributes(inout FSimulationContext Context)
{
		Context.MapUpdate.Particles = Context.MapSpawn.Particles;
}

void StoreUpdateVariables(in FSimulationContext Context)
{
		GStageWritesAlive = true;
		const bool bValid = Context.MapUpdate.DataInstance.Alive;
		const int WriteIndex = OutputIndex(0, true, bValid);
		if (bValid)
		{
			OutputDataFloat(0, 0, WriteIndex, Context.MapUpdate.Particles.Age);
			OutputDataBool(0, 0, WriteIndex, Context.MapUpdate.Particles.CheckOnScreen);
			OutputDataFloat(0, 1, WriteIndex, Context.MapUpdate.Particles.CheckScreenCounter);
			OutputDataInt(0, 1, WriteIndex, Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse.CollisionID);
			OutputDataInt(0, 2, WriteIndex, Context.MapUpdate.Particles.Collision.CollisionQueryAndResponse001.CollisionID);
			OutputDataFloat(0, 2, WriteIndex, Context.MapUpdate.Particles.Collision.OffscreenCounter);
			OutputDataFloat(0, 3, WriteIndex, Context.MapUpdate.Particles.Color.r);
			OutputDataFloat(0, 4, WriteIndex, Context.MapUpdate.Particles.Color.g);
			OutputDataFloat(0, 5, WriteIndex, Context.MapUpdate.Particles.Color.b);
			OutputDataFloat(0, 6, WriteIndex, Context.MapUpdate.Particles.Color.a);
			OutputDataBool(0, 3, WriteIndex, Context.MapUpdate.Particles.HasCollided);
			OutputDataInt(0, 4, WriteIndex, Context.MapUpdate.Particles.InitRandom.Seed1);
			OutputDataInt(0, 5, WriteIndex, Context.MapUpdate.Particles.InitRandom.Seed2);
			OutputDataInt(0, 6, WriteIndex, Context.MapUpdate.Particles.InitRandom.Seed3);
			OutputDataFloat(0, 7, WriteIndex, Context.MapUpdate.Particles.Lifetime);
			OutputDataFloat(0, 8, WriteIndex, Context.MapUpdate.Particles.Mass);
			OutputDataFloat(0, 9, WriteIndex, Context.MapUpdate.Particles.MaterialRandom);
			OutputDataFloat(0, 10, WriteIndex, Context.MapUpdate.Particles.NewPosition_Skeletal.x);
			OutputDataFloat(0, 11, WriteIndex, Context.MapUpdate.Particles.NewPosition_Skeletal.y);
			OutputDataFloat(0, 12, WriteIndex, Context.MapUpdate.Particles.NewPosition_Skeletal.z);
			OutputDataFloat(0, 13, WriteIndex, Context.MapUpdate.Particles.NormalizedAge);
			OutputDataInt(0, 7, WriteIndex, Context.MapUpdate.Particles.NumberOfCollisions);
			OutputDataFloat(0, 14, WriteIndex, Context.MapUpdate.Particles.Position.x);
			OutputDataFloat(0, 15, WriteIndex, Context.MapUpdate.Particles.Position.y);
			OutputDataFloat(0, 16, WriteIndex, Context.MapUpdate.Particles.Position.z);
			OutputDataFloat(0, 17, WriteIndex, Context.MapUpdate.Particles.PreviousVelocity.x);
			OutputDataFloat(0, 18, WriteIndex, Context.MapUpdate.Particles.PreviousVelocity.y);
			OutputDataFloat(0, 19, WriteIndex, Context.MapUpdate.Particles.PreviousVelocity.z);
			OutputDataFloat(0, 20, WriteIndex, Context.MapUpdate.Particles.RestCounter);
			OutputDataInt(0, 8, WriteIndex, Context.MapUpdate.Particles.RibbonID.Index);
			OutputDataInt(0, 9, WriteIndex, Context.MapUpdate.Particles.RibbonID.AcquireTag);
			OutputDataFloat(0, 21, WriteIndex, Context.MapUpdate.Particles.Scale.x);
			OutputDataFloat(0, 22, WriteIndex, Context.MapUpdate.Particles.Scale.y);
			OutputDataFloat(0, 23, WriteIndex, Context.MapUpdate.Particles.Scale.z);
			OutputDataBool(0, 10, WriteIndex, Context.MapUpdate.Particles.SkeletalMeshLocation.FirstFrameBool);
			OutputDataFloat(0, 24, WriteIndex, Context.MapUpdate.Particles.SpriteRotation);
			OutputDataFloat(0, 25, WriteIndex, Context.MapUpdate.Particles.SpriteSize.x);
			OutputDataFloat(0, 26, WriteIndex, Context.MapUpdate.Particles.SpriteSize.y);
			OutputDataInt(0, 11, WriteIndex, Context.MapUpdate.Particles.UniqueID);
			OutputDataFloat(0, 27, WriteIndex, Context.MapUpdate.Particles.Velocity.x);
			OutputDataFloat(0, 28, WriteIndex, Context.MapUpdate.Particles.Velocity.y);
			OutputDataFloat(0, 29, WriteIndex, Context.MapUpdate.Particles.Velocity.z);
		}

}

void CopyInstance(in int InstanceIdx)
{

}
#line 3897 "/Engine/Generated/NiagaraEmitterInstance.ush"
[numthreads( 32 , 1, 1)]
void SimulateMainComputeCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	GDispatchThreadId = DispatchThreadId;
	GGroupThreadId = GroupThreadId;
	GCurrentPhase = -1;
	GEmitterTickCounter = EmitterTickCounter;
	GSimStart = SimStart;
	GRandomSeedOffset = 0;
#line 3918 "/Engine/Generated/NiagaraEmitterInstance.ush"
	const uint InstanceID = UpdateStartInstance + DispatchThreadId.x;
	if (ReadInstanceCountOffset == 0xFFFFFFFF)
	{
		GSpawnStartInstance = 0;
	}
	else
	{
		GSpawnStartInstance = RWInstanceCounts[ReadInstanceCountOffset];
	}
	bool bRunUpdateLogic, bRunSpawnLogic;
#line 3936 "/Engine/Generated/NiagaraEmitterInstance.ush"
	{
	    const int MaxInstances = GSpawnStartInstance + SpawnedInstances;
		bRunUpdateLogic = InstanceID < GSpawnStartInstance && InstanceID < UpdateStartInstance + MaxInstances;
		bRunSpawnLogic = InstanceID >= GSpawnStartInstance && InstanceID < UpdateStartInstance + MaxInstances;
	}

	const float RandomSeedInitialisation = NiagaraInternalNoise(InstanceID * 16384, 0 * 8196, (bRunUpdateLogic ? 4096 : 0) + EmitterTickCounter);

	FSimulationContext Context = (FSimulationContext)0;

	[branch]
	if (bRunUpdateLogic)
	{
		GCurrentPhase = GUpdatePhase;
		SetupExecIndexForGPU();
		InitConstants(Context);
		LoadUpdateVariables(Context, InstanceID);
		ReadDataSets(Context);
		SimulateMapUpdate(Context);


		WriteDataSets(Context);
	}
	else if (bRunSpawnLogic)
	{
		GCurrentPhase = GSpawnPhase;
#line 3970 "/Engine/Generated/NiagaraEmitterInstance.ush"
		{
			SetupExecIndexAndSpawnInfoForGPU();
		}
		InitConstants(Context);
		InitSpawnVariables(Context);
		ReadDataSets(Context);

		Context.MapSpawn.Particles.UniqueID = Engine_Emitter_TotalSpawnedParticles + ExecIndex();
		ConditionalInterpolateParameters(Context);
		SimulateMapSpawn(Context);

		GCurrentPhase = GUpdatePhase;

		TransferAttributes(Context);



		SimulateMapUpdate(Context);
		WriteDataSets(Context);
	}

	StoreUpdateVariables(Context);

}
#line 703 "/Plugin/FX/Niagara/Private/NiagaraEmitterInstanceShader.usf"

#if 0 /*BEGIN_RESOURCE_TABLES*/
View, 130419238
DrawRectangleParameters, 3145983
InstancedView, 232784127
MobileSceneTextures, 90703865
SceneTexturesStruct, 120063476
NULL, 0
View_MaterialTextureBilinearWrapedSampler, View, 8, 0
View_MaterialTextureBilinearClampedSampler, View, 8, 1
View_VolumetricLightmapIndirectionTexture, View, 5, 2
View_VolumetricLightmapBrickAmbientVector, View, 5, 3
View_VolumetricLightmapBrickSHCoefficients0, View, 5, 4
View_VolumetricLightmapBrickSHCoefficients1, View, 5, 5
View_VolumetricLightmapBrickSHCoefficients2, View, 5, 6
View_VolumetricLightmapBrickSHCoefficients3, View, 5, 7
View_VolumetricLightmapBrickSHCoefficients4, View, 5, 8
View_VolumetricLightmapBrickSHCoefficients5, View, 5, 9
View_SkyBentNormalBrickTexture, View, 5, 10
View_DirectionalLightShadowingBrickTexture, View, 5, 11
View_VolumetricLightmapBrickAmbientVectorSampler, View, 8, 12
View_VolumetricLightmapTextureSampler0, View, 8, 13
View_VolumetricLightmapTextureSampler1, View, 8, 14
View_VolumetricLightmapTextureSampler2, View, 8, 15
View_VolumetricLightmapTextureSampler3, View, 8, 16
View_VolumetricLightmapTextureSampler4, View, 8, 17
View_VolumetricLightmapTextureSampler5, View, 8, 18
View_SkyBentNormalTextureSampler, View, 8, 19
View_DirectionalLightShadowingTextureSampler, View, 8, 20
View_GlobalDistanceFieldTexture0, View, 5, 21
View_GlobalDistanceFieldSampler0, View, 8, 22
View_GlobalDistanceFieldTexture1, View, 5, 23
View_GlobalDistanceFieldSampler1, View, 8, 24
View_GlobalDistanceFieldTexture2, View, 5, 25
View_GlobalDistanceFieldSampler2, View, 8, 26
View_GlobalDistanceFieldTexture3, View, 5, 27
View_GlobalDistanceFieldSampler3, View, 8, 28
View_AtmosphereTransmittanceTexture, View, 5, 29
View_AtmosphereTransmittanceTextureSampler, View, 8, 30
View_AtmosphereIrradianceTexture, View, 5, 31
View_AtmosphereIrradianceTextureSampler, View, 8, 32
View_AtmosphereInscatterTexture, View, 5, 33
View_AtmosphereInscatterTextureSampler, View, 8, 34
View_PerlinNoiseGradientTexture, View, 5, 35
View_PerlinNoiseGradientTextureSampler, View, 8, 36
View_PerlinNoise3DTexture, View, 5, 37
View_PerlinNoise3DTextureSampler, View, 8, 38
View_SobolSamplingTexture, View, 5, 39
View_SharedPointWrappedSampler, View, 8, 40
View_SharedPointClampedSampler, View, 8, 41
View_SharedBilinearWrappedSampler, View, 8, 42
View_SharedBilinearClampedSampler, View, 8, 43
View_SharedTrilinearWrappedSampler, View, 8, 44
View_SharedTrilinearClampedSampler, View, 8, 45
View_PreIntegratedBRDF, View, 5, 46
View_PreIntegratedBRDFSampler, View, 8, 47
View_PrimitiveSceneData, View, 6, 48
View_PrimitiveSceneDataTexture, View, 5, 49
View_LightmapSceneData, View, 6, 50
View_TransmittanceLutTexture, View, 5, 51
View_TransmittanceLutTextureSampler, View, 8, 52
View_SkyViewLutTexture, View, 5, 53
View_SkyViewLutTextureSampler, View, 8, 54
View_DistantSkyLightLutTexture, View, 5, 55
View_DistantSkyLightLutTextureSampler, View, 8, 56
View_CameraAerialPerspectiveVolume, View, 5, 57
View_CameraAerialPerspectiveVolumeSampler, View, 8, 58
View_VTFeedbackBuffer, View, 7, 59
View_QuadOverdraw, View, 7, 60
MobileSceneTextures_SceneColorTexture, MobileSceneTextures, 5, 0
MobileSceneTextures_SceneColorTextureSampler, MobileSceneTextures, 8, 1
MobileSceneTextures_SceneDepthTexture, MobileSceneTextures, 5, 2
MobileSceneTextures_SceneDepthTextureSampler, MobileSceneTextures, 8, 3
MobileSceneTextures_SceneAlphaCopyTexture, MobileSceneTextures, 5, 4
MobileSceneTextures_SceneAlphaCopyTextureSampler, MobileSceneTextures, 8, 5
MobileSceneTextures_CustomDepthTexture, MobileSceneTextures, 5, 6
MobileSceneTextures_CustomDepthTextureSampler, MobileSceneTextures, 8, 7
MobileSceneTextures_MobileCustomStencilTexture, MobileSceneTextures, 5, 8
MobileSceneTextures_MobileCustomStencilTextureSampler, MobileSceneTextures, 8, 9
MobileSceneTextures_VirtualTextureFeedbackUAV, MobileSceneTextures, 7, 10
MobileSceneTextures_EyeAdaptationBuffer, MobileSceneTextures, 6, 11
SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct, 5, 0
SceneTexturesStruct_SceneColorTextureSampler, SceneTexturesStruct, 8, 1
SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct, 5, 2
SceneTexturesStruct_SceneDepthTextureSampler, SceneTexturesStruct, 8, 3
SceneTexturesStruct_SceneDepthTextureNonMS, SceneTexturesStruct, 5, 4
SceneTexturesStruct_GBufferATexture, SceneTexturesStruct, 5, 5
SceneTexturesStruct_GBufferBTexture, SceneTexturesStruct, 5, 6
SceneTexturesStruct_GBufferCTexture, SceneTexturesStruct, 5, 7
SceneTexturesStruct_GBufferDTexture, SceneTexturesStruct, 5, 8
SceneTexturesStruct_GBufferETexture, SceneTexturesStruct, 5, 9
SceneTexturesStruct_GBufferFTexture, SceneTexturesStruct, 5, 10
SceneTexturesStruct_GBufferVelocityTexture, SceneTexturesStruct, 5, 11
SceneTexturesStruct_GBufferATextureNonMS, SceneTexturesStruct, 5, 12
SceneTexturesStruct_GBufferBTextureNonMS, SceneTexturesStruct, 5, 13
SceneTexturesStruct_GBufferCTextureNonMS, SceneTexturesStruct, 5, 14
SceneTexturesStruct_GBufferDTextureNonMS, SceneTexturesStruct, 5, 15
SceneTexturesStruct_GBufferETextureNonMS, SceneTexturesStruct, 5, 16
SceneTexturesStruct_GBufferFTextureNonMS, SceneTexturesStruct, 5, 17
SceneTexturesStruct_GBufferVelocityTextureNonMS, SceneTexturesStruct, 5, 18
SceneTexturesStruct_GBufferATextureSampler, SceneTexturesStruct, 8, 19
SceneTexturesStruct_GBufferBTextureSampler, SceneTexturesStruct, 8, 20
SceneTexturesStruct_GBufferCTextureSampler, SceneTexturesStruct, 8, 21
SceneTexturesStruct_GBufferDTextureSampler, SceneTexturesStruct, 8, 22
SceneTexturesStruct_GBufferETextureSampler, SceneTexturesStruct, 8, 23
SceneTexturesStruct_GBufferFTextureSampler, SceneTexturesStruct, 8, 24
SceneTexturesStruct_GBufferVelocityTextureSampler, SceneTexturesStruct, 8, 25
SceneTexturesStruct_ScreenSpaceAOTexture, SceneTexturesStruct, 5, 26
SceneTexturesStruct_ScreenSpaceAOTextureSampler, SceneTexturesStruct, 8, 27
SceneTexturesStruct_CustomDepthTextureNonMS, SceneTexturesStruct, 5, 28
SceneTexturesStruct_CustomDepthTexture, SceneTexturesStruct, 5, 29
SceneTexturesStruct_CustomDepthTextureSampler, SceneTexturesStruct, 8, 30
SceneTexturesStruct_CustomStencilTexture, SceneTexturesStruct, 6, 31
SceneTexturesStruct_SceneStencilTexture, SceneTexturesStruct, 6, 32
SceneTexturesStruct_EyeAdaptation, SceneTexturesStruct, 5, 33
SceneTexturesStruct_SceneColorCopyTexture, SceneTexturesStruct, 5, 34
SceneTexturesStruct_SceneColorCopyTextureSampler, SceneTexturesStruct, 8, 35
NULL, NULL, 0, 0
#endif /*END_RESOURCE_TABLES*/
#if 0 /*DIRECT COMPILE*/
-directcompile -format=PCD3D_SM5 -entry=SimulateMainComputeCS -cs C:/Users/jimzzchen/Documents/VFX_Learning/Saved/ShaderDebugInfo/PCD3D_SM5/HolographicSystem_3DMesh_2/Character/ParticleGPUComputeScript/FNiagaraShader/0/NiagaraEmitterInstanceShader.usf -cflags=4096 -nocrashreports
#endif /*DIRECT COMPILE*/
//
